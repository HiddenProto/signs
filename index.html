<!doctype html>
<!--
  Alternate's Magical Evolution - Minimal playable HTML5 prototype
  - Single-file (HTML/CSS/JS)
  - Implements player movement, aim, charging aura, shield, simple spells, enemies waves,
    XP/leveling with 3-upgrade choices, basic shop, save/load, simple UI sidebars.
  - Multiplayer/Wi-Fi is stubbed (placeholder) — real networking requires a server.
  - This file intentionally includes many comments and features to match the game design spec.
-->
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Alternate's Magical Evolution — Prototype</title>
<style>
  :root{
    --bg:#0b0d10; --panel:#11161a; --accent:#22c1ff; --muted:#88929a;
    --green:#33cc66; --danger:#ff4444;
  }
  html,body{height:100%;margin:0;background:linear-gradient(#061018,#07121a);font-family:Inter,system-ui,Arial;}
  #wrap{display:grid;grid-template-columns:260px 1fr 260px;gap:12px;padding:12px;height:100%;box-sizing:border-box;}
  .panel{background:linear-gradient(180deg,var(--panel),#081017);padding:10px;border-radius:8px;color:#dbe8f2;box-shadow:0 6px 18px rgba(0,0,0,.6);overflow:auto}
  .panel h3{margin:4px 0 8px 0;font-size:14px;color:var(--muted)}
  #left .stat{display:flex;justify-content:space-between;padding:4px 0;border-bottom:1px solid rgba(255,255,255,.03)}
  #right .enemyRow{display:flex;justify-content:space-between;padding:4px 0;border-bottom:1px solid rgba(255,255,255,.03)}
  #center{position:relative;display:flex;flex-direction:column;align-items:center;}
  #gameCanvas{background:linear-gradient(180deg,#09111a,#061018);border-radius:8px;box-shadow:0 10px 30px rgba(0,0,0,.6);width:100%;height:100%;}
  .hud{position:absolute;left:50%;transform:translateX(-50%);bottom:18px;display:flex;gap:8px;align-items:center}
  .btn{background:rgba(255,255,255,.03);border:1px solid rgba(255,255,255,.03);padding:6px 10px;border-radius:6px;color:#e8f9ff;cursor:pointer}
  .small{font-size:12px;padding:4px 6px}
  .green{color:var(--green)}
  .shopGrid{display:grid;grid-template-columns:repeat(2,1fr);gap:8px}
  .shopItem{background:linear-gradient(180deg,#0d1316,#071014);padding:8px;border-radius:6px;border:1px solid rgba(255,255,255,.03);text-align:center}
  .overlay{position:fixed;inset:0;background:rgba(0,0,0,.6);display:none;align-items:center;justify-content:center}
  .modal{background:#071017;padding:16px;border-radius:10px;width:420px;max-width:90%}
  .bar{height:10px;border-radius:6px;background:rgba(255,255,255,.06);overflow:hidden}
  .bar > i{height:100%;display:block;background:linear-gradient(90deg,#33cc66,#22c1ff)}
  .nameTag{position:absolute;font-size:12px;padding:2px 6px;border-radius:100px;background:rgba(0,0,0,.6);backdrop-filter:blur(2px);}
  /* Mobile controls (visual only) */
  .mobileControls{position:absolute;left:8px;bottom:12px;display:none}
  .touchBtn{width:64px;height:64px;border-radius:50%;background:rgba(255,255,255,.04);display:flex;align-items:center;justify-content:center}
  @media (max-width:900px){
    #wrap{grid-template-columns:1fr}
    .panel{display:none}
    .mobileControls{display:block}
  }
  footer{position:absolute;left:12px;bottom:12px;color:var(--muted);font-size:12px}
</style>
</head>
<body>
<div id="wrap">
  <!-- LEFT SIDEBAR: Player Info + Active Spell -->
  <div id="left" class="panel">
    <h3>Player Info</h3>
    <div class="stat"><span>Name</span><strong id="ui_name">Magician</strong></div>
    <div class="stat"><span>Level / XP</span><strong id="ui_level">1 (0/100)</strong></div>
    <div class="stat"><span>HP</span><strong id="ui_hp">100</strong></div>
    <div class="stat"><span>Mana</span><strong id="ui_mana">100</strong></div>
    <div class="stat"><span>ATK</span><strong id="ui_atk">5</strong></div>
    <div class="stat"><span>DEF</span><strong id="ui_def">2</strong></div>
    <div class="stat"><span>PL / MPL</span><strong id="ui_pl">1 / 1</strong></div>
    <h3>Active Spell</h3>
    <div id="activeSpell" style="padding:8px;border-radius:6px;background:rgba(0,0,0,.2);">
      <div><strong id="ui_spell">Magic Shot</strong> <span id="ui_spell_tag" class="small" style="color:var(--muted)">[Tap LMB]</span></div>
      <div style="margin-top:8px">
        <div class="bar" style="margin-bottom:6px"><i id="manaBar" style="width:60%"></i></div>
        <div class="small" style="color:var(--muted)">Charge to increase damage. Hold Space for shield.</div>
      </div>
    </div>

    <h3 style="margin-top:10px">Shop / Save</h3>
    <div style="display:flex;gap:8px;margin-top:6px">
      <button class="btn small" id="openShop">Open Shop</button>
      <button class="btn small" id="saveBtn">Save</button>
      <button class="btn small" id="loadBtn">Load</button>
    </div>

    <h3 style="margin-top:10px">Quick Settings</h3>
    <div style="display:flex;gap:6px;flex-wrap:wrap">
      <button class="btn small" id="toggleGrid">Toggle Grid</button>
      <button class="btn small" id="renameBtn">Rename</button>
      <button class="btn small" id="resetBtn">Reset</button>
    </div>
  </div>

  <!-- CENTER: Canvas -->
  <div id="center" class="panel">
    <canvas id="gameCanvas" width="1200" height="720"></canvas>

    <!-- HUD controls -->
    <div class="hud">
      <div class="btn small" id="castBtn">Cast (LMB)</div>
      <div class="btn small" id="shieldBtn">Shield (Space)</div>
      <div class="btn small" id="cycleLeft">◀</div>
      <div class="btn small" id="cycleRight">▶</div>
      <div class="btn small" id="multiplayerBtn">Multiplayer (stub)</div>
    </div>

    <!-- Mobile controls (visual) -->
    <div class="mobileControls">
      <div style="display:flex;gap:8px;">
        <div class="touchBtn">◯</div>
        <div class="touchBtn">◑</div>
      </div>
    </div>
  </div>

  <!-- RIGHT SIDEBAR: Enemies / Waves / Shop -->
  <div id="right" class="panel">
    <h3>Enemies Info</h3>
    <div style="display:flex;justify-content:space-between">
      <div>Alive: <strong id="ui_alive">0</strong></div>
      <div>Wave: <strong id="ui_wave">0</strong></div>
    </div>
    <div id="enemyList" style="margin-top:8px"></div>

    <h3 style="margin-top:10px">Spellbook</h3>
    <div id="spellList">
      <!-- each item clickable to equip -->
    </div>

    <h3 style="margin-top:10px">Shop Preview</h3>
    <div class="shopGrid">
      <div class="shopItem"><strong>Txt.Cat</strong><div>100</div></div>
      <div class="shopItem"><strong>Fire Wizard</strong><div>500</div></div>
      <div class="shopItem"><strong>Sparkling Pixie</strong><div>300</div></div>
      <div class="shopItem"><strong>Shadow Mage</strong><div>750</div></div>
    </div>

  </div>
</div>

<!-- Overlay modals -->
<div id="overlay" class="overlay">
  <div class="modal" id="modalContent"></div>
</div>

<footer>Prototype — press WASD + mouse or touch. Open console (F12) for debug info.</footer>

<script>
/* --------- Core Game State & Utilities --------- */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false });
let W = canvas.width, H = canvas.height;
let lastTs = 0;
let debug = false;

/* Persistent player data */
let playerData = {
  name: localStorage.getItem('ame_name') || 'Magician',
  level: 1, xp: 0, xpNext: 100,
  hpMax: 100, hp: 100,
  manaMax: 100, mana: 100,
  atk: 5, def: 2,
  pl: 1, mpl: 1,
  credits: parseInt(localStorage.getItem('ame_credits')||'0',10),
  skins: [],
  activeSkin: null,
  spells: ['Magic Shot','Tri-Shot','Beam','Ice'],
  activeSpellIndex: 0
};

/* Simple world */
let world = {
  enemies: [],
  projectiles: [],
  particles: [],
  wave: 0,
  alive: 0,
  grid: false
};

/* Input */
let input = {
  left:false,right:false,up:false,down:false,
  mx:W/2,my:H/2,
  mouseDown:false,charging:false,shield:false
};

/* Player entity */
let player = {
  x:W/2, y:H/2, r:18, color:'#113344', hatColor:'#2aa6ff',
  aimAngle:0, charge:0, chargeMax:1.8, shieldDur:100, shieldMax:100,
  regenCooldown:0 // seconds since enemy nearby
};

/* Spell definitions (simplified) */
const SPELLS = {
  'Magic Shot': { mana:8, base:12, chargeMult:1.6, homingAt:6 },
  'Tri-Shot': { mana:12, base:8, spread:0.35, shots:3 },
  'Beam': { mana:20, base:25, sustain:true },
  'Ice': { mana:10, base:6, slow:0.6 },
  'Lightning': { mana:18, base:10, chain:3 }
};

/* Enemy types template */
const ENEMY_TEMPLATES = {
  Novice: { color:'#ff99cc', hp:20, atk:3, def:0, pl:1, behavior:'random' },
  Weak:   { color:'#88ff77', hp:35, atk:5, def:1, pl:2, behavior:'magic' },
  Intermediate: { color:'#ffff66', hp:70, atk:8, def:2, pl:3, behavior:'dodge' },
  Legend: { color:'#b88cff', hp:150, atk:14, def:4, pl:5, behavior:'beam' },
  Myth: { color:'#9aa0a5', hp:400, atk:30, def:8, pl:8, behavior:'boss' }
};

/* UI elements */
const ui = {
  name: document.getElementById('ui_name'),
  level: document.getElementById('ui_level'),
  hp: document.getElementById('ui_hp'),
  mana: document.getElementById('ui_mana'),
  atk: document.getElementById('ui_atk'),
  def: document.getElementById('ui_def'),
  pl: document.getElementById('ui_pl'),
  spell: document.getElementById('ui_spell'),
  manaBar: document.getElementById('manaBar'),
  alive: document.getElementById('ui_alive'),
  wave: document.getElementById('ui_wave'),
  enemyList: document.getElementById('enemyList'),
  spellList: document.getElementById('spellList'),
  activeSpellTag: document.getElementById('ui_spell_tag')
};

function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
function rand(min,max){return Math.random()*(max-min)+min;}
function dist(a,b,c,d){return Math.hypot(a-c,b-d);}

/* --------- Input handling --------- */
window.addEventListener('keydown', e=>{
  if(e.key==='a' || e.key==='ArrowLeft') input.left=true;
  if(e.key==='d' || e.key==='ArrowRight') input.right=true;
  if(e.key==='w' || e.key==='ArrowUp') input.up=true;
  if(e.key==='s' || e.key==='ArrowDown') input.down=true;
  if(e.code==='Space'){ input.shield=true; }
  if(e.key==='q'){ cycleSpell(-1); }
  if(e.key==='e'){ cycleSpell(1); }
});
window.addEventListener('keyup', e=>{
  if(e.key==='a' || e.key==='ArrowLeft') input.left=false;
  if(e.key==='d' || e.key==='ArrowRight') input.right=false;
  if(e.key==='w' || e.key==='ArrowUp') input.up=false;
  if(e.key==='s' || e.key==='ArrowDown') input.down=false;
  if(e.code==='Space'){ input.shield=false; }
});
canvas.addEventListener('mousemove', e=>{
  const rect = canvas.getBoundingClientRect();
  input.mx = (e.clientX-rect.left) * (canvas.width/rect.width);
  input.my = (e.clientY-rect.top) * (canvas.height/rect.height);
});
canvas.addEventListener('mousedown', e=>{ input.mouseDown=true; input.charging=true; });
canvas.addEventListener('mouseup', e=>{ input.mouseDown=false; fireSpell(); input.charging=false; player.charge=0; });

/* Touch support (simple) */
canvas.addEventListener('touchstart', e=>{
  e.preventDefault();
  const t = e.touches[0]; const r=canvas.getBoundingClientRect();
  input.mx=(t.clientX-r.left)*(canvas.width/r.width);
  input.my=(t.clientY-r.top)*(canvas.height/r.height);
  input.mouseDown=true; input.charging=true;
}, {passive:false});
canvas.addEventListener('touchmove', e=>{
  const t = e.touches[0]; const r=canvas.getBoundingClientRect();
  input.mx=(t.clientX-r.left)*(canvas.width/r.width);
  input.my=(t.clientY-r.top)*(canvas.height/r.height);
}, {passive:false});
canvas.addEventListener('touchend', e=>{ input.mouseDown=false; fireSpell(); input.charging=false; player.charge=0; });

/* --------- Gameplay: Spawning waves --------- */
function spawnWave(){
  world.wave++;
  const wave = world.wave;
  let count = Math.min(12, 3 + Math.floor(wave * 1.2));
  for(let i=0;i<count;i++){
    const kind = chooseEnemyForWave(wave);
    spawnEnemy(kind);
  }
  updateUI();
}

function chooseEnemyForWave(wave){
  if(wave%8===0) return 'Myth';
  if(wave>6 && Math.random()<0.25) return 'Legend';
  if(wave>3 && Math.random()<0.4) return ['Intermediate','Weak'][Math.random()<0.6?0:1];
  return ['Novice','Weak'][Math.random()<0.7?0:1];
}

function spawnEnemy(name){
  const t = ENEMY_TEMPLATES[name];
  const angle = Math.random()*Math.PI*2;
  const r = Math.max(W,H)*0.45;
  const x = W/2 + Math.cos(angle)*r;
  const y = H/2 + Math.sin(angle)*r;
  world.enemies.push({
    id: Math.random().toString(36).slice(2,9),
    type: name, x,y, vx:0,vy:0,
    hp: t.hp, hpMax: t.hp,
    atk: t.atk, def: t.def, pl: t.pl,
    color: t.color, behavior: t.behavior,
    rank: name
  });
  world.alive = world.enemies.length;
}

/* --------- Spells & Projectiles --------- */
function fireSpell(){
  const spellName = playerData.spells[playerData.activeSpellIndex] || 'Magic Shot';
  const sDef = SPELLS[spellName] || SPELLS['Magic Shot'];
  if(playerData.mana < sDef.mana) return;
  // consume mana
  playerData.mana = clamp(playerData.mana - sDef.mana, 0, playerData.manaMax);
  // create projectiles depending on spell
  const angle = Math.atan2(input.my - player.y, input.mx - player.x);
  const speed = 6 + (player.charge*4);
  if(spellName==='Magic Shot'){
    world.projectiles.push({x:player.x + Math.cos(angle)*22, y:player.y + Math.sin(angle)*22,
      vx:Math.cos(angle)*speed, vy:Math.sin(angle)*speed, life:120, dmg:Math.round(sDef.base*(1+player.charge)), pl:playerData.pl, owner:'player', type:'orb'});
  } else if(spellName==='Tri-Shot'){
    for(let i=0;i<3;i++){
      const a = angle + (i-1)*(sDef.spread) * (1 - player.charge*0.3);
      world.projectiles.push({x:player.x + Math.cos(a)*22, y:player.y + Math.sin(a)*22,
        vx:Math.cos(a)*speed, vy:Math.sin(a)*speed, life:120, dmg:Math.round(sDef.base*(1+player.charge*0.8)), pl:playerData.pl, owner:'player', type:'orb'});
    }
  } else if(spellName==='Beam'){
    // simplified: instant beam hit in a line
    const beamRange = 420 + player.charge*180;
    let bx = player.x + Math.cos(angle)*beamRange;
    let by = player.y + Math.sin(angle)*beamRange;
    // damage first enemy hit along line
    let hit = null;
    for(const e of world.enemies){
      const d = Math.abs((e.x-player.x)*(player.y-by)-(e.y-player.y)*(player.x-bx)) / Math.hypot(bx-player.x,by-player.y);
      if(d < 22){
        hit = e; break;
      }
    }
    if(hit){
      hit.hp -= sDef.base * (1 + player.charge*1.2);
      spawnParticle(hit.x,hit.y,8, player.color);
      gainXP(6);
    }
  } else if(spellName==='Ice'){
    world.projectiles.push({x:player.x + Math.cos(angle)*22, y:player.y + Math.sin(angle)*22,
      vx:Math.cos(angle)*speed, vy:Math.sin(angle)*speed, life:120, dmg:sDef.base*(1+player.charge), pl:playerData.pl, owner:'player', type:'ice'});
  } else {
    // fallback simple orb
    world.projectiles.push({x:player.x + Math.cos(angle)*22, y:player.y + Math.sin(angle)*22,
      vx:Math.cos(angle)*speed, vy:Math.sin(angle)*speed, life:120, dmg:sDef.base*(1+player.charge), pl:playerData.pl, owner:'player', type:'orb'});
  }
}

/* --------- Collisions & Simulation --------- */
function updateEntities(dt){
  // player aim angle
  player.aimAngle = Math.atan2(input.my - player.y, input.mx - player.x);

  // movement
  const speedBase = 160;
  let mvx = 0, mvy = 0;
  if(input.left) mvx -= 1; if(input.right) mvx += 1;
  if(input.up) mvy -= 1; if(input.down) mvy += 1;
  if(mvx||mvy){
    const mag = Math.hypot(mvx,mvy);
    player.x += (mvx/mag) * speedBase * dt;
    player.y += (mvy/mag) * speedBase * dt;
  }

  // clamp
  player.x = clamp(player.x, 28, W-28);
  player.y = clamp(player.y, 28, H-28);

  // charge mechanic
  if(input.charging && input.mouseDown){
    player.charge = clamp(player.charge + dt*1.2, 0, player.chargeMax);
  } else {
    player.charge = Math.max(0, player.charge - dt*1.8);
  }

  // mana regen always
  playerData.mana = clamp(playerData.mana + 20*dt, 0, playerData.manaMax);

  // HP regen if no enemies nearby
  const nearestEnemyDist = world.enemies.length ? Math.min(...world.enemies.map(e=>dist(e.x,e.y,player.x,player.y))) : Infinity;
  if(nearestEnemyDist > 240){ playerData.hp = clamp(playerData.hp + 5*dt, 0, playerData.hpMax); }

  // projectiles
  for(let i=world.projectiles.length-1;i>=0;i--){
    const p = world.projectiles[i];
    p.x += p.vx * dt * 60/1;
    p.y += p.vy * dt * 60/1;
    p.life--;
    // remove out of bounds or expired
    if(p.life<=0 || p.x< -40 || p.x>W+40 || p.y<-40 || p.y>H+40){ world.projectiles.splice(i,1); continue; }
    // collisions
    if(p.owner==='player'){
      for(let j=world.enemies.length-1;j>=0;j--){
        const e = world.enemies[j];
        if(dist(p.x,p.y,e.x,e.y) < 18 + (p.type==='orb'?6:8)){
          // PL interactions (simplified): if projectile pl < enemy pl then reduce dmg; equal -> explosion
          let dmg = p.dmg || 6;
          if(p.pl < e.pl) dmg = Math.round(dmg*0.6);
          else if(p.pl === e.pl) dmg = Math.round(dmg*1.2), spawnExplosion(p.x,p.y);
          e.hp -= Math.max(1, Math.round(dmg - e.def*0.5));
          spawnParticle(e.x,e.y,6,'#ffcc66');
          world.projectiles.splice(i,1);
          if(e.hp <= 0){
            // drop credits and xp
            playerData.credits += Math.max(2, Math.floor(e.hpMax/6));
            gainXP(8 + Math.floor(e.hpMax/10));
            world.enemies.splice(j,1);
            world.alive = world.enemies.length;
          }
          break;
        }
      }
    }
  }

  // enemies AI simple
  for(const e of world.enemies){
    // move toward player with some behavior
    const angle = Math.atan2(player.y - e.y, player.x - e.x);
    const spd = 40 + (e.pl*8);
    // random jitter for novice
    if(e.behavior==='random'){
      e.x += Math.cos(angle)*spd*dt + Math.sin(Math.random()*6)*10*dt;
      e.y += Math.sin(angle)*spd*dt + Math.cos(Math.random()*6)*10*dt;
    } else if(e.behavior==='magic'){
      // keep distance
      const d = dist(e.x,e.y,player.x,player.y);
      if(d < 160) { e.x -= Math.cos(angle)*spd*dt; e.y -= Math.sin(angle)*spd*dt; }
      else { e.x += Math.cos(angle)*spd*dt * 0.6; e.y += Math.sin(angle)*spd*dt * 0.6; }
      // occasionally fire small projectile
      if(Math.random() < 0.006) {
        world.projectiles.push({x:e.x,y:e.y,vx:Math.cos(angle)*3+rand(-0.6,0.6),vy:Math.sin(angle)*3+rand(-0.6,0.6),life:120,dmg:e.atk,pl:e.pl,owner:'enemy',type:'orb'});
      }
    } else if(e.behavior==='beam'){
      // slowly approach and sometimes fire burst
      e.x += Math.cos(angle)*spd*0.9*dt; e.y += Math.sin(angle)*spd*0.9*dt;
      if(Math.random()<0.004) {
        // wide beam simulated by projectiles fan
        for(let i=0;i<6;i++){
          const a = angle + (i-3)*0.12;
          world.projectiles.push({x:e.x+Math.cos(a)*18,y:e.y+Math.sin(a)*18,vx:Math.cos(a)*5,vy:Math.sin(a)*5,life:90,dmg:Math.round(e.atk*0.8),pl:e.pl,owner:'enemy',type:'orb'});
        }
      }
    } else {
      e.x += Math.cos(angle)*spd*dt; e.y += Math.sin(angle)*spd*dt;
    }
    // contact damage
    if(dist(e.x,e.y,player.x,player.y) < 28){
      // shield interactions
      if(input.shield && player.shieldDur > 0){
        // shield absorbs and depletes
        player.shieldDur = clamp(player.shieldDur - (e.atk*0.6), 0, player.shieldMax);
        spawnParticle(player.x + Math.cos(angle)*20, player.y + Math.sin(angle)*20, 4, '#88ccff');
      } else {
        // take damage
        const dmg = Math.max(1, e.atk - Math.round(playerData.def*0.3));
        playerData.hp = clamp(playerData.hp - dmg*dt*5, 0, playerData.hpMax);
      }
    }
  }

  // world simple auto wave spawn
  if(world.enemies.length === 0 && world.wave < 100){
    setTimeout(spawnWave, 600);
  }

  // particles lifetime
  for(let i=world.particles.length-1;i>=0;i--){
    const p = world.particles[i];
    p.life -= dt*60;
    p.x += p.vx * dt * 60;
    p.y += p.vy * dt * 60;
    if(p.life<=0) world.particles.splice(i,1);
  }

  // update UI mirrors
  updateUI();
}

/* --------- Visual helpers --------- */
function spawnParticle(x,y,count,color){
  for(let i=0;i<count;i++){
    world.particles.push({x:x,y:y,vx:rand(-2,2),vy:rand(-2,2),life:rand(20,80),col:color});
  }
}
function spawnExplosion(x,y){
  spawnParticle(x,y,18,'#ffbb33');
  spawnParticle(x,y,6,'#ff3344');
}

/* --------- XP & Leveling --------- */
function gainXP(n){
  playerData.xp += n;
  while(playerData.xp >= playerData.xpNext){
    playerData.xp -= playerData.xpNext;
    playerData.level++;
    playerData.xpNext = Math.floor(playerData.xpNext * 1.35);
    // give upgrade choices
    setTimeout(()=>{ showLevelUpOptions(); }, 80);
  }
}

/* Level-up UI with 3 random upgrades */
function showLevelUpOptions(){
  const choices = [];
  const possible = [
    {t:'HP',desc:'+20 HP',apply:()=>{ playerData.hpMax += 20; playerData.hp += 20; }},
    {t:'Mana',desc:'+20 Mana',apply:()=>{ playerData.manaMax += 20; playerData.mana += 20 }},
    {t:'ATK',desc:'+2 ATK',apply:()=>{ playerData.atk += 2 }},
    {t:'DEF',desc:'+1 DEF',apply:()=>{ playerData.def += 1 }},
    {t:'Spell',desc:'Unlock: Penta-Shot',apply:()=>{ if(!playerData.spells.includes('Penta-Shot')) playerData.spells.push('Penta-Shot') }},
    {t:'PL',desc:'+1 PL',apply:()=>{ playerData.pl += 1 }},
    {t:'MPL',desc:'+1 MPL',apply:()=>{ playerData.mpl += 1 }}
  ];
  // pick 3 distinct random
  while(choices.length<3){
    const c = possible[Math.floor(Math.random()*possible.length)];
    if(!choices.includes(c)) choices.push(c);
  }
  // show modal
  const modal = document.getElementById('modalContent');
  modal.innerHTML = '<h3>Level Up! Choose 1</h3>';
  const container = document.createElement('div');
  container.style.display='flex';container.style.gap='8px';
  choices.forEach((c,idx)=>{
    const btn = document.createElement('button');
    btn.className='btn';
    btn.style.flex='1';
    btn.textContent = c.t + ' — ' + c.desc;
    btn.onclick = ()=>{
      c.apply();
      closeModal();
      // update spell list UI after unlock
      renderSpellbook();
    };
    container.appendChild(btn);
  });
  modal.appendChild(container);
  document.getElementById('overlay').style.display='flex';
}

function closeModal(){ document.getElementById('overlay').style.display='none'; document.getElementById('modalContent').innerHTML=''; }

/* --------- UI Rendering --------- */
function updateUI(){
  ui.name.textContent = playerData.name;
  ui.level.textContent = `${playerData.level} (${playerData.xp}/${playerData.xpNext})`;
  ui.hp.textContent = `${Math.round(playerData.hp)}/${playerData.hpMax}`;
  ui.mana.textContent = `${Math.round(playerData.mana)}/${playerData.manaMax}`;
  ui.atk.textContent = playerData.atk;
  ui.def.textContent = playerData.def;
  ui.pl.textContent = `${playerData.pl} / ${playerData.mpl}`;
  ui.spell.textContent = playerData.spells[playerData.activeSpellIndex] || 'Magic Shot';
  ui.alive.textContent = world.enemies.length;
  ui.wave.textContent = world.wave;
  ui.manaBar.style.width = `${(playerData.mana/playerData.manaMax)*100}%`;
  // enemy list
  ui.enemyList.innerHTML = '';
  world.enemies.slice(0,8).forEach(e=>{
    const div = document.createElement('div'); div.className='enemyRow';
    div.innerHTML = `<div style="display:flex;gap:8px;align-items:center"><div style="width:12px;height:12px;border-radius:50%;background:${e.color}"></div><strong style="font-size:13px">${e.rank}</strong></div>
                     <div style="text-align:right"><div style="font-size:12px">${Math.max(0,Math.round(e.hp))} HP</div><div style="font-size:11px;color:var(--muted)">PL ${e.pl}</div></div>`;
    ui.enemyList.appendChild(div);
  });
}

/* Spellbook render */
function renderSpellbook(){
  ui.spellList.innerHTML = '';
  playerData.spells.forEach((s,idx)=>{
    const el = document.createElement('div');
    el.style.display='flex'; el.style.justifyContent='space-between'; el.style.padding='6px'; el.style.cursor='pointer';
    el.style.borderBottom='1px solid rgba(255,255,255,.03)';
    el.innerHTML = `<div>${s}</div><div style="opacity:${playerData.activeSpellIndex===idx?1:0.6}">${idx===playerData.activeSpellIndex?'<strong style="color:var(--green)">Selected</strong>':'Select'}</div>`;
    el.onclick = ()=>{ playerData.activeSpellIndex = idx; renderSpellbook(); updateUI(); };
    ui.spellList.appendChild(el);
  });
}

/* Cycle spells */
function cycleSpell(dir){
  playerData.activeSpellIndex = (playerData.activeSpellIndex + dir + playerData.spells.length) % playerData.spells.length;
  renderSpellbook(); updateUI();
}

/* --------- Drawing --------- */
function draw(dt){
  ctx.clearRect(0,0,W,H);
  // optional grid
  if(world.grid){
    ctx.strokeStyle = 'rgba(255,255,255,0.02)';
    ctx.lineWidth=1;
    for(let x=0;x<W;x+=40){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
    for(let y=0;y<H;y+=40){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
  }

  // draw particles
  for(const p of world.particles){
    ctx.globalAlpha = clamp(p.life/80,0,1);
    ctx.fillStyle = p.col || '#fff';
    ctx.fillRect(p.x, p.y, 2,2);
    ctx.globalAlpha = 1;
  }

  // draw projectiles
  for(const pr of world.projectiles){
    if(pr.type==='ice') ctx.fillStyle='#88d7ff';
    else ctx.fillStyle = pr.owner==='player' ? '#66ddff' : '#ff9999';
    ctx.beginPath(); ctx.arc(pr.x,pr.y,6,0,Math.PI*2); ctx.fill();
  }

  // enemies
  for(const e of world.enemies){
    ctx.fillStyle = e.color;
    ctx.beginPath(); ctx.arc(e.x,e.y,18,0,Math.PI*2); ctx.fill();
    // HP bar
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillRect(e.x-22,e.y-30,44,6);
    ctx.fillStyle = 'rgba(255,180,90,0.9)';
    const w = clamp(e.hp/e.hpMax,0,1)*44;
    ctx.fillRect(e.x-22,e.y-30,w,6);
  }

  // draw player shield if active
  if(input.shield && player.shieldDur>0){
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = '#88ccff';
    ctx.beginPath(); ctx.arc(player.x,player.y,player.r + 22,0,Math.PI*2); ctx.fill();
    ctx.globalAlpha = 1;
  }

  // charge aura
  if(player.charge>0.02){
    const radius = player.r + 12 + player.charge*38;
    ctx.globalAlpha = 0.18 + Math.min(0.4, player.charge*0.25);
    ctx.fillStyle = '#33ccff';
    ctx.beginPath(); ctx.arc(player.x,player.y,radius,0,Math.PI*2); ctx.fill();
    ctx.globalAlpha = 1;
  }

  // player body (simple stick/box)
  ctx.fillStyle = player.color;
  ctx.fillRect(player.x-8, player.y-14, 16,28); // body
  // hat
  ctx.fillStyle = player.hatColor;
  ctx.fillRect(player.x-10, player.y-26, 20,8);
  // right arm as barrel pointing to aim
  const ax = player.x + Math.cos(player.aimAngle)*26;
  const ay = player.y + Math.sin(player.aimAngle)*26;
  ctx.strokeStyle = '#224466'; ctx.lineWidth = 6; ctx.lineCap='round';
  ctx.beginPath(); ctx.moveTo(player.x+8, player.y-4); ctx.lineTo(ax,ay); ctx.stroke();
  // name tag
  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  ctx.fillRect(player.x-36, player.y-48, 72,18);
  ctx.fillStyle = '#eaf8ff'; ctx.font='12px sans-serif'; ctx.textAlign='center';
  ctx.fillText(playerData.name, player.x, player.y-36);

  // HUD text small
  ctx.fillStyle = '#88e6ff';
  ctx.font='14px sans-serif';
  ctx.textAlign='left';
  ctx.fillText(`Wave: ${world.wave}  Enemies: ${world.enemies.length}`, 12,20);
}

/* --------- Save / Load / Shop / Misc UI --------- */
document.getElementById('openShop').addEventListener('click', ()=>{
  const modal = document.getElementById('modalContent');
  modal.innerHTML = `<h3>Shop</h3><div style="display:flex;gap:8px;flex-direction:column;">
    <div style="display:flex;justify-content:space-between"><div>Txt.Cat (Skin)</div><div>100 <button class="btn small">Buy</button></div></div>
    <div style="display:flex;justify-content:space-between"><div>Fire Wizard (Skin)</div><div>500 <button class="btn small">Buy</button></div></div>
    <div style="text-align:right;margin-top:8px"><button class="btn" id="closeShop">Close</button></div>
  </div>`;
  document.getElementById('overlay').style.display='flex';
  document.getElementById('closeShop').onclick = closeModal;
});
document.getElementById('saveBtn').addEventListener('click', ()=>{
  localStorage.setItem('ame_save', JSON.stringify(playerData));
  localStorage.setItem('ame_credits', playerData.credits);
  alert('Saved locally.');
});
document.getElementById('loadBtn').addEventListener('click', ()=>{
  const s = localStorage.getItem('ame_save');
  if(s){ playerData = JSON.parse(s); renderSpellbook(); updateUI(); alert('Loaded.'); } else alert('No save found.');
});
document.getElementById('renameBtn').addEventListener('click', ()=>{
  const name = prompt('Enter name', playerData.name);
  if(name){ playerData.name = name; localStorage.setItem('ame_name', name); updateUI(); }
});
document.getElementById('resetBtn').addEventListener('click', ()=>{
  if(confirm('Reset progress?')){
    localStorage.clear(); location.reload();
  }
});
document.getElementById('toggleGrid').addEventListener('click', ()=>{ world.grid = !world.grid; });
document.getElementById('cycleLeft').addEventListener('click', ()=>{ cycleSpell(-1); });
document.getElementById('cycleRight').addEventListener('click', ()=>{ cycleSpell(1); });
document.getElementById('shieldBtn').addEventListener('mousedown', ()=>{ input.shield=true; });
document.getElementById('shieldBtn').addEventListener('mouseup', ()=>{ input.shield=false; });
document.getElementById('multiplayerBtn').addEventListener('click', ()=>{
  const modal = document.getElementById('modalContent');
  modal.innerHTML = `<h3>Multiplayer (Auto-WiFi)</h3><div style="color:var(--muted);margin-bottom:8px">Networking is stubbed in this prototype. Real-time multiplayer requires a signaling server or WebSocket endpoint. This is a placeholder UI for auto-connect and name/stats display.</div><div style="text-align:right"><button class="btn" id="closeMP">Close</button></div>`;
  document.getElementById('overlay').style.display='flex';
  document.getElementById('closeMP').onclick = closeModal;
});

/* Shop & skins simplified - clicks buy simulate deduction */
document.querySelectorAll('.shopItem').forEach((el,idx)=>{
  el.addEventListener('click', ()=>{
    alert('Shop click (preview). Use Save to persist credits.');
  });
});

/* Overlay close on click outside */
document.getElementById('overlay').addEventListener('click', (e)=>{ if(e.target.id==='overlay') closeModal(); });

/* --------- Game loop --------- */
function loop(ts){
  const dt = lastTs ? Math.min(0.05,(ts-lastTs)/1000) : 0.016;
  lastTs = ts;
  updateEntities(dt);
  draw(dt);
  requestAnimationFrame(loop);
}

/* initialize */
function init(){
  // place player at center
  player.x = W/2; player.y = H/2;
  renderSpellbook();
  updateUI();
  // spawn first wave
  spawnWave();
  requestAnimationFrame(loop);
}

/* Handle window resize to scale canvas */
function fitCanvas(){
  const rect = canvas.getBoundingClientRect();
  // adjust internally if css scaled
  W = canvas.width;
  H = canvas.height;
}
window.addEventListener('resize', fitCanvas);

init();
</script>
</body>
</html>
