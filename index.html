<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Alternate's Magical Evolution</title>
    <style>
        body { margin: 0; background: black; }
        canvas { display: block; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <script>
        // Game Constants
        const CANVAS_WIDTH = window.innerWidth;
        const CANVAS_HEIGHT = window.innerHeight;
        const ARENA_WIDTH = 800;
        const ARENA_HEIGHT = 600;
        const PLAYER_SIZE = 20;
        const ENEMY_SIZE = 25;
        const PROJECTILE_SPEED = 5;
        const BLOOD_PARTICLE_COUNT = 20;
        const DEATH_BLOOD_COUNT = 100;
        const PARTICLE_LIFE = 60;
        const SHIELD_RADIUS = 40;
        const OMNI_SHIELD_BONUS = 20;
        const MAX_PL = 16;
        const WAVE_ENEMY_BASE = 1;
        const WAVE_ENEMY_INCREASE = 1 / 3; // +1 every 3 levels
        const BOSS_EVERY = 5;
        const PL_INCREASE_EVERY = Math.floor(Math.random() * 3) + 3; // 3-5
        const UPGRADE_CHOICES = 3;

        // Game State Enum
        const GAME_STATES = {
            MENU: 'menu',
            PLAYING: 'playing',
            LEVELUP: 'levelup',
            GAMEOVER: 'gameover'
        };

        // Entity Types
        const ENTITY_TYPES = {
            PLAYER: 'player',
            ENEMY: 'enemy',
            PROJECTILE: 'projectile',
            PARTICLE: 'particle',
            EFFECT: 'effect'
        };

        // Enemy Types
        const ENEMY_TYPES = [
            'Fire', // Red, fireballs
            'Ice', // Blue, slows
            'Shadow', // Purple, homing
            'Storm', // Yellow, lightning
            'Beast' // Green, fast shots
        ];

        // Colors for enemy types
        const ENEMY_COLORS = {
            'Fire': 'red',
            'Ice': 'cyan',
            'Shadow': 'purple',
            'Storm': 'yellow',
            'Beast': 'green'
        };

        // Ability List
        const ABILITIES = [
            { id: 1, name: 'Magic Shot', unlocked: true, cd: 500, mana: 10, description: 'Basic orange orb projectile', color: 'orange', type: 'projectile', damage: 10, hp: 10, homing: false },
            { id: 2, name: 'Tri-Shot', unlocked: false, cd: 800, mana: 15, description: '3-way spread blue shots', color: 'blue', type: 'spread', spread: 3, angle: Math.PI / 6, damage: 8, hp: 8 },
            { id: 3, name: 'Beam Shot', unlocked: false, cd: 1000, mana: 20, description: 'White laser line, pierces', color: 'white', type: 'beam', duration: 30, damage: 15, hp: 20, pierce: true },
            { id: 4, name: 'Ice Shard', unlocked: false, cd: 600, mana: 12, description: 'Blue triangle, slows 50% for 2s', color: 'blue', type: 'projectile', damage: 12, hp: 12, slow: 0.5, slowDuration: 120 },
            { id: 5, name: 'Lightning', unlocked: false, cd: 1200, mana: 25, description: 'Yellow zig-zag bolt, chains', color: 'yellow', type: 'lightning', damage: 18, hp: 15, chain: 3 },
            { id: 6, name: 'Curve Shot', unlocked: false, cd: 700, mana: 14, description: 'Green homing arc', color: 'green', type: 'projectile', damage: 10, hp: 10, homing: true, curve: true },
            { id: 7, name: 'Shield Breaker', unlocked: false, cd: 1500, mana: 30, description: 'Purple AoE pulse, breaks shields', color: 'purple', type: 'aoe', radius: 100, damage: 20, shieldBreak: 50 },
            { id: 8, name: 'Homing Missile', unlocked: false, cd: 900, mana: 18, description: 'Red rocket, explodes', color: 'red', type: 'projectile', damage: 25, hp: 20, homing: true, explode: 50 },
            { id: 9, name: 'Force Wave', unlocked: false, cd: 1100, mana: 22, description: 'Blue shockwave cone', color: 'blue', type: 'cone', angle: Math.PI / 4, range: 200, damage: 15, knockback: 5 },
            { id: 10, name: 'Penta Shot', unlocked: false, cd: 600, mana: 20, description: '5-way spread, rapid', color: 'cyan', type: 'spread', spread: 5, angle: Math.PI / 8, damage: 7, hp: 7 },
            { id: 11, name: 'Recursive Shot', unlocked: false, cd: 1300, mana: 28, description: 'Bouncing orb', color: 'green', type: 'projectile', damage: 12, hp: 12, bounces: 3 },
            { id: 12, name: 'Shield Attack', unlocked: false, cd: 1000, mana: 25, description: 'Shield projectile, reflects', color: 'white', type: 'projectile', damage: 10, hp: 15, reflect: true },
            { id: 13, name: 'Beta Laser', unlocked: false, cd: 2000, mana: 40, description: 'Thick red beam, DoT', color: 'red', type: 'beam', duration: 60, damage: 30, hp: 30, dot: 5, dotDuration: 180 },
            { id: 14, name: 'Super Speed', unlocked: false, cd: 3000, mana: 50, description: 'Temp speed x2 for 5s', type: 'buff', duration: 300, speedMult: 2 },
            { id: 15, name: 'Precharged Rings', unlocked: false, cd: 5000, mana: 60, description: '6 mana balls around, enhance default', type: 'ring', balls: 6, damageMult: 3, color: 'purple' }
        ];

        // Upgrade Types
        const UPGRADE_TYPES = [
            { type: 'unlock', weight: 70, func: unlockAbility },
            { type: 'buff_damage', weight: 10, func: buffDamage },
            { type: 'buff_cd', weight: 10, func: buffCD },
            { type: 'stat_atk', weight: 5, func: statATK },
            { type: 'stat_def', weight: 5, func: statDEF },
            { type: 'stat_pl', weight: 2, func: statPL },
            { type: 'shield_yield', weight: 5, func: shieldYield },
            { type: 'shield_omni', weight: 3, func: shieldOmni }
        ];

        // Global Variables
        let canvas, ctx;
        let gameState = GAME_STATES.MENU;
        let player;
        let enemies = [];
        let projectiles = [];
        let particles = [];
        let effects = [];
        let keys = {};
        let mouse = { x: 0, y: 0 };
        let currentAbility = 0;
        let level = 1;
        let xp = 0;
        let xpNeeded = 100;
        let wave = 1;
        let upgrades = [];
        let usedUpgrades = [];
        let lastTime = 0;
        let saveKey = 'alternateGameSave';

        // Player Class
        class Player {
            constructor() {
                this.type = ENTITY_TYPES.PLAYER;
                this.x = CANVAS_WIDTH / 2;
                this.y = CANVAS_HEIGHT / 2;
                this.size = PLAYER_SIZE;
                this.color = 'blue';
                this.hatColor = 'purple';
                this.speed = 3;
                this.health = 100;
                this.maxHealth = 100;
                this.mana = 100;
                this.maxMana = 100;
                this.atk = 1;
                this.def = 1;
                this.pl = 1;
                this.shieldActive = false;
                this.shieldDurability = 100;
                this.maxShieldDurability = 100;
                this.shieldYield = 1.0;
                this.shieldOmni = false;
                this.shieldRegenRate = 0.5;
                this.depletedRegenBonus = 2;
                this.direction = 0;
                this.abilities = ABILITIES.map(a => ({...a}));
                this.prechargedBalls = [];
                this.buffs = [];
                this.loadSave();
            }

            update(delta) {
                // Movement
                let dx = 0, dy = 0;
                if (keys['w'] || keys['ArrowUp']) dy -= 1;
                if (keys['s'] || keys['ArrowDown']) dy += 1;
                if (keys['a'] || keys['ArrowLeft']) dx -= 1;
                if (keys['d'] || keys['ArrowRight']) dx += 1;
                if (dx || dy) {
                    const mag = Math.sqrt(dx*dx + dy*dy);
                    dx /= mag;
                    dy /= mag;
                    this.x += dx * this.speed * (this.getBuff('speedMult') || 1) * delta / 16.67;
                    this.y += dy * this.speed * (this.getBuff('speedMult') || 1) * delta / 16.67;
                }

                // Bound to arena
                this.x = Math.max(PLAYER_SIZE / 2, Math.min(this.x, CANVAS_WIDTH - PLAYER_SIZE / 2));
                this.y = Math.max(PLAYER_SIZE / 2, Math.min(this.y, CANVAS_HEIGHT - PLAYER_SIZE / 2));

                // Direction to mouse
                this.direction = Math.atan2(mouse.y - this.y, mouse.x - this.x);

                // Mana regen
                this.mana = Math.min(this.maxMana, this.mana + 20 * delta / 1000);

                // Shield
                if (this.shieldActive) {
                    this.mana -= 0.1 * delta / 16.67; // Drain over time
                    if (this.mana <= 0) this.shieldActive = false;
                } else {
                    // Regen shield durability
                    let regen = this.shieldRegenRate;
                    if (this.shieldDurability <= 0) regen *= this.depletedRegenBonus;
                    this.shieldDurability = Math.min(this.maxShieldDurability, this.shieldDurability + regen * delta / 16.67);
                }

                // Health regen
                this.health = Math.min(this.maxHealth, this.health + 0.1 * delta / 16.67);

                // Update buffs
                this.buffs = this.buffs.filter(b => {
                    b.duration -= delta / 16.67;
                    return b.duration > 0;
                });

                // Update precharged rings
                if (this.prechargedBalls.length > 0) {
                    const angleStep = 2 * Math.PI / this.prechargedBalls.length;
                    this.prechargedBalls.forEach((ball, i) => {
                        ball.angle = i * angleStep + performance.now() / 1000 % (2 * Math.PI);
                        ball.x = this.x + Math.cos(ball.angle) * 30;
                        ball.y = this.y + Math.sin(ball.angle) * 30;
                    });
                }
            }

            draw() {
                // Square body
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - this.size / 2, this.y - this.size / 2, this.size, this.size);

                // Purple hat
                ctx.fillStyle = this.hatColor;
                ctx.beginPath();
                ctx.moveTo(this.x - this.size / 2, this.y - this.size / 2 - 10);
                ctx.lineTo(this.x + this.size / 2, this.y - this.size / 2 - 10);
                ctx.lineTo(this.x, this.y - this.size / 2 - 30);
                ctx.fill();

                // Barrel arm
                ctx.strokeStyle = 'gray';
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x + Math.cos(this.direction) * 20, this.y + Math.sin(this.direction) * 20);
                ctx.stroke();

                // Shield
                if (this.shieldActive) {
                    ctx.strokeStyle = 'green';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, SHIELD_RADIUS + (this.shieldOmni ? OMNI_SHIELD_BONUS : 0), 0, 2 * Math.PI);
                    ctx.stroke();
                }

                // Precharged balls
                this.prechargedBalls.forEach(ball => {
                    ctx.fillStyle = ball.color;
                    ctx.beginPath();
                    ctx.arc(ball.x, ball.y, 5, 0, 2 * Math.PI);
                    ctx.fill();
                });
            }

            castAbility() {
                const abi = this.abilities[currentAbility];
                if (!abi.unlocked || abi.currentCD > 0 || this.mana < abi.mana) return;

                let enhanced = false;
                if (abi.id === 1 && this.prechargedBalls.length > 0) {
                    enhanced = true;
                    abi.damage *= abi.damageMult || 3;
                    const ball = this.prechargedBalls.pop();
                    // Use ball position or something
                }

                this.createProjectile(abi);

                if (enhanced) abi.damage /= 3; // Reset

                this.mana -= abi.mana;
                abi.currentCD = abi.cd;
            }

            createProjectile(abi) {
                switch (abi.type) {
                    case 'projectile':
                        projectiles.push(new Projectile(this.x, this.y, this.direction, abi, this));
                        break;
                    case 'spread':
                        for (let i = 0; i < abi.spread; i++) {
                            const offset = (i - (abi.spread - 1) / 2) * abi.angle;
                            projectiles.push(new Projectile(this.x, this.y, this.direction + offset, abi, this));
                        }
                        break;
                    case 'beam':
                        effects.push(new BeamEffect(this.x, this.y, this.direction, abi, this));
                        break;
                    case 'lightning':
                        // Find target
                        const target = this.findNearestEnemy();
                        if (target) effects.push(new LightningEffect(this, target, abi));
                        break;
                    case 'aoe':
                        effects.push(new AoeEffect(mouse.x, mouse.y, abi, this));
                        break;
                    case 'cone':
                        effects.push(new ConeEffect(this.x, this.y, this.direction, abi, this));
                        break;
                    case 'buff':
                        this.buffs.push({ type: abi.name, duration: abi.duration, speedMult: abi.speedMult });
                        break;
                    case 'ring':
                        this.prechargedBalls = [];
                        for (let i = 0; i < abi.balls; i++) {
                            this.prechargedBalls.push({ color: abi.color, angle: 0 });
                        }
                        break;
                }
            }

            findNearestEnemy() {
                let minDist = Infinity;
                let nearest = null;
                enemies.forEach(e => {
                    const dist = Math.hypot(e.x - this.x, e.y - this.y);
                    if (dist < minDist) {
                        minDist = dist;
                        nearest = e;
                    }
                });
                return nearest;
            }

            getBuff(type) {
                const buff = this.buffs.find(b => b[type]);
                return buff ? buff[type] : null;
            }

            takeDamage(dmg, attacker) {
                if (this.shieldActive) {
                    const absorbed = dmg * this.shieldYield;
                    this.shieldDurability -= absorbed;
                    this.mana -= absorbed;
                    if (this.shieldDurability <= 0) this.shieldActive = false;
                    addParticles(this.x, this.y, 'yellow', 10); // Sparks
                    // Reflect if reflect ability
                    return 0;
                } else {
                    const effectiveDmg = Math.max(1, dmg - this.def + this.def * (this.pl / MAX_PL * 0.05)); // PL ignores 5% def
                    this.health -= effectiveDmg;
                    addBloodParticles(this.x, this.y, 10);
                    if (this.health <= 0) gameOver();
                    return effectiveDmg;
                }
            }

            checkRingCollision(entity) {
                this.prechargedBalls = this.prechargedBalls.filter(ball => {
                    const dist = Math.hypot(ball.x - entity.x, ball.y - entity.y);
                    if (dist < this.size / 2 + entity.size / 2 + 5) {
                        entity.takeDamage(20 * this.pl, this);
                        this.takeDamage(10, entity);
                        addParticles(ball.x, ball.y, 'purple', 20);
                        return false;
                    }
                    return true;
                });
            }

            save() {
                const saveData = {
                    health: this.maxHealth,
                    mana: this.maxMana,
                    atk: this.atk,
                    def: this.def,
                    pl: this.pl,
                    abilities: this.abilities.map(a => ({id: a.id, unlocked: a.unlocked, damage: a.damage, cd: a.cd})),
                    shieldYield: this.shieldYield,
                    shieldOmni: this.shieldOmni
                };
                localStorage.setItem(saveKey, JSON.stringify(saveData));
            }

            loadSave() {
                const saved = localStorage.getItem(saveKey);
                if (saved) {
                    const data = JSON.parse(saved);
                    this.maxHealth = data.health;
                    this.health = data.health;
                    this.maxMana = data.mana;
                    this.mana = data.mana;
                    this.atk = data.atk;
                    this.def = data.def;
                    this.pl = data.pl;
                    this.shieldYield = data.shieldYield;
                    this.shieldOmni = data.shieldOmni;
                    this.abilities.forEach(a => {
                        const savedA = data.abilities.find(sa => sa.id === a.id);
                        if (savedA) {
                            a.unlocked = savedA.unlocked;
                            a.damage = savedA.damage || a.damage;
                            a.cd = savedA.cd || a.cd;
                        }
                    });
                }
            }
        }

        // Enemy Class
        class Enemy {
            constructor(type, pl) {
                this.type = ENTITY_TYPES.ENEMY;
                this.enemyType = type;
                this.color = ENEMY_COLORS[type];
                this.x = Math.random() * CANVAS_WIDTH;
                this.y = Math.random() * CANVAS_HEIGHT;
                this.size = ENEMY_SIZE * (level / BOSS_EVERY === wave ? 1.5 : 1);
                this.speed = 1 + level * 0.2;
                this.health = 50 + level * 20;
                this.maxHealth = this.health;
                this.mana = 100;
                this.maxMana = 100;
                this.atk = 10 + level * 5;
                this.def = 5 + level * 2;
                this.pl = Math.floor(level / 2) + (level % BOSS_EVERY === 0 ? 1 : 0);
                this.shieldActive = this.pl >= 4 ? Math.random() > 0.5 : false;
                this.shieldDurability = 100;
                this.maxShieldDurability = 100;
                this.direction = 0;
                this.abilities = this.getAbilitiesForTypeAndPL();
                this.currentAbility = 0;
                this.castTimer = 0;
                this.dodgeChance = 0.02 * this.pl;
            }

            getAbilitiesForTypeAndPL() {
                let abis = [ABILITIES[0]]; // Basic always
                if (this.pl >= 2) abis.push(ABILITIES[1]);
                if (this.pl >= 3) abis.push(ABILITIES[3]); // Ice for all, but type specific?
                // Type specific
                switch (this.enemyType) {
                    case 'Fire':
                        if (this.pl >= 4) abis.push(ABILITIES[7]); // Homing missile like fire
                        if (this.pl >= 8) abis.push(ABILITIES[12]); // Beta laser
                        break;
                    case 'Ice':
                        if (this.pl >= 4) abis.push(ABILITIES[3]); // Ice shard
                        if (this.pl >= 8) abis.push(ABILITIES[6]); // Shield breaker?
                        break;
                    case 'Shadow':
                        if (this.pl >= 4) abis.push(ABILITIES[5]); // Curve
                        if (this.pl >= 8) abis.push(ABILITIES[7]); // Homing
                        break;
                    case 'Storm':
                        if (this.pl >= 4) abis.push(ABILITIES[4]); // Lightning
                        if (this.pl >= 8) abis.push(ABILITIES[2]); // Beam
                        break;
                    case 'Beast':
                        if (this.pl >= 4) abis.push(ABILITIES[8]); // Force wave
                        if (this.pl >= 8) abis.push(ABILITIES[10]); // Recursive
                        break;
                }
                if (this.pl >= 12) abis.push(ABILITIES[Math.floor(Math.random() * ABILITIES.length)]);
                if (this.pl >= 16) abis = ABILITIES.slice(); // Full kit
                return abis.map(a => ({...a, currentCD: 0}));
            }

            update(delta) {
                // AI logic
                this.castTimer -= delta;
                const distToPlayer = Math.hypot(player.x - this.x, player.y - this.y);
                this.direction = Math.atan2(player.y - this.y, player.x - this.x);

                // Chase if far
                if (distToPlayer > 30) {
                    this.x += Math.cos(this.direction) * this.speed * delta / 16.67;
                    this.y += Math.sin(this.direction) * this.speed * delta / 16.67;
                }

                // Dodge
                if (Math.random() < this.dodgeChance / 60) {
                    // Dodge logic, move perpendicular
                    const perp = this.direction + Math.PI / 2;
                    this.x += Math.cos(perp) * this.speed * 2 * delta / 16.67;
                    this.y += Math.sin(perp) * this.speed * 2 * delta / 16.67;
                }

                // Cast ability
                if (this.castTimer <= 0) {
                    this.chooseAndCastAbility(distToPlayer);
                }

                // Mana regen
                this.mana = Math.min(this.maxMana, this.mana + 10 * delta / 1000);

                // Shield regen similar to player
                if (!this.shieldActive) {
                    let regen = 0.5;
                    if (this.shieldDurability <= 0) regen *= 2;
                    this.shieldDurability = Math.min(this.maxShieldDurability, this.shieldDurability + regen * delta / 16.67);
                }

                // Activate shield if low health or random
                if (this.pl >= 4 && !this.shieldActive && (this.health < this.maxHealth / 2 || Math.random() < 0.01)) {
                    this.shieldActive = true;
                }
                if (this.shieldActive && this.mana <= 0) this.shieldActive = false;
            }

            chooseAndCastAbility(dist) {
                // Table of circumstances
                let abi;
                if (dist < 50 && this.abilities.find(a => a.type === 'aoe')) {
                    abi = this.abilities.find(a => a.type === 'aoe' && a.currentCD <= 0 && this.mana >= a.mana);
                } else if (dist > 200 && this.abilities.find(a => a.homing)) {
                    abi = this.abilities.find(a => a.homing && a.currentCD <= 0 && this.mana >= a.mana);
                } else if (this.pl > 8 && Math.random() < 0.3) {
                    abi = this.abilities[Math.floor(Math.random() * this.abilities.length)];
                } else {
                    abi = this.abilities[0]; // Basic
                }
                if (abi && abi.currentCD <= 0 && this.mana >= abi.mana) {
                    this.createProjectile(abi);
                    this.mana -= abi.mana;
                    abi.currentCD = abi.cd / (1 + this.pl / MAX_PL); // Lower CD with PL
                    this.castTimer = abi.cd / 2 + Math.random() * 1000; // Random delay
                }
            }

            createProjectile(abi) {
                // Similar to player
                switch (abi.type) {
                    case 'projectile':
                        projectiles.push(new Projectile(this.x, this.y, this.direction, abi, this));
                        break;
                    // Add other types similarly
                    case 'spread':
                        for (let i = 0; i < abi.spread; i++) {
                            const offset = (i - (abi.spread - 1) / 2) * abi.angle;
                            projectiles.push(new Projectile(this.x, this.y, this.direction + offset, abi, this));
                        }
                        break;
                    case 'beam':
                        effects.push(new BeamEffect(this.x, this.y, this.direction, abi, this));
                        break;
                    case 'lightning':
                        effects.push(new LightningEffect(this, player, abi));
                        break;
                    case 'aoe':
                        effects.push(new AoeEffect(player.x, player.y, abi, this)); // Target player
                        break;
                    case 'cone':
                        effects.push(new ConeEffect(this.x, this.y, this.direction, abi, this));
                        break;
                }
            }

            draw() {
                // Square body
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - this.size / 2, this.y - this.size / 2, this.size, this.size);

                // Barrel arm
                ctx.strokeStyle = 'gray';
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x + Math.cos(this.direction) * 20, this.y + Math.sin(this.direction) * 20);
                ctx.stroke();

                // Health bar
                ctx.fillStyle = 'red';
                ctx.fillRect(this.x - this.size / 2, this.y - this.size / 2 - 10, this.size * (this.health / this.maxHealth), 5);

                // Mana bar
                ctx.fillStyle = 'blue';
                ctx.fillRect(this.x - this.size / 2, this.y - this.size / 2 - 15, this.size * (this.mana / this.maxMana), 5);

                // Shield
                if (this.shieldActive) {
                    ctx.strokeStyle = 'green';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, SHIELD_RADIUS, 0, 2 * Math.PI);
                    ctx.stroke();
                }
            }

            takeDamage(dmg, attacker) {
                if (this.shieldActive) {
                    const absorbed = dmg;
                    this.shieldDurability -= absorbed;
                    if (this.shieldDurability <= 0) this.shieldActive = false;
                    addParticles(this.x, this.y, 'yellow', 10); // Sparks
                    // Reflect
                    if (Math.random() < 0.5) {
                        // Change projectile owner to null or reflect direction
                    }
                    return 0;
                } else {
                    const effectiveDmg = Math.max(1, dmg - this.def + this.def * (attacker.pl / MAX_PL * 0.05));
                    this.health -= effectiveDmg;
                    addBloodParticles(this.x, this.y, BLOOD_PARTICLE_COUNT);
                    if (this.health <= 0) this.die();
                    return effectiveDmg;
                }
            }

            die() {
                addBloodParticles(this.x, this.y, DEATH_BLOOD_COUNT);
                xp += 10 + level * 5;
                checkLevelUp();
                enemies = enemies.filter(e => e !== this);
                if (enemies.length === 0) nextWave();
            }
        }

        // Projectile Class
        class Projectile {
            constructor(x, y, direction, abi, owner) {
                this.x = x;
                this.y = y;
                this.direction = direction;
                this.speed = PROJECTILE_SPEED;
                this.size = 5;
                this.color = abi.color;
                this.damage = abi.damage * (1 + owner.atk / 10) * (1 + owner.pl / MAX_PL);
                this.hp = abi.hp * (1 + owner.pl / MAX_PL);
                this.owner = owner;
                this.abi = abi;
                this.trail = [];
            }

            update(delta) {
                this.x += Math.cos(this.direction) * this.speed * delta / 16.67;
                this.y += Math.sin(this.direction) * this.speed * delta / 16.67;

                // Homing
                if (this.abi.homing) {
                    const target = this.findTarget();
                    if (target) {
                        const targetDir = Math.atan2(target.y - this.y, target.x - this.x);
                        this.direction = lerpAngle(this.direction, targetDir, 0.1);
                    }
                }

                // Curve
                if (this.abi.curve) {
                    this.direction += 0.05; // Simple curve
                }

                // Bounces
                if (this.abi.bounces > 0) {
                    if (this.x < 0 || this.x > CANVAS_WIDTH) {
                        this.direction = Math.PI - this.direction;
                        this.abi.bounces--;
                    }
                    if (this.y < 0 || this.y > CANVAS_HEIGHT) {
                        this.direction = -this.direction;
                        this.abi.bounces--;
                    }
                }

                // Trail
                this.trail.push({x: this.x, y: this.y});
                if (this.trail.length > 10) this.trail.shift();

                // Out of bounds
                if (this.x < 0 || this.x > CANVAS_WIDTH || this.y < 0 || this.y > CANVAS_HEIGHT) {
                    this.destroy();
                }
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, 2 * Math.PI);
                ctx.fill();

                // Trail
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                this.trail.forEach(p => ctx.lineTo(p.x, p.y));
                ctx.stroke();
            }

            findTarget() {
                // Find nearest opposite entity
                const targets = this.owner === player ? enemies : [player];
                let minDist = Infinity;
                let nearest = null;
                targets.forEach(t => {
                    const dist = Math.hypot(t.x - this.x, t.y - this.y);
                    if (dist < minDist) {
                        minDist = dist;
                        nearest = t;
                    }
                });
                return nearest;
            }

            checkCollision() {
                // Vs entities
                const targets = this.owner === player ? enemies : [player];
                targets.forEach(t => {
                    const dist = Math.hypot(t.x - this.x, t.y - this.y);
                    const hitRadius = t.shieldActive ? SHIELD_RADIUS : t.size / 2 + this.size;
                    if (dist < hitRadius) {
                        const dmg = t.takeDamage(this.damage, this.owner);
                        if (this.abi.pierce) this.hp -= dmg;
                        else this.destroy();
                        if (this.abi.slow) t.speed *= this.abi.slow; // Apply slow
                        if (this.abi.dot) {
                            // Add DoT effect
                        }
                        if (this.abi.explode) {
                            // AoE damage
                            addAoeDamage(this.x, this.y, this.abi.explode, this.owner);
                        }
                    }
                });

                // Vs other projectiles
                projectiles.forEach(p => {
                    if (p !== this && p.owner !== this.owner) {
                        const dist = Math.hypot(p.x - this.x, p.y - this.y);
                        if (dist < this.size + p.size) {
                            // Collide
                            const strength1 = this.damage * (1 + this.owner.pl / MAX_PL);
                            const strength2 = p.damage * (1 + p.owner.pl / MAX_PL);
                            if (strength1 > strength2) {
                                p.destroy();
                                this.hp -= strength2 / strength1 * this.hp;
                            } else if (strength2 > strength1) {
                                this.destroy();
                                p.hp -= strength1 / strength2 * p.hp;
                            } else {
                                this.destroy();
                                p.destroy();
                            }
                        }
                    }
                });

                if (this.hp <= 0) this.destroy();
            }

            destroy() {
                projectiles = projectiles.filter(p => p !== this);
            }
        }

        // Beam Effect
        class BeamEffect {
            constructor(x, y, direction, abi, owner) {
                this.x = x;
                this.y = y;
                this.direction = direction;
                this.duration = abi.duration;
                this.width = 5;
                this.color = abi.color;
                this.damage = abi.damage / 60; // Per frame
                this.owner = owner;
                this.abi = abi;
            }

            update(delta) {
                this.duration -= delta / 16.67;
                if (this.duration <= 0) this.destroy();

                // Update position if owner moves
                this.x = this.owner.x;
                this.y = this.owner.y;
                this.direction = Math.atan2(mouse.y - this.y, mouse.x - this.x); // For player, for enemy to player

                // Check hits
                const length = 1000; // Long beam
                const endX = this.x + Math.cos(this.direction) * length;
                const endY = this.y + Math.sin(this.direction) * length;
                const targets = this.owner === player ? enemies : [player];
                targets.forEach(t => {
                    // Line circle intersection
                    if (lineCircleIntersect(this.x, this.y, endX, endY, t.x, t.y, t.size / 2)) {
                        t.takeDamage(this.damage * delta / 16.67, this.owner);
                    }
                });
            }

            draw() {
                ctx.strokeStyle = this.color;
                ctx.lineWidth = this.width;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                const length = 1000;
                ctx.lineTo(this.x + Math.cos(this.direction) * length, this.y + Math.sin(this.direction) * length);
                ctx.stroke();
            }

            destroy() {
                effects = effects.filter(e => e !== this);
            }
        }

        // Lightning Effect
        class LightningEffect {
            constructor(source, target, abi) {
                this.source = source;
                this.target = target;
                this.abi = abi;
                this.damage = abi.damage;
                this.chains = abi.chain || 0;
                this.duration = 10; // Short
            }

            update(delta) {
                this.duration -= delta / 16.67;
                if (this.duration <= 0) this.destroy();

                // Hit target
                this.target.takeDamage(this.damage / this.chains, this.source);

                // Chain
                if (this.chains > 0) {
                    const nextTarget = this.findNextTarget();
                    if (nextTarget) {
                        effects.push(new LightningEffect(this.target, nextTarget, {...this.abi, chain: this.chains - 1}));
                    }
                }
            }

            draw() {
                ctx.strokeStyle = this.abi.color;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(this.source.x, this.source.y);
                // Zigzag
                const segments = 5;
                const dx = (this.target.x - this.source.x) / segments;
                const dy = (this.target.y - this.source.y) / segments;
                for (let i = 1; i < segments; i++) {
                    const px = this.source.x + dx * i + (Math.random() - 0.5) * 20;
                    const py = this.source.y + dy * i + (Math.random() - 0.5) * 20;
                    ctx.lineTo(px, py);
                }
                ctx.lineTo(this.target.x, this.target.y);
                ctx.stroke();
            }

            findNextTarget() {
                const targets = this.source === player ? enemies : [player];
                let minDist = Infinity;
                let nearest = null;
                targets.forEach(t => {
                    if (t !== this.target) {
                        const dist = Math.hypot(t.x - this.target.x, t.y - this.target.y);
                        if (dist < minDist && dist < 100) {
                            minDist = dist;
                            nearest = t;
                        }
                    }
                });
                return nearest;
            }

            destroy() {
                effects = effects.filter(e => e !== this);
            }
        }

        // Aoe Effect
        class AoeEffect {
            constructor(x, y, abi, owner) {
                this.x = x;
                this.y = y;
                this.radius = abi.radius;
                this.color = abi.color;
                this.damage = abi.damage;
                this.owner = owner;
                this.duration = 20; // Expand then gone
                this.currentRadius = 0;
            }

            update(delta) {
                this.duration -= delta / 16.67;
                this.currentRadius += this.radius / this.duration;
                if (this.duration <= 0) this.destroy();

                // Hit
                const targets = this.owner === player ? enemies : [player];
                targets.forEach(t => {
                    const dist = Math.hypot(t.x - this.x, t.y - this.y);
                    if (dist < this.currentRadius) {
                        t.takeDamage(this.damage, this.owner);
                        if (this.abi.shieldBreak) t.shieldDurability -= this.abi.shieldBreak + this.owner.pl * 10;
                    }
                });
            }

            draw() {
                ctx.fillStyle = this.color + '44'; // Transparent
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.currentRadius, 0, 2 * Math.PI);
                ctx.fill();
            }

            destroy() {
                effects = effects.filter(e => e !== this);
            }
        }

        // Cone Effect
        class ConeEffect {
            constructor(x, y, direction, abi, owner) {
                this.x = x;
                this.y = y;
                this.direction = direction;
                this.angle = abi.angle;
                this.range = abi.range;
                this.color = abi.color;
                this.damage = abi.damage;
                this.knockback = abi.knockback;
                this.owner = owner;
                this.duration = 10;
            }

            update(delta) {
                this.duration -= delta / 16.67;
                if (this.duration <= 0) this.destroy();

                // Hit
                const targets = this.owner === player ? enemies : [player];
                targets.forEach(t => {
                    const dx = t.x - this.x;
                    const dy = t.y - this.y;
                    const dist = Math.hypot(dx, dy);
                    const ang = Math.atan2(dy, dx);
                    const diff = Math.abs(ang - this.direction) % (2 * Math.PI);
                    if (dist < this.range && diff < this.angle / 2) {
                        t.takeDamage(this.damage, this.owner);
                        // Knockback
                        t.x += Math.cos(this.direction) * this.knockback;
                        t.y += Math.sin(this.direction) * this.knockback;
                    }
                });
            }

            draw() {
                ctx.fillStyle = this.color + '44';
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.arc(this.x, this.y, this.range, this.direction - this.angle / 2, this.direction + this.angle / 2);
                ctx.fill();
            }

            destroy() {
                effects = effects.filter(e => e !== this);
            }
        }

        // Particle Class
        class Particle {
            constructor(x, y, color, vx, vy, life) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.vx = vx;
                this.vy = vy;
                this.life = life;
                this.size = 2;
            }

            update(delta) {
                this.x += this.vx * delta / 16.67;
                this.y += this.vy * delta / 16.67;
                this.life -= delta / 16.67;
                if (this.life <= 0) this.destroy();
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * (this.life / PARTICLE_LIFE), 0, 2 * Math.PI);
                ctx.fill();
            }

            destroy() {
                particles = particles.filter(p => p !== this);
            }
        }

        // Functions
        function addParticles(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * 2 * Math.PI;
                const speed = Math.random() * 5 + 1;
                particles.push(new Particle(x, y, color, Math.cos(angle) * speed, Math.sin(angle) * speed, PARTICLE_LIFE));
            }
        }

        function addBloodParticles(x, y, count) {
            addParticles(x, y, 'red', count);
        }

        function addAoeDamage(x, y, radius, owner) {
            const abi = {radius, damage: 10}; // Example
            effects.push(new AoeEffect(x, y, abi, owner));
        }

        function init() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            canvas.width = CANVAS_WIDTH;
            canvas.height = CANVAS_HEIGHT;

            player = new Player();

            // Event listeners
            window.addEventListener('keydown', e => keys[e.key] = true);
            window.addEventListener('keyup', e => keys[e.key] = false);
            canvas.addEventListener('mousemove', e => {
                mouse.x = e.clientX;
                mouse.y = e.clientY;
            });
            canvas.addEventListener('click', () => {
                if (gameState === GAME_STATES.PLAYING) player.castAbility();
            });
            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            });

            // Space for shield
            window.addEventListener('keydown', e => {
                if (e.key === ' ') player.shieldActive = true;
            });
            window.addEventListener('keyup', e => {
                if (e.key === ' ') player.shieldActive = false;
            });

            // Cycle ability ,
            window.addEventListener('keydown', e => {
                if (e.key === ',') {
                    currentAbility = (currentAbility + 1) % player.abilities.length;
                }
            });

            requestAnimationFrame(gameLoop);
        }

        function gameLoop(timestamp) {
            const delta = timestamp - lastTime;
            lastTime = timestamp;

            update(delta);
            draw();

            requestAnimationFrame(gameLoop);
        }

        function update(delta) {
            if (gameState === GAME_STATES.PLAYING) {
                player.update(delta);

                enemies.forEach(e => e.update(delta));
                projectiles.forEach(p => {
                    p.update(delta);
                    p.checkCollision();
                });
                particles.forEach(p => p.update(delta));
                effects.forEach(e => e.update(delta));

                // Check ring collisions
                enemies.forEach(e => player.checkRingCollision(e));

                // CD tick
                player.abilities.forEach(a => a.currentCD = Math.max(0, a.currentCD - delta));

                // God mode
                if (player.pl >= MAX_PL && Math.random() < 0.01) {
                    // Screen shake
                    ctx.translate(Math.random() * 10 - 5, Math.random() * 10 - 5);
                }
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Arena black
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            player.draw();
            enemies.forEach(e => e.draw());
            projectiles.forEach(p => p.draw());
            particles.forEach(p => p.draw());
            effects.forEach(e => e.draw());

            // UI
            drawUI();

            // Reset translate if shake
            ctx.setTransform(1, 0, 0, 1, 0, 0);
        }

        function drawUI() {
            ctx.fillStyle = 'white';
            ctx.font = '20px Arial';

            // Top left stats
            ctx.fillText(`Health: ${Math.floor(player.health)}/${player.maxHealth}`, 10, 30);
            ctx.fillText(`Mana: ${Math.floor(player.mana)}/${player.maxMana}`, 10, 60);
            ctx.fillText(`PL: ${player.pl}`, 10, 90);
            ctx.fillText(`ATK: ${player.atk}`, 10, 120);
            ctx.fillText(`DEF: ${player.def}`, 10, 150);
            ctx.fillText(`Level: ${level}`, 10, 180);
            ctx.fillText(`XP: ${xp}/${xpNeeded}`, 10, 210);

            // Right spell list
            const startX = canvas.width - 200;
            ctx.fillText('Abilities:', startX, 30);
            player.abilities.forEach((a, i) => {
                ctx.fillStyle = a.unlocked ? (i === currentAbility ? 'green' : 'white') : 'gray';
                ctx.fillText(`${a.name} ${a.unlocked ? '' : '[LOCKED]'} CD: ${Math.ceil(a.currentCD / 1000)}s`, startX, 60 + i * 30);
            });

            // Bottom controls
            ctx.fillStyle = 'white';
            ctx.fillText('WASD/Arrows: Move, Mouse: Aim/Click Fire, , : Cycle, Space: Shield', 10, canvas.height - 30);

            // Enemy stats on side
            ctx.fillText('Enemies:', canvas.width - 400, 30);
            enemies.forEach((e, i) => {
                ctx.fillText(`${e.enemyType} PL:${e.pl} ATK:${e.atk} DEF:${e.def} HP:${Math.floor(e.health)} Abilities: ${e.abilities.map(a => a.name).join(', ')}`, canvas.width - 400, 60 + i * 30);
            });

            if (gameState === GAME_STATES.MENU) {
                ctx.fillStyle = 'white';
                ctx.font = '40px Arial';
                ctx.fillText('Alternate\'s Magical Evolution', canvas.width / 2 - 200, canvas.height / 2 - 100);
                ctx.font = '30px Arial';
                ctx.fillText('Press P to Play', canvas.width / 2 - 100, canvas.height / 2);
                ctx.fillText('Press A for Attributes', canvas.width / 2 - 150, canvas.height / 2 + 50);
            }

            if (gameState === GAME_STATES.LEVELUP) {
                ctx.fillStyle = 'white';
                ctx.font = '30px Arial';
                ctx.fillText('Level Up! Choose Upgrade:', canvas.width / 2 - 150, canvas.height / 2 - 100);
                upgrades.forEach((u, i) => {
                    ctx.fillText(u.description, canvas.width / 2 - 200, canvas.height / 2 + i * 50);
                });
            }

            if (gameState === GAME_STATES.GAMEOVER) {
                ctx.fillStyle = 'red';
                ctx.font = '40px Arial';
                ctx.fillText('Game Over', canvas.width / 2 - 100, canvas.height / 2);
                ctx.font = '30px Arial';
                ctx.fillText('Press R to Restart', canvas.width / 2 - 150, canvas.height / 2 + 50);
            }
        }

        function nextWave() {
            wave++;
            const numEnemies = WAVE_ENEMY_BASE + Math.floor(level * WAVE_ENEMY_INCREASE);
            for (let i = 0; i < numEnemies; i++) {
                const type = ENEMY_TYPES[Math.floor(Math.random() * ENEMY_TYPES.length)];
                enemies.push(new Enemy(type, level / 2));
            }
            if (wave % BOSS_EVERY === 0) {
                // Boss
                const bossType = ENEMY_TYPES[Math.floor(Math.random() * ENEMY_TYPES.length)];
                const boss = new Enemy(bossType, level);
                boss.size *= 1.5;
                boss.health *= 2;
                boss.atk *= 1.5;
                enemies.push(boss);
            }
            player.save();
        }

        function checkLevelUp() {
            if (xp >= xpNeeded) {
                level++;
                xp = 0;
                xpNeeded += 50;
                gameState = GAME_STATES.LEVELUP;
                generateUpgrades();
                if (level % PL_INCREASE_EVERY === 0 && player.pl < MAX_PL) player.pl++;
            }
        }

        function generateUpgrades() {
            upgrades = [];
            const totalWeight = UPGRADE_TYPES.reduce((sum, ut) => sum + ut.weight, 0);
            for (let i = 0; i < UPGRADE_CHOICES; i++) {
                let rand = Math.random() * totalWeight;
                let selected;
                for (let ut of UPGRADE_TYPES) {
                    rand -= ut.weight;
                    if (rand <= 0) {
                        selected = ut;
                        break;
                    }
                }
                const upgrade = selected.func();
                if (upgrade && !usedUpgrades.includes(upgrade.type + upgrade.id)) {
                    upgrades.push(upgrade);
                } else i--; // Retry if duplicate or invalid
            }
        }

        // Upgrade functions
        function unlockAbility() {
            const locked = player.abilities.filter(a => !a.unlocked);
            if (locked.length === 0) return null;
            const abi = locked[Math.floor(Math.random() * locked.length)];
            return {type: 'unlock', id: abi.id, description: `Unlock ${abi.name}`, apply: () => abi.unlocked = true};
        }

        function buffDamage() {
            const abi = player.abilities[Math.floor(Math.random() * player.abilities.length)];
            if (!abi.unlocked) return null;
            return {type: 'buff_damage', id: abi.id, description: `+10 Damage to ${abi.name}`, apply: () => abi.damage += 10};
        }

        function buffCD() {
            const abi = player.abilities[Math.floor(Math.random() * player.abilities.length)];
            if (!abi.unlocked) return null;
            return {type: 'buff_cd', id: abi.id, description: `-50ms CD to ${abi.name}`, apply: () => abi.cd = Math.max(100, abi.cd - 50)};
        }

        function statATK() {
            return {type: 'stat_atk', description: `+2-5 ATK`, apply: () => player.atk += Math.floor(Math.random() * 4) + 2};
        }

        function statDEF() {
            return {type: 'stat_def', description: `+2-5 DEF`, apply: () => player.def += Math.floor(Math.random() * 4) + 2};
        }

        function statPL() {
            if (player.pl >= MAX_PL) return null;
            return {type: 'stat_pl', description: `+1 PL`, apply: () => player.pl++};
        }

        function shieldYield() {
            return {type: 'shield_yield', description: `Shield Yield -0.1`, apply: () => player.shieldYield = Math.max(0.5, player.shieldYield - 0.1)};
        }

        function shieldOmni() {
            if (player.shieldOmni) return null;
            return {type: 'shield_omni', description: `Omni Shield +20 Radius`, apply: () => player.shieldOmni = true};
        }

        function gameOver() {
            gameState = GAME_STATES.GAMEOVER;
            localStorage.removeItem(saveKey);
        }

        // Helper functions
        function lerpAngle(a, b, t) {
            const diff = (b - a + Math.PI) % (2 * Math.PI) - Math.PI;
            return a + diff * t;
        }

        function lineCircleIntersect(x1, y1, x2, y2, cx, cy, r) {
            // Math to check intersection
            const dx = x2 - x1;
            const dy = y2 - y1;
            const fx = x1 - cx;
            const fy = y1 - cy;
            const a = dx*dx + dy*dy;
            const b = 2 * (fx*dx + fy*dy);
            const c = fx*fx + fy*fy - r*r;
            const discriminant = b*b - 4*a*c;
            return discriminant >= 0;
        }

        // Menu handling
        window.addEventListener('keydown', e => {
            if (gameState === GAME_STATES.MENU) {
                if (e.key.toLowerCase() === 'p') {
                    gameState = GAME_STATES.PLAYING;
                    nextWave();
                }
                if (e.key.toLowerCase() === 'a') {
                    // Show attributes, perhaps console or alert
                    alert(`Stats: ${JSON.stringify({atk: player.atk, def: player.def, pl: player.pl})}`);
                }
            }
            if (gameState === GAME_STATES.LEVELUP) {
                if (e.key >= '1' && e.key <= '3') {
                    const choice = parseInt(e.key) - 1;
                    if (upgrades[choice]) {
                        upgrades[choice].apply();
                        usedUpgrades.push(upgrades[choice].type + upgrades[choice].id);
                        gameState = GAME_STATES.PLAYING;
                    }
                }
            }
            if (gameState === GAME_STATES.GAMEOVER) {
                if (e.key.toLowerCase() === 'r') {
                    location.reload();
                }
            }
        });

        init();
    </script>
</body>
</html>
