<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Alternate's Magical Evolution</title>
    <style>
        body { margin: 0; background: black; display: flex; justify-content: center; align-items: center; height: 100vh; font-family: Arial, sans-serif; color: white; }
        canvas { border: 1px solid white; background: black; }
    </style>
</head>
<body>
    <canvas id="canvas" width="800" height="600"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const GAME_WIDTH = 800;
        const GAME_HEIGHT = 600;

        class Vector {
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }
            add(v) { return new Vector(this.x + v.x, this.y + v.y); }
            sub(v) { return new Vector(this.x - v.x, this.y - v.y); }
            mul(s) { return new Vector(this.x * s, this.y * s); }
            dot(v) { return this.x * v.x + this.y * v.y; }
            mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
            norm() {
                const m = this.mag();
                return m > 0 ? this.mul(1 / m) : new Vector(0, 0);
            }
        }

        class Entity {
            constructor(x, y, color, size = 10) {
                this.pos = new Vector(x, y);
                this.vel = new Vector(0, 0);
                this.color = color;
                this.size = size;
                this.health = 100;
                this.maxHealth = 100;
                this.speed = 3;
                this.atk = 20;
                this.def = 10;
                this.pl = 1;
                this.debuffs = [];
                this.slowMult = 1;
                this.owner = null; // for projs
            }
            update(dt) {
                this.pos = this.pos.add(this.vel.mul(dt));
                // Clamp bounds
                this.pos.x = Math.max(0, Math.min(GAME_WIDTH, this.pos.x));
                this.pos.y = Math.max(0, Math.min(GAME_HEIGHT, this.pos.y));
                // Debuffs
                this.debuffs = this.debuffs.filter(d => {
                    d.duration -= dt;
                    if (d.type === 'dot') this.health -= d.dotValue * dt;
                    if (d.type === 'slow') this.slowMult = d.value;
                    return d.duration > 0;
                });
                this.slowMult = this.debuffs.some(d => d.type === 'slow') ? this.debuffs.find(d => d.type === 'slow').value : 1;
                if (this.debuffs.some(d => d.type === 'stun')) this.vel = new Vector(0, 0);
            }
            takeDamage(dmg, type, attackerPl) {
                let effectiveDmg = Math.max(1, dmg - this.def * (1 - 0.01 * attackerPl));
                if (type === 'shieldAttack') effectiveDmg = dmg; // ignore def
                this.health -= effectiveDmg;
                return effectiveDmg;
            }
            applyDebuff(type, duration, value) {
                this.debuffs.push({ type, duration, value: value || 1, dotValue: value || 0 });
            }
            render(ctx, animOffset = 0) {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.pos.x, this.pos.y - this.size / 2, this.size / 2, 0, Math.PI * 2);
                ctx.fill(); // head
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(this.pos.x, this.pos.y);
                ctx.lineTo(this.pos.x, this.pos.y + this.size * 1.2);
                ctx.stroke(); // body
                // Simple arms
                const armAngle = Math.sin(animOffset) * 0.3;
                ctx.beginPath();
                ctx.moveTo(this.pos.x, this.pos.y);
                ctx.lineTo(this.pos.x + Math.cos(armAngle) * this.size * 0.8, this.pos.y + Math.sin(armAngle) * this.size * 0.8);
                ctx.stroke();
                // Legs
                const legAngle = Math.sin(animOffset * 1.5) * 0.2;
                ctx.beginPath();
                ctx.moveTo(this.pos.x, this.pos.y + this.size * 1.2);
                ctx.lineTo(this.pos.x - legAngle * this.size * 0.5, this.pos.y + this.size * 1.7);
                ctx.moveTo(this.pos.x, this.pos.y + this.size * 1.2);
                ctx.lineTo(this.pos.x + legAngle * this.size * 0.5, this.pos.y + this.size * 1.7);
                ctx.stroke();
                if (this.pl > 8) {
                    ctx.shadowColor = 'gold';
                    ctx.shadowBlur = 5;
                    ctx.beginPath();
                    ctx.arc(this.pos.x, this.pos.y - this.size / 2, this.size / 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
                // Health bar
                ctx.fillStyle = 'red';
                ctx.fillRect(this.pos.x - this.size, this.pos.y - this.size - 5, this.size * 2, 3);
                ctx.fillStyle = 'green';
                ctx.fillRect(this.pos.x - this.size, this.pos.y - this.size - 5, this.size * 2 * (this.health / this.maxHealth), 3);
            }
        }

        class Player extends Entity {
            constructor() {
                super(GAME_WIDTH / 2, GAME_HEIGHT / 2, 'blue');
                this.maxHealth = 100;
                this.health = 100;
                this.maxMana = 100;
                this.mana = 100;
                this.pl = 1;
                this.atk = 20;
                this.def = 10;
                this.level = 1;
                this.xp = 0;
                this.xpToNext = 100;
                this.unlockedAbilities = [new Ability('Magic Shot', 0.5, 5, 20, 'projectile', 'orange', this.pl, 0)];
                this.unlocks = [0];
                this.selectedAbility = 0;
                this.shieldActive = false;
                this.shieldStrength = 0;
                this.shieldMax = 100;
                this.shieldYield = 1.0;
                this.speedBuff = 1;
                this.speedBuffTimer = 0;
                this.invulnTimer = 0;
                this.animOffset = 0;
                this.trailTimer = 0;
            }
            update(dt) {
                super.update(dt);
                this.mana = Math.min(this.maxMana, this.mana + 20 * dt);
                this.animOffset += dt * 2;
                if (this.vel.mag() > 0.1) {
                    this.trailTimer += dt;
                    if (this.trailTimer > 0.1) {
                        particles.push(new Particle(this.pos.sub(this.vel.norm().mul(5)), this.vel.mul(-1).norm().mul(50), 'blue', 0.5));
                        this.trailTimer = 0;
                    }
                }
                if (this.shieldActive) {
                    this.shieldStrength = Math.min(this.shieldMax, this.shieldStrength + 50 * dt);
                } else {
                    this.shieldStrength = Math.max(0, this.shieldStrength - 50 * dt);
                }
                if (this.speedBuffTimer > 0) {
                    this.speedBuffTimer -= dt;
                    if (this.pl >= 12) this.invulnTimer = Math.max(this.invulnTimer - dt, 0);
                    if (this.speedBuffTimer <= 0) this.speedBuff = 1;
                }
                this.speed = (3 * this.speedBuff * this.slowMult) * (1 + this.pl / 32);
                this.vel = this.vel.mul(this.slowMult);
                this.unlockedAbilities.forEach(a => { if (a.cd > 0) a.cd = Math.max(0, a.cd - dt); });
                // Input move
                let inputVel = new Vector(0, 0);
                if (keys['w'] || keys['ArrowUp']) inputVel.y -= 1;
                if (keys['s'] || keys['ArrowDown']) inputVel.y += 1;
                if (keys['a'] || keys['ArrowLeft']) inputVel.x -= 1;
                if (keys['d'] || keys['ArrowRight']) inputVel.x += 1;
                if (inputVel.mag() > 0) this.vel = inputVel.norm().mul(this.speed);
                if (this.invulnTimer > 0) this.invulnTimer -= dt;
            }
            takeDamage(dmg, type, attackerPl) {
                if (this.invulnTimer > 0) return 0;
                let absorbed = 0;
                if (this.shieldActive && this.shieldStrength > 0) {
                    absorbed = Math.min(dmg, this.shieldStrength);
                    this.shieldStrength -= absorbed;
                    this.mana -= absorbed * this.shieldYield;
                    for (let i = 0; i < 5; i++) particles.push(new Particle(this.pos, new Vector(Math.random() * 100 - 50, Math.random() * 100 - 50), 'yellow', 0.3));
                }
                let effectiveDmg = Math.max(1, (dmg - absorbed) - this.def * (1 - 0.01 * attackerPl));
                this.health -= effectiveDmg;
                if (this.health <= 0) gameState = 'gameOver';
                return effectiveDmg;
            }
            fire(targetPos) {
                const abil = this.unlockedAbilities[this.selectedAbility];
                if (abil.cd <= 0 && this.mana >= abil.manaCost) {
                    abil.fire(this.pos, targetPos, this);
                    this.mana -= abil.manaCost;
                    abil.cd = abil.maxCd;
                    console.log(`${abil.name} fired`);
                    if (this.pl >= 16) screenShake = 0.1;
                }
            }
            cycleAbility() {
                this.selectedAbility = (this.selectedAbility + 1) % this.unlockedAbilities.length;
            }
            selectAbility(key) {
                const keyMap = {
                    'Digit1': 0, 'Digit2': 1, 'Digit3': 2, 'Digit4': 3, 'Digit5': 4,
                    'Digit6': 5, 'Digit7': 6, 'Digit8': 7, 'Digit9': 8,
                    'KeyC': 9, 'KeyV': 10, 'KeyB': 11, 'KeyN': 12, 'KeyM': 13
                };
                const idx = keyMap[key];
                if (idx !== undefined && this.unlocks.includes(idx)) {
                    this.selectedAbility = this.unlockedAbilities.findIndex(a => a.id === idx);
                }
            }
            render(ctx) {
                super.render(ctx, this.animOffset);
                // Hat
                ctx.fillStyle = 'purple';
                ctx.fillRect(this.pos.x - 4, this.pos.y - this.size / 2 - 6, 8, 4);
                // Shield
                if (this.shieldActive && this.shieldStrength > 0) {
                    const radius = 40 + (this.pl >= 8 ? 20 : 0); // omni upgrade sim
                    ctx.strokeStyle = 'lime';
                    ctx.lineWidth = 3 + Math.sin(Date.now() * 0.01) * 2;
                    ctx.beginPath();
                    ctx.arc(this.pos.x, this.pos.y, radius, 0, Math.PI * 2);
                    ctx.stroke();
                }
                // Aim line
                ctx.strokeStyle = 'gray';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(this.pos.x, this.pos.y);
                ctx.lineTo(mouse.x, mouse.y);
                ctx.stroke();
            }
            save() {
                const save = {
                    pl: this.pl, level: this.level, xp: this.xp, atk: this.atk, def: this.def,
                    shieldYield: this.shieldYield,
                    unlockedAbilities: this.unlockedAbilities.map(a => ({
                        id: a.id, name: a.name, dmg: a.dmg, maxCd: a.maxCd, manaCost: a.manaCost,
                        type: a.type, color: a.color
                    }))
                };
                localStorage.setItem('alternateSave', JSON.stringify(save));
            }
            load() {
                const saved = localStorage.getItem('alternateSave');
                if (saved) {
                    const data = JSON.parse(saved);
                    this.pl = data.pl; this.level = data.level; this.xp = data.xp;
                    this.atk = data.atk; this.def = data.def;
                    this.shieldYield = data.shieldYield;
                    this.unlockedAbilities = data.unlockedAbilities.map(aData => new Ability(
                        aData.name, aData.maxCd, aData.manaCost, aData.dmg,
                        aData.type, aData.color, this.pl, aData.id
                    ));
                    this.unlocks = this.unlockedAbilities.map(a => a.id);
                }
            }
        }

        class Enemy extends Entity {
            constructor(x, y, color, level, type) {
                super(x, y, color);
                this.level = level;
                this.type = type;
                this.pl = Math.floor(level / 2);
                this.health = 50 + level * 20;
                this.maxHealth = this.health;
                this.speed = 1 + level * 0.2;
                this.atk = 10 + level * 5;
                this.def = 5 + level * 2;
                this.spellTimer = 0;
                this.dodgeTimer = 0;
                this.shieldActive = this.pl >= 4 && Math.random() < 0.3;
                this.shieldStrength = this.pl >= 4 ? 50 : 0;
                this.unlockedAbilities = ABILITIES.slice(0, Math.min(this.pl, ABILITIES.length)).map((a, i) => new Ability(a.name, a.maxCd, a.manaCost, a.baseDmg, a.type, a.color, this.pl, i));
                this.animOffset = Math.random() * Math.PI * 2;
                this.isBoss = false;
                this.size = type === 'boss' ? 15 : 10;
            }
            update(dt) {
                super.update(dt);
                this.animOffset += dt * 1.5;
                if (this.shieldActive) this.shieldStrength = Math.min(50 + this.pl * 10, this.shieldStrength + 30 * dt);
                this.spellTimer += dt;
                let dist = this.pos.sub(player.pos).mag();
                let dir = player.pos.sub(this.pos).norm();
                if (dist > 30) {
                    this.vel = dir.mul(this.speed);
                } else {
                    this.vel = new Vector(0, 0);
                    if (dist < 15) player.takeDamage(this.atk, 'melee', this.pl);
                }
                // AI cast
                let castInt = Math.max(3 - this.pl * 0.1, 1);
                if (this.spellTimer > castInt && this.unlockedAbilities.length > 0 && !this.debuffs.some(d => d.type === 'stun')) {
                    this.spellTimer = 0;
                    const abil = this.unlockedAbilities[Math.floor(Math.random() * this.unlockedAbilities.length)];
                    abil.fire(this.pos, player.pos, this);
                    console.log(`${this.type} casts ${abil.name}`);
                }
                // Dodge
                if (this.dodgeTimer <= 0 && Math.random() < 0.02 * this.pl) {
                    let perp = new Vector(-dir.y, dir.x).mul((Math.random() > 0.5 ? 1 : -1));
                    this.vel = perp.mul(this.speed * 1.5);
                    this.dodgeTimer = 0.5;
                } else {
                    this.dodgeTimer -= dt;
                }
                // Flee at PL16
                if (player.pl >= 16 && dist > 50 && Math.random() < 0.1) {
                    this.vel = dir.mul(-this.speed * 1.5);
                }
                if (this.isBoss) {
                    this.shieldActive = true;
                }
            }
            takeDamage(dmg, type, attackerPl) {
                let absorbed = 0;
                if (this.shieldActive && this.shieldStrength > 0 && type !== 'shieldAttack') {
                    absorbed = Math.min(dmg, this.shieldStrength);
                    this.shieldStrength -= absorbed;
                    for (let i = 0; i < 5; i++) particles.push(new Particle(this.pos, new Vector(Math.random() * 100 - 50, Math.random() * 100 - 50), 'yellow', 0.3));
                }
                let effectiveDmg = Math.max(1, (dmg - absorbed) - this.def * (1 - 0.01 * attackerPl));
                if (type === 'shieldAttack') effectiveDmg = dmg - absorbed;
                this.health -= effectiveDmg;
                if (this.health <= 0) {
                    player.xp += 10 + player.level * 5;
                    addParticles(this.pos, 'spark', 20);
                    enemies = enemies.filter(e => e !== this);
                    if (enemies.length === 0) {
                        player.xp += currentWave * 50; // wave bonus
                        currentWave++;
                        if (player.xp >= player.xpToNext) {
                            player.level++;
                            player.xp -= player.xpToNext;
                            player.xpToNext = Math.floor(player.xpToNext * 1.5);
                            gameState = 'levelUp';
                            upgradePool = getUpgradePool(player);
                        }
                        spawnWave();
                    }
                }
                return effectiveDmg;
            }
            render(ctx) {
                if (this.isBoss) {
                    ctx.save();
                    ctx.translate(this.pos.x, this.pos.y);
                    ctx.scale(1.5, 1.5);
                    super.render(ctx, this.animOffset);
                    ctx.restore();
                } else {
                    super.render(ctx, this.animOffset);
                }
                if (this.shieldActive && this.shieldStrength > 0) {
                    ctx.strokeStyle = 'cyan';
                    ctx.beginPath();
                    ctx.arc(this.pos.x, this.pos.y, 30, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
        }

        class Projectile {
            constructor(pos, vel, color, dmg, type, pl, owner = null, id = 0) {
                this.pos = pos;
                this.vel = vel;
                this.color = color;
                this.dmg = dmg * (1 + pl / 16);
                this.type = type;
                this.pl = pl;
                this.owner = owner;
                this.id = id;
                this.life = Infinity;
                this.size = type === 'beta' ? 8 : 5;
                this.bounces = 0;
                this.maxBounces = type === 'recursive' ? 3 + pl : 0;
                this.launchTime = Date.now();
            }
            update(dt) {
                this.pos = this.pos.add(this.vel.mul(dt));
                // Homing
                if (['magic', 'curve', 'missile'].includes(this.type)) {
                    let target = this.type === 'curve' || this.type === 'missile' ? findNearestEnemy(this.pos) : (this.type === 'magic' && this.pl > 10 ? findNearestEnemy(this.pos) : null);
                    if (target) {
                        let steerStrength = this.type === 'missile' ? 0.2 : (this.type === 'curve' ? 0.1 : 0.05);
                        let desired = target.pos.sub(this.pos).norm().mul(this.vel.mag());
                        let steer = desired.sub(this.vel.norm().mul(this.vel.mag())).mul(steerStrength);
                        this.vel = this.vel.add(steer.mul(dt * 60));
                        // Curve sin
                        if (this.type === 'curve') {
                            let time = (Date.now() - this.launchTime) / 1000;
                            let perp = new Vector(-this.vel.y, this.vel.x).norm();
                            this.vel = this.vel.add(perp.mul(Math.sin(time * 5) * 20 * dt));
                        }
                    }
                }
                // Bounce walls
                if (this.type === 'recursive') {
                    if (this.pos.x <= 0 || this.pos.x >= GAME_WIDTH) {
                        this.vel.x *= -1;
                        this.pos.x = Math.max(0, Math.min(GAME_WIDTH, this.pos.x));
                        this.bounces++;
                    }
                    if (this.pos.y <= 0 || this.pos.y >= GAME_HEIGHT) {
                        this.vel.y *= -1;
                        this.pos.y = Math.max(0, Math.min(GAME_HEIGHT, this.pos.y));
                        this.bounces++;
                    }
                    if (this.bounces > this.maxBounces) this.life = 0;
                }
                // Proj vs proj reflect
                if (this.type === 'shieldAttack') {
                    projectiles.forEach(other => {
                        if (other !== this && other.owner !== player && this.pos.sub(other.pos).mag() < this.size + other.size) {
                            other.vel = other.vel.mul(-1);
                            other.owner = player;
                            addParticles(this.pos, 'spark', 5);
                        }
                    });
                }
                // Entity collision
                let targets = this.owner === player ? enemies : [player];
                for (let t of targets) {
                    if (this.pos.sub(t.pos).mag() < this.size + t.size) {
                        let hitDmg = t.takeDamage(this.dmg, this.type, this.pl);
                        addParticles(t.pos, 'spark', 10);
                        if (this.type === 'ice') t.applyDebuff('slow', 2, 0.5);
                        if (this.type === 'beam' || this.type === 'beta') t.applyDebuff('stun', this.pl >= 8 ? 1 : 0, 1);
                        if (this.type === 'lightning') {
                            let chains = findNearestEnemies(t.pos, 3, 50);
                            chains.forEach(c => c.takeDamage(this.dmg * 0.8, this.type, this.pl));
                            if (this.pl > 10) t.applyDebuff('dot', 3, this.dmg / 3);
                        }
                        if (this.type === 'beta') t.applyDebuff('dot', 3, this.dmg / 3);
                        if (this.type === 'missile') {
                            targets.forEach(tt => {
                                if (tt !== t && tt.pos.sub(t.pos).mag() < 50) tt.takeDamage(this.dmg * 0.5, this.type, this.pl);
                            });
                        }
                        if (this.type === 'recursive' && this.bounces < this.maxBounces) {
                            let normal = this.pos.sub(t.pos).norm();
                            this.vel = this.vel.sub(normal.mul(2 * this.vel.dot(normal)));
                            this.bounces++;
                            this.pos = this.pos.add(normal.mul(10)); // push out
                        } else if (!['beam', 'beta'].includes(this.type)) {
                            this.life = 0;
                        }
                    }
                }
                if (this.life === Infinity && (this.pos.x < 0 || this.pos.x > GAME_WIDTH || this.pos.y < 0 || this.pos.y > GAME_HEIGHT)) this.life = 0;
                this.life -= dt;
            }
            render(ctx) {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.pos.x, this.pos.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                // Trail
                ctx.globalAlpha = 0.5;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.pos.x - this.vel.x * 0.05, this.pos.y - this.vel.y * 0.05, this.size * 0.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        class Particle {
            constructor(pos, vel, color, life) {
                this.pos = pos;
                this.vel = vel;
                this.color = color;
                this.life = life;
                this.maxLife = life;
                this.size = 2 + Math.random() * 3;
            }
            update(dt) {
                this.pos = this.pos.add(this.vel.mul(dt));
                this.vel = this.vel.mul(0.98);
                this.life -= dt;
            }
            render(ctx) {
                let alpha = this.life / this.maxLife;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.pos.x - this.size / 2, this.pos.y - this.size / 2, this.size, this.size);
                ctx.globalAlpha = 1;
            }
        }

        class Ability {
            constructor(name, maxCd, manaCost, baseDmg, type, color, pl, id = 0) {
                this.name = name;
                this.id = id;
                this.maxCd = maxCd;
                this.cd = 0;
                this.manaCost = manaCost;
                this.dmg = baseDmg;
                this.type = type;
                this.color = color;
                this.pl = pl;
            }
            fire(from, to, owner) {
                let dir = to.sub(from).norm();
                switch (this.id) {
                    case 0: // Magic Shot
                        projectiles.push(new Projectile(from.add(dir.mul(10)), dir.mul(200), this.color, this.dmg, 'magic', this.pl, owner, this.id));
                        break;
                    case 1: // Tri-Shot
                        let angle = Math.atan2(dir.y, dir.x);
                        for (let a = -0.52; a <= 0.52; a += 0.52) {
                            let d = new Vector(Math.cos(angle + a), Math.sin(angle + a)).mul(180);
                            projectiles.push(new Projectile(from.add(dir.mul(10)), d, this.color, this.dmg, 'tri', this.pl, owner, this.id));
                        }
                        break;
                    case 2: // Beam Shot
                        fireBeam(from, to, this.dmg, this.pl, 'white', 3, owner);
                        break;
                    case 3: // Ice Shard
                        projectiles.push(new Projectile(from.add(dir.mul(10)), dir.mul(150), 'cyan', this.dmg, 'ice', this.pl, owner, this.id));
                        break;
                    case 4: // Lightning
                        fireLightning(from, to, this.dmg, this.pl, owner);
                        break;
                    case 5: // Curve Shot
                        projectiles.push(new Projectile(from.add(dir.mul(10)), dir.mul(180), 'green', this.dmg, 'curve', this.pl, owner, this.id));
                        break;
                    case 6: // Shield Breaker
                        fireAoE(to, 50 + this.pl * 5, this.dmg * 0.5, 'purple', true, this.pl, owner);
                        break;
                    case 7: // Homing Missile
                        projectiles.push(new Projectile(from.add(dir.mul(10)), dir.mul(150), 'red', this.dmg, 'missile', this.pl, owner, this.id));
                        break;
                    case 8: // Force Wave
                        fireCone(from, to, this.dmg, 200, Math.PI / 3, this.pl, owner);
                        break;
                    case 9: // Penta Shot
                        let pAngle = Math.atan2(dir.y, dir.x);
                        for (let a = -0.785; a <= 0.785; a += 0.3925) {
                            let d = new Vector(Math.cos(pAngle + a), Math.sin(pAngle + a)).mul(160);
                            projectiles.push(new Projectile(from.add(dir.mul(10)), d, 'blue', this.dmg, 'penta', this.pl, owner, this.id));
                        }
                        break;
                    case 10: // Recursive Shot
                        projectiles.push(new Projectile(from.add(dir.mul(10)), dir.mul(180), 'violet', this.dmg, 'recursive', this.pl, owner, this.id));
                        break;
                    case 11: // Shield Attack
                        projectiles.push(new Projectile(from.add(dir.mul(10)), dir.mul(200), 'silver', this.dmg, 'shieldAttack', this.pl, owner, this.id));
                        break;
                    case 12: // Beta Laser
                        fireBeam(from, to, this.dmg * 2, this.pl, 'red', 10, owner);
                        break;
                    case 13: // Super Speed
                        owner.speedBuff = 2;
                        owner.speedBuffTimer = 5;
                        if (owner.pl >= 12) owner.invulnTimer = 5;
                        addParticles(owner.pos, 'blue', 15);
                        break;
                }
            }
        }

        const ABILITIES = [
            { name: 'Magic Shot', maxCd: 0.5, manaCost: 5, baseDmg: 20, type: 'projectile', color: 'orange' },
            { name: 'Tri-Shot', maxCd: 0.8, manaCost: 8, baseDmg: 15, type: 'spread', color: 'blue' },
            { name: 'Beam Shot', maxCd: 1.5, manaCost: 15, baseDmg: 40, type: 'beam', color: 'white' },
            { name: 'Ice Shard', maxCd: 1.0, manaCost: 10, baseDmg: 25, type: 'projectile', color: 'cyan' },
            { name: 'Lightning', maxCd: 2.0, manaCost: 20, baseDmg: 30, type: 'chain', color: 'yellow' },
            { name: 'Curve Shot', maxCd: 0.7, manaCost: 7, baseDmg: 22, type: 'homing', color: 'green' },
            { name: 'Shield Breaker', maxCd: 3.0, manaCost: 25, baseDmg: 10, type: 'aoe', color: 'purple' },
            { name: 'Homing Missile', maxCd: 2.5, manaCost: 18, baseDmg: 35, type: 'homing', color: 'red' },
            { name: 'Force Wave', maxCd: 2.0, manaCost: 15, baseDmg: 28, type: 'cone', color: 'blue' },
            { name: 'Penta Shot', maxCd: 0.4, manaCost: 12, baseDmg: 18, type: 'spread', color: 'blue' },
            { name: 'Recursive Shot', maxCd: 4.0, manaCost: 30, baseDmg: 25, type: 'bounce', color: 'violet' },
            { name: 'Shield Attack', maxCd: 1.2, manaCost: 12, baseDmg: 30, type: 'projectile', color: 'silver' },
            { name: 'Beta Laser', maxCd: 5.0, manaCost: 40, baseDmg: 60, type: 'beam', color: 'red' },
            { name: 'Super Speed', maxCd: 10.0, manaCost: 25, baseDmg: 0, type: 'buff', color: 'gold' }
        ];

        function fireBeam(from, to, dmg, pl, color, width, owner) {
            let dir = to.sub(from).norm();
            let length = from.sub(to).mag();
            let step = dir.mul(5);
            let current = from.add(dir.mul(10));
            while (current.sub(from).mag() < length) {
                let targets = owner === player ? enemies : [player];
                for (let t of targets) {
                    if (current.sub(t.pos).mag() < t.size + 5) {
                        t.takeDamage(dmg, 'beam', pl);
                        addParticles(t.pos, 'white', 8);
                    }
                }
                current = current.add(step);
            }
            // Render will be handled in game loop, but for instant, log
            console.log('Beam fired');
        }

        function fireLightning(from, to, dmg, pl, owner) {
            // Damage first target
            let targets = owner === player ? enemies : [player];
            let nearest = findNearestTo(from, targets);
            if (nearest) nearest.takeDamage(dmg, 'lightning', pl);
            console.log('Lightning fired');
        }

        function fireAoE(pos, radius, dmg, color, breakShield, pl, owner) {
            let targets = owner === player ? enemies : [player];
            targets.forEach(t => {
                if (t.pos.sub(pos).mag() < radius) {
                    if (breakShield) t.shieldStrength -= 50 + pl * 10;
                    t.takeDamage(dmg, 'aoe', pl);
                    addParticles(t.pos, color, 10);
                }
            });
            console.log('AoE fired');
        }

        function fireCone(from, to, dmg, length, angle, pl, owner) {
            let dir = to.sub(from).norm();
            let coneAng = Math.atan2(dir.y, dir.x);
            let targets = owner === player ? enemies : [player];
            targets.forEach(t => {
                let tDist = t.pos.sub(from).mag();
                if (tDist < length) {
                    let tAng = Math.atan2(t.pos.y - from.y, t.pos.x - from.x);
                    let diff = Math.abs(tAng - coneAng);
                    if (diff < angle / 2 || Math.abs(diff - Math.PI * 2) < angle / 2) {
                        t.takeDamage(dmg, 'cone', pl);
                        // Knockback
                        let kbDir = t.pos.sub(from).norm();
                        t.vel = t.vel.add(kbDir.mul(100));
                        addParticles(t.pos, 'blue', 5);
                    }
                }
            });
            console.log('Cone fired');
        }

        function findNearestEnemy(pos) {
            return enemies.reduce((closest, e) => {
                let d = e.pos.sub(pos).mag();
                return d < (closest ? closest.pos.sub(pos).mag() : Infinity) ? e : closest;
            }, null);
        }

        function findNearestEnemies(pos, count, range) {
            return enemies.filter(e => e.pos.sub(pos).mag() < range).sort((a, b) => a.pos.sub(pos).mag() - b.pos.sub(pos).mag()).slice(0, count);
        }

        function findNearestTo(pos, targets) {
            return targets.reduce((closest, t) => {
                let d = t.pos.sub(pos).mag();
                return d < (closest ? closest.pos.sub(pos).mag() : Infinity) ? t : closest;
            }, null);
        }

        function addParticles(pos, type, count) {
            const colors = { spark: 'yellow', white: 'white', blue: 'blue' };
            for (let i = 0; i < count; i++) {
                let angle = Math.random() * Math.PI * 2;
                let speed = Math.random() * 100 + 50;
                let vel = new Vector(Math.cos(angle) * speed, Math.sin(angle) * speed);
                let color = colors[type] || 'white';
                particles.push(new Particle(pos.add(new Vector(Math.random() * 10 - 5, Math.random() * 10 - 5)), vel, color, Math.random() * 1 + 0.5));
            }
        }

        function getUpgradePool(player) {
            let availableUnlocks = ABILITIES.map((a, i) => i).filter(i => !player.unlocks.includes(i));
            let pool = [];
            const specials = [1,2,3,4,5,6,7,8,9,10,11,12,13]; // indices 1+
            for (let i = 0; i < 12; i++) { // generate pool
                if (availableUnlocks.length > 0 && Math.random() < (player.level < 10 ? 0.7 : 0.3)) {
                    let idx = availableUnlocks.splice(Math.random() * availableUnlocks.length | 0, 1)[0];
                    pool.push({
                        name: `Unlock ${ABILITIES[idx].name}`,
                        apply: () => {
                            let newAbil = new Ability(ABILITIES[idx].name, ABILITIES[idx].maxCd, ABILITIES[idx].manaCost, ABILITIES[idx].baseDmg, ABILITIES[idx].type, ABILITIES[idx].color, player.pl, idx);
                            if (specials.includes(idx)) {
                                player.unlockedAbilities.unshift(newAbil);
                            } else {
                                player.unlockedAbilities.push(newAbil);
                            }
                            player.unlocks.push(idx);
                        },
                        type: 'unlock'
                    });
                } else if (player.unlockedAbilities.length > 0) {
                    let abilIdx = Math.random() * player.unlockedAbilities.length | 0;
                    let abil = player.unlockedAbilities[abilIdx];
                    if (Math.random() < 0.5) {
                        pool.push({
                            name: `+10 DMG ${abil.name}`,
                            apply: () => { abil.dmg += 10; },
                            type: 'buff'
                        });
                    } else {
                        pool.push({
                            name: `-0.1s CD ${abil.name}`,
                            apply: () => { abil.maxCd = Math.max(0.1, abil.maxCd - 0.1); },
                            type: 'buff'
                        });
                    }
                } else {
                    // Stats rare
                    if (Math.random() < 0.05 && player.pl < 16) {
                        pool.push({
                            name: 'PL +1',
                            apply: () => { player.pl++; },
                            type: 'stat'
                        });
                    } else if (Math.random() < 0.2) {
                        pool.push({
                            name: 'ATK +2',
                            apply: () => { player.atk += 2; },
                            type: 'stat'
                        });
                    } else if (Math.random() < 0.2) {
                        pool.push({
                            name: 'DEF +2',
                            apply: () => { player.def += 2; },
                            type: 'stat'
                        });
                    } else {
                        pool.push({
                            name: 'Shield Yield -0.1',
                            apply: () => { player.shieldYield = Math.max(0.1, player.shieldYield - 0.1); },
                            type: 'shield'
                        });
                    }
                }
            }
            // Shuffle and take 3 unique
            for (let i = pool.length - 1; i > 0; i--) {
                let j = Math.random() * (i + 1) | 0;
                [pool[i], pool[j]] = [pool[j], pool[i]];
            }
            return pool.slice(0, 3);
        }

        function spawnWave() {
            enemies = [];
            let num = Math.min(1 + Math.floor((player.level - 1) / 3), 6);
            let isBossWave = currentWave % 5 === 0;
            if (isBossWave) num = Math.max(1, num - 1);
            const types = ['fire', 'ice', 'shadow', 'storm', 'beast'];
            const colors = { fire: 'red', ice: 'cyan', shadow: 'purple', storm: 'yellow', beast: 'green' };
            for (let i = 0; i < num; i++) {
                let side = Math.random() * 4 | 0;
                let x = side % 2 === 0 ? (Math.random() * GAME_WIDTH) : (side < 2 ? 0 : GAME_WIDTH);
                let y = side % 2 === 1 ? (Math.random() * GAME_HEIGHT) : (side < 2 ? 0 : GAME_HEIGHT);
                let type = types[Math.random() * types.length | 0];
                let e = new Enemy(x, y, colors[type], player.level, type);
                enemies.push(e);
            }
            if (isBossWave) {
                let bossSide = Math.random() * 4 | 0;
                let bx = bossSide % 2 === 0 ? (Math.random() * GAME_WIDTH) : (bossSide < 2 ? 0 : GAME_WIDTH);
                let by = bossSide % 2 === 1 ? (Math.random() * GAME_HEIGHT) : (bossSide < 2 ? 0 : GAME_HEIGHT);
                let boss = new Enemy(bx, by, 'darkred', player.level, 'boss');
                boss.isBoss = true;
                boss.health *= 2;
                boss.maxHealth *= 2;
                boss.pl = Math.min(player.pl + 1, 16);
                boss.size = 15;
                enemies.push(boss);
            }
        }

        // Globals
        let player = new Player();
        let enemies = [];
        let projectiles = [];
        let particles = [];
        let keys = {};
        let mouse = { x: 0, y: 0 };
        let gameState = 'menu';
        let currentWave = 1;
        let upgradePool = [];
        let screenShake = 0;
        let upgradeSelected = -1;

        // Events
        window.addEventListener('keydown', e => {
            keys[e.code] = true;
            if (gameState === 'playing') {
                if (e.code === 'Space') player.shieldActive = true;
                if (e.code === 'Comma') player.cycleAbility();
                if (e.code >= 'Digit1' && e.code <= 'Digit9' || ['KeyC', 'KeyV', 'KeyB', 'KeyN', 'KeyM'].includes(e.code)) {
                    player.selectAbility(e.code);
                }
            }
            if (e.code === 'KeyR' && gameState === 'gameOver') {
                localStorage.removeItem('alternateSave');
                location.reload();
            }
        });
        window.addEventListener('keyup', e => {
            keys[e.code] = false;
            if (e.code === 'Space') player.shieldActive = false;
        });
        canvas.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
        });
        canvas.addEventListener('click', e => {
            if (gameState === 'playing' && !player.shieldActive) {
                player.fire(new Vector(mouse.x, mouse.y));
            } else if (gameState === 'levelUp') {
                // Select upgrade
                const btnWidth = 200, btnHeight = 40, startX = 300, startY = 200;
                upgradeSelected = Math.floor((mouse.y - startY) / (btnHeight + 10));
                if (upgradeSelected >= 0 && upgradeSelected < 3) {
                    upgradePool[upgradeSelected].apply(player);
                    player.save();
                    gameState = 'playing';
                }
            } else if (gameState === 'menu') {
                const btnY = 300, btnH = 50;
                if (mouse.y > btnY && mouse.y < btnY + btnH) {
                    if (mouse.x < 400) { // Play
                        player.load();
                        gameState = 'playing';
                        if (enemies.length === 0) spawnWave();
                    } else if (mouse.x < 600) { // Attributes
                        // Toggle view? Simple console for now
                        console.log('Attributes:', { pl: player.pl, level: player.level, atk: player.atk, def: player.def, unlocks: player.unlocks });
                    } else { // Restart wipe
                        if (confirm('Wipe save?')) localStorage.removeItem('alternateSave');
                        player = new Player();
                        gameState = 'playing';
                        spawnWave();
                    }
                }
            }
        });

        function renderUI(ctx) {
            // Stats top left
            ctx.fillStyle = 'white';
            ctx.font = '16px Arial';
            ctx.fillText(`Health: ${Math.floor(player.health)}/${player.maxHealth}`, 10, 20);
            ctx.fillText(`Mana: ${Math.floor(player.mana)}/${player.maxMana}`, 10, 40);
            ctx.fillText(`PL: ${player.pl}/16`, 10, 60);
            ctx.fillText(`ATK: ${player.atk} DEF: ${player.def}`, 10, 80);
            ctx.fillText(`Level: ${player.level} XP: ${player.xp}/${player.xpToNext}`, 10, 100);
            ctx.fillText(`Wave: ${currentWave}`, 10, 120);
            // Spells right
            ctx.fillText('Spells:', 650, 20);
            player.unlockedAbilities.forEach((a, i) => {
                let y = 40 + i * 20;
                ctx.fillStyle = i === player.selectedAbility ? 'lime' : 'gray';
                let cdText = a.cd > 0 ? ` [${(a.cd).toFixed(1)}s]` : '';
                ctx.fillText(`${a.name}${cdText}`, 650, y);
            });
            // Controls bottom
            ctx.fillStyle = 'white';
            ctx.fillText('WASD/Arrows: Move | Mouse: Aim/Fire | , : Cycle | SPACE: Shield | 1-9/C-V-B-N-M: Select', 10, 580);
        }

        function renderMenu(ctx) {
            ctx.fillStyle = 'white';
            ctx.font = '32px Arial';
            ctx.textAlign = 'center';
            ctx.fillText("Alternate's Magical Evolution", GAME_WIDTH / 2, 150);
            ctx.font = '20px Arial';
            ctx.textAlign = 'left';
            const btnY = 300;
            ['Play', 'Attributes', 'Restart (Wipe)'].forEach((btn, i) => {
                let x = 200 + i * 200;
                ctx.strokeStyle = 'white';
                ctx.strokeRect(x, btnY, 150, 50);
                ctx.fillText(btn, x + 10, btnY + 30);
            });
            ctx.textAlign = 'left';
        }

        function renderLevelUp(ctx) {
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            ctx.fillStyle = 'white';
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Level Up! Choose Upgrade', GAME_WIDTH / 2, 150);
            const btnWidth = 250, btnHeight = 50, startX = (GAME_WIDTH - btnWidth) / 2, startY = 200;
            upgradePool.forEach((up, i) => {
                let y = startY + i * (btnHeight + 10);
                ctx.strokeStyle = i === upgradeSelected ? 'lime' : 'white';
                ctx.strokeRect(startX, y, btnWidth, btnHeight);
                ctx.fillStyle = i === upgradeSelected ? 'lime' : 'white';
                ctx.fillText(up.name, startX + 10, y + 30);
            });
            ctx.textAlign = 'left';
        }

        function renderGameOver(ctx) {
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            ctx.fillStyle = 'red';
            ctx.font = '32px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Game Over', GAME_WIDTH / 2, 250);
            ctx.font = '20px Arial';
            ctx.fillText(`Final Level: ${player.level} PL: ${player.pl}`, GAME_WIDTH / 2, 300);
            ctx.fillText('R to Restart (Wipes Save)', GAME_WIDTH / 2, 350);
            ctx.textAlign = 'left';
        }

        // Load on start
        player.load();

        let lastTime = 0;
        function gameLoop(time) {
            let dt = (time - lastTime) / 1000;
            lastTime = time;
            dt = Math.min(dt, 1 / 30); // cap

            // Shake
            if (screenShake > 0) {
                ctx.save();
                ctx.translate(Math.random() * screenShake * 10 - screenShake * 5, Math.random() * screenShake * 10 - screenShake * 5);
                screenShake -= dt;
            }

            ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

            if (gameState === 'playing') {
                player.update(dt);
                enemies.forEach(e => e.update(dt));
                projectiles.forEach(p => p.update(dt));
                particles.forEach(p => p.update(dt));
                // Clean
                projectiles = projectiles.filter(p => p.life > 0 && p.pos.mag() < 2000);
                particles = particles.filter(p => p.life > 0);
                // Render
                enemies.forEach(e => e.render(ctx));
                player.render(ctx);
                projectiles.forEach(p => p.render(ctx));
                particles.forEach(p => p.render(ctx));
                // Render beams etc. here if needed, but for simplicity, effects in update
                renderUI(ctx);
            } else if (gameState === 'menu') {
                renderMenu(ctx);
            } else if (gameState === 'levelUp') {
                enemies.forEach(e => e.update(dt));
                player.update(dt);
                projectiles.forEach(p => p.update(dt));
                particles.forEach(p => p.update(dt));
                enemies.forEach(e => e.render(ctx));
                player.render(ctx);
                projectiles.forEach(p => p.render(ctx));
                particles.forEach(p => p.render(ctx));
                renderLevelUp(ctx);
                renderUI(ctx);
            } else if (gameState === 'gameOver') {
                renderGameOver(ctx);
            }

            if (screenShake > 0) ctx.restore();

            requestAnimationFrame(gameLoop);
        }

        if (gameState === 'playing') spawnWave();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
