<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rhythm Dodge - Professional Edition</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        body { 
            margin: 0; 
            background: linear-gradient(135deg, #0c0c0c, #1a1a2e, #16213e); 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            height: 100vh; 
            font-family: 'Orbitron', monospace; 
            color: #00ff88; 
            overflow: hidden;
        }
        canvas { 
            border: 2px solid #00ff88; 
            border-radius: 10px; 
            background: radial-gradient(circle at center, #000428, #004e92); 
            box-shadow: 0 0 20px #00ff88; 
            cursor: crosshair;
        }
        #menu { 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            text-align: center; 
            z-index: 10; 
            background: rgba(0,0,0,0.9); 
            padding: 30px; 
            border-radius: 15px; 
            border: 1px solid #00ff88; 
            box-shadow: 0 0 30px rgba(0,255,136,0.5); 
            transition: opacity 0.3s;
        }
        #menu h1 { 
            font-size: 3em; 
            margin-bottom: 20px; 
            text-shadow: 0 0 10px #00ff88; 
            letter-spacing: 2px;
        }
        button { 
            padding: 12px 24px; 
            font-size: 1.1em; 
            background: linear-gradient(45deg, #ff0080, #00ff88); 
            border: none; 
            color: #000; 
            cursor: pointer; 
            border-radius: 25px; 
            margin: 10px; 
            font-weight: 700; 
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 15px rgba(0,255,136,0.3);
        }
        button:hover { 
            transform: scale(1.05); 
            box-shadow: 0 6px 20px rgba(0,255,136,0.5);
        }
        button:disabled { 
            background: #666; 
            cursor: not-allowed; 
            transform: none;
            box-shadow: none;
        }
        #shop { display: none; }
        #shop ul { list-style: none; padding: 0; }
        #shop li { 
            margin: 15px 0; 
            padding: 10px; 
            background: rgba(0,255,136,0.1); 
            border-radius: 10px; 
            border-left: 3px solid #00ff88;
        }
        #info { 
            position: absolute; 
            top: 10px; 
            left: 10px; 
            font-size: 0.9em; 
            background: rgba(0,0,0,0.7); 
            padding: 10px; 
            border-radius: 5px; 
            border: 1px solid #00ff88;
        }
        #creds { 
            position: absolute; 
            top: 10px; 
            right: 10px; 
            font-size: 1.2em; 
            font-weight: 700; 
            background: rgba(0,0,0,0.7); 
            padding: 10px; 
            border-radius: 5px; 
            border: 1px solid #00ff88;
            text-shadow: 0 0 5px #00ff88;
        }
        #hud { 
            position: absolute; 
            top: 50px; 
            left: 10px; 
            font-size: 1em; 
            color: #00ff88; 
            text-shadow: 0 0 5px #00ff88;
        }
        #dashIndicator { 
            position: absolute; 
            bottom: 20px; 
            left: 50%; 
            transform: translateX(-50%); 
            font-size: 1em; 
            color: #ff0080; 
            text-shadow: 0 0 5px #ff0080;
        }
    </style>
</head>
<body>
    <div id="info">
        <p><strong>Mic Sync:</strong> Allow mic access to capture your computer's audio (e.g., YouTube music). Analyzes raw bass for beat-synced attacks—no filtering!</p>
        <p><strong>Creds:</strong> Earn 1 per 10 score + bonus 50 for 100+ score. Spend in Shop!</p>
        <label>BPM Fallback: <input type="number" id="bpm" value="120" min="60" max="200" style="background: #000; color: #00ff88; border: 1px solid #00ff88;"></label>
    </div>
    <div id="creds">Creds: <span id="credsValue">0</span></div>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="hud" style="display: none;">
        <div>Score: <span id="scoreDisplay">0</span></div>
        <div>Dash Ready: <span id="dashReady">Yes</span></div>
    </div>
    <div id="dashIndicator" style="display: none;">Hold SHIFT to Dash (Cooldown: 2s)</div>
    <div id="menu">
        <h1>Rhythm Dodge</h1>
        <p>Dodge music-synced attacks! Mouse/Touch move. SHIFT to dash through hazards.</p>
        <button onclick="showShop()">Shop</button>
        <button onclick="startGame()">Play (Mic Sync)</button>
        <div id="shop">
            <h2>Skins Arsenal</h2>
            <p>Upgrade your cube's style. Earn creds by surviving longer!</p>
            <ul id="skinList"></ul>
            <button onclick="backToMenu()">Back to Menu</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const menu = document.getElementById('menu');
        const shopDiv = document.getElementById('shop');
        const skinList = document.getElementById('skinList');
        const bpmInput = document.getElementById('bpm');
        const credsSpan = document.getElementById('credsValue');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const dashReadySpan = document.getElementById('dashReady');
        const hud = document.getElementById('hud');
        const dashIndicator = document.getElementById('dashIndicator');

        // Game state
        let gameState = 'menu';
        let player = { x: 400, y: 300, size: 12 };
        let attacks = [];
        let score = 0;
        let creds = parseInt(localStorage.getItem('creds')) || 0;
        let bpm = parseInt(bpmInput.value);
        let spawnInterval = 60000 / bpm;
        let lastSpawn = 0;
        let selectedSkin = localStorage.getItem('selectedSkin') || 'Default Square';
        let isDashing = false;
        let dashCooldown = 0;
        let dashDuration = 0;

        // Audio for mic sync
        let audioContext;
        let analyser;
        let microphone;
        let rafId;
        let beatThreshold = 0.7; // Adjust for sensitivity
        let lastBeatTime = 0;
        let beatInterval = 500; // Min time between beats (ms)

        // Skins
        const skins = [
            { name: 'Default Cube', shape: 'square', color: '#ffffff', price: 0 },
            { name: 'Neon Red', shape: 'square', color: '#ff0040', price: 50 },
            { name: 'Cyber Blue', shape: 'square', color: '#00bfff', price: 100 },
            { name: 'Lime Pulse', shape: 'circle', color: '#00ff41', price: 75 },
            { name: 'Violet Star', shape: 'star', color: '#8a2be2', price: 150 },
            { name: 'Golden Dash', shape: 'square', color: '#ffd700', price: 200 } // New premium
        ];

        let ownedSkins = JSON.parse(localStorage.getItem('ownedSkins')) || ['Default Cube'];

        function updateCreds() {
            credsSpan.textContent = creds;
            localStorage.setItem('creds', creds.toString());
        }
        updateCreds();

        // Mouse/Touch movement
        function updatePlayerPos(e) {
            if (gameState !== 'playing' || isDashing) return;
            const rect = canvas.getBoundingClientRect();
            let clientX, clientY;
            if (e.touches) {
                e.preventDefault();
                const touch = e.touches[0];
                clientX = touch.clientX;
                clientY = touch.clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }
            player.x = clientX - rect.left;
            player.y = clientY - rect.top;
            player.x = Math.max(player.size/2, Math.min(800 - player.size/2, player.x));
            player.y = Math.max(player.size/2, Math.min(600 - player.size/2, player.y));
        }
        canvas.addEventListener('mousemove', updatePlayerPos);
        canvas.addEventListener('touchmove', updatePlayerPos);

        // Dash mechanic
        const keys = {};
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
                if (gameState === 'playing' && dashCooldown <= 0 && !isDashing) {
                    startDash();
                }
            }
            if (e.code === 'Space' && (gameState === 'gameOver' || gameState === 'menu' || gameState === 'shop')) {
                e.preventDefault();
                if (gameState === 'gameOver') startGame();
                else if (gameState === 'shop') backToMenu();
            }
        });
        document.addEventListener('keyup', (e) => { keys[e.code] = false; });

        function startDash() {
            isDashing = true;
            dashDuration = 200; // 200ms invincibility
            dashCooldown = 2000; // 2s cooldown
            // Optional: Boost speed towards mouse, but for simplicity, just invincible move
            updateDashDisplay();
        }

        function updateDash() {
            if (isDashing) {
                dashDuration -= 16; // ~60fps
                if (dashDuration <= 0) {
                    isDashing = false;
                }
            }
            if (dashCooldown > 0) {
                dashCooldown -= 16;
                updateDashDisplay();
            } else if (!isDashing) {
                dashReadySpan.textContent = 'Yes';
                dashReadySpan.style.color = '#00ff88';
            }
        }

        function updateDashDisplay() {
            if (gameState === 'playing') {
                if (isDashing) {
                    dashReadySpan.textContent = 'Dashing!';
                    dashReadySpan.style.color = '#ffd700';
                } else if (dashCooldown > 0) {
                    dashReadySpan.textContent = `${Math.ceil(dashCooldown/1000)}s`;
                    dashReadySpan.style.color = '#ff0080';
                }
            }
        }

        // Audio setup
        async function setupAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                microphone = audioContext.createMediaStreamSource(stream);
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                const bufferLength = analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                microphone.connect(analyser);

                function detectBeat() {
                    if (gameState !== 'playing') {
                        rafId = requestAnimationFrame(detectBeat);
                        return;
                    }
                    analyser.getByteFrequencyData(dataArray);
                    // Raw bass energy (low freqs for beats)
                    let bassEnergy = 0;
                    for (let i = 0; i < 20; i++) { // Low frequencies
                        bassEnergy += dataArray[i];
                    }
                    bassEnergy /= 20;
                    const now = Date.now();
                    if (bassEnergy > beatThreshold * 255 && now - lastBeatTime > beatInterval) {
                        spawnAttack(); // Beat-synced spawn!
                        lastBeatTime = now;
                        score++; // Score on beat dodge
                        scoreDisplay.textContent = score;
                    }
                    rafId = requestAnimationFrame(detectBeat);
                }
                detectBeat();
            } catch (err) {
                console.error('Mic access denied:', err);
                alert('Mic access denied—falling back to BPM timer. Grant permission for true audio sync!');
                // Fallback to BPM
            }
        }

        function showShop() {
            gameState = 'shop';
            shopDiv.style.display = 'block';
            renderSkinList();
        }

        function backToMenu() {
            gameState = 'menu';
            shopDiv.style.display = 'none';
        }

        function renderSkinList() {
            skinList.innerHTML = '';
            skins.forEach(skin => {
                const li = document.createElement('li');
                const owned = ownedSkins.includes(skin.name);
                li.innerHTML = `
                    <span style="color: ${skin.color}; font-weight: 900; text-shadow: 0 0 5px ${skin.color};">${skin.name}</span> 
                    (${skin.shape}) - ${owned ? 'Owned' : `Price: ${skin.price} creds`}
                    <button onclick="buyOrSelect('${skin.name}')" ${owned ? '' : 'disabled'}>
                        ${owned ? 'Equip' : 'Buy'}
                    </button>
                `;
                skinList.appendChild(li);
            });
        }

        function buyOrSelect(skinName) {
            const skin = skins.find(s => s.name === skinName);
            const owned = ownedSkins.includes(skinName);
            if (owned) {
                selectedSkin = skinName;
                localStorage.setItem('selectedSkin', selectedSkin);
                alert(`Equipped ${skinName}! Glows with your beats.`);
            } else if (creds >= skin.price) {
                creds -= skin.price;
                ownedSkins.push(skinName);
                localStorage.setItem('ownedSkins', JSON.stringify(ownedSkins));
                updateCreds();
                alert(`Acquired ${skinName}! Equip it now.`);
                renderSkinList();
            } else {
                alert('Creds low—dodge more beats to earn!');
            }
        }

        async function startGame() {
            await setupAudio(); // Init mic
            gameState = 'playing';
            menu.style.display = 'none';
            hud.style.display = 'block';
            dashIndicator.style.display = 'block';
            attacks = [];
            score = 0;
            player.x = 400;
            player.y = 300;
            lastSpawn = Date.now();
            lastBeatTime = 0;
            isDashing = false;
            dashCooldown = 0;
            scoreDisplay.textContent = score;
            updateDashDisplay();
            bpm = parseInt(bpmInput.value);
            spawnInterval = 60000 / bpm; // Fallback if no mic
            if (audioContext) {
                // Use beat detection over timer
                setInterval(() => {
                    if (Date.now() - lastBeatTime > beatInterval * 2) {
                        spawnAttack(); // Fallback spawn if quiet
                        score++;
                        scoreDisplay.textContent = score;
                    }
                }, spawnInterval);
            }
            gameLoop();
        }

        function earnCreds() {
            let earned = Math.floor(score / 10);
            if (score >= 100) earned += 50; // Bonus!
            creds += earned;
            updateCreds();
            alert(`Beat Sync Complete! +${earned} creds (1/10 score + milestone bonus). Total: ${creds}`);
        }

        function spawnAttack() {
            const types = ['line', 'circle', 'pulse'];
            const type = types[Math.floor(Math.random() * types.length)];
            let attack;
            const time = Date.now() / 1000;

            if (type === 'line') {
                const side = Math.floor(Math.random() * 4);
                let x1, y1, x2, y2;
                switch (side) {
                    case 0: x1 = Math.random() * 800; y1 = 0; x2 = Math.random() * 800; y2 = 600; break;
                    case 1: x1 = 800; y1 = Math.random() * 600; x2 = 0; y2 = Math.random() * 600; break;
                    case 2: x1 = Math.random() * 800; y1 = 600; x2 = Math.random() * 800; y2 = 0; break;
                    case 3: x1 = 0; y1 = Math.random() * 600; x2 = 800; y2 = Math.random() * 600; break;
                }
                const speed = 2.5 + Math.sin(time * 2) * 1.5; // Pulsing speed
                attack = { type: 'line', x1, y1, x2, y2, progress: 0, speed, color: `hsl(${time * 50 % 360}, 80%, 60%)` };
            } else if (type === 'circle') {
                const x = Math.random() * 800;
                const y = Math.random() * 600;
                const maxRadius = 150 + Math.random() * 100;
                const speed = 4 + Math.cos(time) * 2;
                attack = { type: 'circle', x, y, radius: 0, maxRadius, speed, color: `hsl(${time * 30 % 360}, 70%, 70%)` };
            } else {
                const x = 400 + Math.sin(time) * 100; // Slight offset
                const y = 300 + Math.cos(time) * 50;
                const maxRadius = 300;
                const speed = 6 + Math.random() * 3;
                attack = { type: 'pulse', x, y, radius: 0, maxRadius, speed, color: `hsl(${time * 100 % 360}, 90%, 50%)` };
            }
            attacks.push(attack);
        }

        function update() {
            if (gameState !== 'playing') return;
            updateDash();
            const now = Date.now();

            // Fallback spawn if no audio
            if (!audioContext || now - lastSpawn > spawnInterval * 1.5) {
                spawnAttack();
                lastSpawn = now;
            }

            attacks.forEach((attack, index) => {
                if (attack.type === 'line') {
                    attack.progress += attack.speed / 100;
                    if (attack.progress >= 1) {
                        attacks.splice(index, 1);
                        return;
                    }
                    const currX1 = attack.x1 + (attack.x2 - attack.x1) * attack.progress;
                    const currY1 = attack.y1 + (attack.y2 - attack.y1) * attack.progress;
                    const currX2 = attack.x1 + (attack.x2 - attack.x1) * (attack.progress - 0.05);
                    const currY2 = attack.y1 + (attack.y2 - attack.y1) * (attack.progress - 0.05);
                    const dist = distanceToLine(player.x, player.y, currX1, currY1, currX2, currY2);
                    if (dist < player.size / 2 && !isDashing) {
                        gameOver();
                    }
                } else if (attack.type === 'circle' || attack.type === 'pulse') {
                    attack.radius += attack.speed;
                    if (attack.radius > attack.maxRadius) {
                        attacks.splice(index, 1);
                        return;
                    }
                    const dist = Math.sqrt((player.x - attack.x)**2 + (player.y - attack.y)**2);
                    if (dist < attack.radius + player.size / 2 && !isDashing) {
                        gameOver();
                    }
                }
            });
        }

        function drawPlayer() {
            const skin = skins.find(s => s.name === selectedSkin);
            ctx.fillStyle = skin.color;
            ctx.shadowColor = skin.color;
            ctx.shadowBlur = 15 + Math.sin(Date.now() / 150) * 10; // Beat pulse glow
            if (skin.shape === 'square') {
                ctx.fillRect(player.x - player.size/2, player.y - player.size/2, player.size, player.size);
            } else if (skin.shape === 'circle') {
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.size/2, 0, Math.PI * 2);
                ctx.fill();
            } else if (skin.shape === 'star') {
                drawStar(player.x, player.y, player.size/2 * 1.5, 5);
            }
            ctx.shadowBlur = 0;
            // Dash trail effect
            if (isDashing) {
                ctx.fillStyle = 'rgba(255,215,0,0.5)';
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawStar(cx, cy, radius, spikes) {
            const rot = Math.PI / 2 * 3;
            const step = Math.PI / spikes;
            ctx.beginPath();
            ctx.moveTo(cx, cy - radius);
            for (let i = 0; i < spikes; i++) {
                const x = cx + Math.cos(rot + i * step) * radius;
                const y = cy + Math.sin(rot + i * step) * radius;
                ctx.lineTo(x, y);
                const innerRadius = radius / 2;
                const x2 = cx + Math.cos(rot + i * step + step / 2) * innerRadius;
                const y2 = cy + Math.sin(rot + i * step + step / 2) * innerRadius;
                ctx.lineTo(x2, y2);
            }
            ctx.closePath();
            ctx.fill();
        }

        function draw() {
            ctx.clearRect(0, 0, 800, 600);

            // Background pulse
            const gradient = ctx.createRadialGradient(400, 300, 0, 400, 300, 400);
            gradient.addColorStop(0, `rgba(0,255,136,${Math.sin(Date.now()/500)*0.3 + 0.1})`);
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 800, 600);

            if (gameState === 'playing') {
                drawPlayer();

                attacks.forEach(attack => {
                    ctx.strokeStyle = attack.color;
                    ctx.lineWidth = 6;
                    ctx.lineCap = 'round';
                    ctx.shadowColor = attack.color;
                    ctx.shadowBlur = 10;
                    if (attack.type === 'line') {
                        const currX1 = attack.x1 + (attack.x2 - attack.x1) * attack.progress;
                        const currY1 = attack.y1 + (attack.y2 - attack.y1) * attack.progress;
                        const currX2 = attack.x1 + (attack.x2 - attack.x1) * (attack.progress - 0.05);
                        const currY2 = attack.y1 + (attack.y2 - attack.y1) * (attack.progress - 0.05);
                        ctx.beginPath();
                        ctx.moveTo(currX1, currY1);
                        ctx.lineTo(currX2, currY2);
                        ctx.stroke();
                    } else {
                        ctx.beginPath();
                        ctx.arc(attack.x, attack.y, attack.radius, 0, Math.PI * 2);
                        ctx.stroke();
                        if (attack.type === 'pulse') {
                            ctx.beginPath();
                            ctx.arc(attack.x, attack.y, attack.radius * 0.6, 0, Math.PI * 2);
                            ctx.lineWidth = 3;
                            ctx.stroke();
                        }
                    }
                    ctx.shadowBlur = 0;
                    ctx.lineWidth = 6;
                });

                ctx.fillStyle = '#00ff88';
                ctx.font = 'bold 18px Orbitron';
                ctx.shadowBlur = 0;
                ctx.fillText(`Skin: ${selectedSkin.split(' ')[0]}`, 10, 550);
            } else if (gameState === 'gameOver') {
                ctx.fillStyle = 'rgba(0,255,136,0.9)';
                ctx.font = 'bold 50px Orbitron';
                ctx.textAlign = 'center';
                ctx.fillText('Beat Broken!', 400, 280);
                ctx.font = 'bold 24px Orbitron';
                ctx.fillStyle = '#fff';
                ctx.fillText(`Final Score: ${score}`, 400, 320);
                ctx.fillText(`Creds Earned: ${Math.floor(score / 10) + (score >= 100 ? 50 : 0)}`, 400, 350);
                ctx.fillText('Click/Space to Restart', 400, 400);
                ctx.textAlign = 'left';
            }
        }

        function gameLoop() {
            if (gameState === 'playing') {
                update();
                draw();
                requestAnimationFrame(gameLoop);
            } else {
                draw();
            }
        }

        function gameOver() {
            gameState = 'gameOver';
            if (audioContext) {
                cancelAnimationFrame(rafId);
            }
            earnCreds();
            hud.style.display = 'none';
            dashIndicator.style.display = 'none';
        }

        // Restart
        canvas.addEventListener('click', () => {
            if (gameState === 'gameOver') startGame();
        });

        // BPM fallback update
        bpmInput.addEventListener('input', () => {
            bpm = parseInt(bpmInput.value);
            spawnInterval = 60000 / bpm;
        });

        function distanceToLine(px, py, x1, y1, x2, y2) {
            const A = px - x1; const B = py - y1; const C = x2 - x1; const D = y2 - y1;
            const dot = A * C + B * D; const lenSq = C * C + D * D;
            if (lenSq === 0) return Math.hypot(A, B);
            const param = dot / lenSq;
            let xx = x1 + (param < 0 ? 0 : param > 1 ? C : param * C);
            let yy = y1 + (param < 0 ? 0 : param > 1 ? D : param * D);
            return Math.hypot(px - xx, py - yy);
        }

        // Init
        renderSkinList();
        draw();
    </script>
</body>
</html>
