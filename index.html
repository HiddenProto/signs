<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Alternate's Magical Evolution</title>
    <style>
        body { margin: 0; background: black; }
        canvas { display: block; margin: 0 auto; }
    </style>
</head>
<body>
    <canvas id="canvas" width="800" height="600"></canvas>
    <script>
        // Game Constants
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 600;
        const FPS = 60;
        const ARENA_BOUNDS = { left: 0, top: 0, right: CANVAS_WIDTH, bottom: CANVAS_HEIGHT };

        // Game States
        const STATE_MENU = 'menu';
        const STATE_PLAYING = 'playing';
        const STATE_LEVEL_UP = 'level_up';
        const STATE_GAME_OVER = 'game_over';
        const STATE_ATTRIBUTES = 'attributes';

        // Colors
        const COLOR_BLACK = '#000000';
        const COLOR_WHITE = '#FFFFFF';
        const COLOR_BLUE = '#0000FF';
        const COLOR_PURPLE = '#800080';
        const COLOR_ORANGE = '#FFA500';
        const COLOR_GREEN = '#00FF00';
        const COLOR_RED = '#FF0000';
        const COLOR_YELLOW = '#FFFF00';
        const COLOR_GRAY = '#808080';

        // Entity Sizes
        const PLAYER_SIZE = 20;
        const ENEMY_SIZE = 20;
        const BOSS_SIZE = 30;
        const PROJECTILE_SIZE = 5;

        // Particle Settings
        const PARTICLE_LIFETIME = 60;
        const BLOOD_PARTICLE_COUNT = 10;
        const EXPLOSION_BLOOD_COUNT = 50;

        // Shield Settings
        const SHIELD_RADIUS = 40;
        const SHIELD_STRENGTH = 100;
        const SHIELD_REGEN_RATE = 10; // per second
        const SHIELD_DEPLETED_REGEN_RATE = 20;
        const SHIELD_YIELD = 1.0; // initial

        // Mana Regen
        const MANA_REGEN = 20; // per second

        // Health Regen
        const HEALTH_REGEN = 1; // slow, per second

        // Local Storage Key
        const SAVE_KEY = 'alternates_magical_evolution_save';

        // Attack Types
        const ATTACKS = [
            { id: 1, name: 'Magic Shot', unlocked: true, cd: 500, mana: 10, desc: 'Basic orange orb projectile' },
            { id: 2, name: 'Tri-Shot', unlocked: false, cd: 800, mana: 15, desc: '3-way spread blue shots' },
            { id: 3, name: 'Beam Shot', unlocked: false, cd: 1000, mana: 20, desc: 'White laser line, pierces' },
            { id: 4, name: 'Ice Shard', unlocked: false, cd: 600, mana: 12, desc: 'Blue triangle, slows enemy' },
            { id: 5, name: 'Lightning', unlocked: false, cd: 1200, mana: 25, desc: 'Yellow zig-zag bolt, chains' },
            { id: 6, name: 'Curve Shot', unlocked: false, cd: 700, mana: 14, desc: 'Green homing arc' },
            { id: 7, name: 'Shield Breaker', unlocked: false, cd: 1500, mana: 30, desc: 'Purple AoE pulse' },
            { id: 8, name: 'Homing Missile', unlocked: false, cd: 900, mana: 18, desc: 'Red rocket, explodes' },
            { id: 9, name: 'Force Wave', unlocked: false, cd: 1100, mana: 22, desc: 'Blue shockwave cone' },
            { id: 10, name: 'Penta Shot', unlocked: false, cd: 400, mana: 16, desc: '5-way spread, rapid' },
            { id: 11, name: 'Recursive Shot', unlocked: false, cd: 1300, mana: 28, desc: 'Bouncing orb' },
            { id: 12, name: 'Shield Attack', unlocked: false, cd: 1000, mana: 20, desc: 'Shield projectile' },
            { id: 13, name: 'Beta Laser', unlocked: false, cd: 2000, mana: 40, desc: 'Thick red beam, DoT' },
            { id: 14, name: 'Super Speed', unlocked: false, cd: 30000, mana: 50, desc: 'Temp speed x2' },
            { id: 15, name: 'Precharged Rings', unlocked: false, cd: 5000, mana: 60, desc: '6 mana balls around' }
        ];

        // Enemy Types
        const ENEMY_TYPES = ['Fire', 'Ice', 'Shadow', 'Storm', 'Beast'];
        const ENEMY_COLORS = {
            'Fire': '#FF4500',
            'Ice': '#ADD8E6',
            'Shadow': '#4B0082',
            'Storm': '#FFD700',
            'Beast': '#8B4513'
        };

        // Upgrade Types
        const UPGRADES = [
            // Unlocks
            { type: 'unlock', attackId: 2, desc: 'Unlock Tri-Shot' },
            { type: 'unlock', attackId: 3, desc: 'Unlock Beam Shot' },
            { type: 'unlock', attackId: 4, desc: 'Unlock Ice Shard' },
            { type: 'unlock', attackId: 5, desc: 'Unlock Lightning' },
            { type: 'unlock', attackId: 6, desc: 'Unlock Curve Shot' },
            { type: 'unlock', attackId: 7, desc: 'Unlock Shield Breaker' },
            { type: 'unlock', attackId: 8, desc: 'Unlock Homing Missile' },
            { type: 'unlock', attackId: 9, desc: 'Unlock Force Wave' },
            { type: 'unlock', attackId: 10, desc: 'Unlock Penta Shot' },
            { type: 'unlock', attackId: 11, desc: 'Unlock Recursive Shot' },
            { type: 'unlock', attackId: 12, desc: 'Unlock Shield Attack' },
            { type: 'unlock', attackId: 13, desc: 'Unlock Beta Laser' },
            { type: 'unlock', attackId: 14, desc: 'Unlock Super Speed' },
            { type: 'unlock', attackId: 15, desc: 'Unlock Precharged Rings' },
            // Buffs
            { type: 'buff_damage', value: 10, desc: '+10 Damage to all attacks' },
            { type: 'buff_cd', value: -50, desc: '-50ms Cooldown to all attacks' },
            { type: 'stat_atk', value: 2, desc: '+2 ATK' },
            { type: 'stat_def', value: 2, desc: '+2 DEF' },
            { type: 'stat_pl', value: 1, desc: '+1 PL (rare)' },
            { type: 'shield_yield', value: -0.1, desc: 'Shield Yield -0.1' },
            { type: 'shield_strength', value: 20, desc: '+20 Shield Strength' },
            { type: 'shield_omni', desc: 'Unlock Omni Shield (auto-regen)' }
        ];

        // Game Variables
        let gameState = STATE_MENU;
        let player;
        let enemies = [];
        let projectiles = [];
        let particles = [];
        let wave = 1;
        let level = 1;
        let xp = 0;
        let xpNeeded = 100;
        let selectedAttack = 0;
        let lastAttackTime = 0;
        let shieldActive = false;
        let shieldStrength = SHIELD_STRENGTH;
        let shieldYield = SHIELD_YIELD;
        let hasOmniShield = false;
        let superSpeedActive = false;
        let superSpeedEnd = 0;
        let prechargedRings = [];
        let usedUpgrades = [];
        let levelUpOptions = [];
        let mouseX = 0;
        let mouseY = 0;
        let keys = {};
        let lastTime = 0;
        let deltaTime = 0;

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Event Listeners
        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            if (e.key === ',') cycleAttack();
        });
        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
            if (e.key === ' ') shieldActive = false;
        });
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        });
        canvas.addEventListener('click', handleClick);

        // Classes
        class Entity {
            constructor(x, y, size, color, health, mana, speed, pl, atk, def) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.color = color;
                this.health = health;
                this.maxHealth = health;
                this.mana = mana;
                this.maxMana = mana;
                this.speed = speed;
                this.pl = pl;
                this.atk = atk;
                this.def = def;
                this.availableAttacks = [ATTACKS[0]]; // start with basic
                this.selectedAttack = 0;
                this.lastAttackTime = 0;
                this.shieldActive = false;
                this.shieldStrength = SHIELD_STRENGTH;
                this.shieldYield = SHIELD_YIELD;
                this.hasShield = false; // for enemies
                this.dodgeChance = 0;
                this.slowEnd = 0;
                this.dotEnd = 0;
                this.dotDamage = 0;
                this.armAngle = 0;
                this.prechargedRings = [];
            }

            update(dt) {
                // Regen
                this.health = Math.min(this.maxHealth, this.health + HEALTH_REGEN * dt);
                this.mana = Math.min(this.maxMana, this.mana + MANA_REGEN * dt);

                // Shield regen
                let regenRate = this.shieldStrength === 0 ? SHIELD_DEPLETED_REGEN_RATE : SHIELD_REGEN_RATE;
                this.shieldStrength = Math.min(SHIELD_STRENGTH, this.shieldStrength + regenRate * dt);

                // Slow effect
                if (Date.now() < this.slowEnd) {
                    this.speed *= 0.5;
                }

                // DoT
                if (Date.now() < this.dotEnd) {
                    this.takeDamage(this.dotDamage * dt, null);
                }
            }

            draw() {
                // Draw square body
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - this.size / 2, this.y - this.size / 2, this.size, this.size);

                // Draw hat (triangle)
                ctx.fillStyle = COLOR_PURPLE; // for player, enemies different?
                ctx.beginPath();
                ctx.moveTo(this.x - this.size / 2, this.y - this.size / 2);
                ctx.lineTo(this.x + this.size / 2, this.y - this.size / 2);
                ctx.lineTo(this.x, this.y - this.size / 2 - 10);
                ctx.fill();

                // Draw arms (lines pointing to aim)
                ctx.strokeStyle = COLOR_GRAY;
                ctx.lineWidth = 2;
                const armLength = this.size / 2;
                const leftArmX = this.x - Math.cos(this.armAngle + Math.PI / 4) * armLength;
                const leftArmY = this.y - Math.sin(this.armAngle + Math.PI / 4) * armLength;
                const rightArmX = this.x - Math.cos(this.armAngle - Math.PI / 4) * armLength;
                const rightArmY = this.y - Math.sin(this.armAngle - Math.PI / 4) * armLength;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(leftArmX, leftArmY);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(rightArmX, rightArmY);
                ctx.stroke();

                // Draw shield if active
                if (this.shieldActive) {
                    ctx.strokeStyle = COLOR_GREEN;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, SHIELD_RADIUS, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Draw precharged rings
                this.prechargedRings.forEach((ring, index) => {
                    const angle = (index / 6) * Math.PI * 2 + Date.now() / 1000;
                    const rx = this.x + Math.cos(angle) * 30;
                    const ry = this.y + Math.sin(angle) * 30;
                    ctx.fillStyle = COLOR_BLUE;
                    ctx.beginPath();
                    ctx.arc(rx, ry, 5, 0, Math.PI * 2);
                    ctx.fill();
                });
            }

            takeDamage(dmg, attacker) {
                if (this.shieldActive && this.shieldStrength > 0) {
                    const absorbed = Math.min(dmg, this.shieldStrength / this.shieldYield);
                    this.shieldStrength -= absorbed * this.shieldYield;
                    dmg -= absorbed;
                    // Sparks particles
                    addParticles(this.x, this.y, 5, COLOR_YELLOW);
                    if (dmg <= 0) return;
                }

                const effectiveDmg = Math.max(1, dmg - this.def + (attacker ? attacker.pl * 0.05 * this.def : 0));
                this.health -= effectiveDmg;
                // Blood particles
                addParticles(this.x, this.y, BLOOD_PARTICLE_COUNT, COLOR_RED);
                if (this.health <= 0) {
                    this.die();
                }
            }

            die() {
                // Explode into more blood
                addParticles(this.x, this.y, EXPLOSION_BLOOD_COUNT, COLOR_RED);
                // Remove from list
            }

            fireAttack(targetX, targetY) {
                const attack = this.availableAttacks[this.selectedAttack];
                if (!attack) return;
                const now = Date.now();
                if (now - this.lastAttackTime < attack.cd || this.mana < attack.mana) return;
                this.mana -= attack.mana;
                this.lastAttackTime = now;

                // Set arm angle to direction
                this.armAngle = Math.atan2(targetY - this.y, targetX - this.x);

                // Launch based on id
                this.launchSpecificAttack(attack.id, targetX, targetY);
            }

            launchSpecificAttack(id, tx, ty) {
                const dirX = tx - this.x;
                const dirY = ty - this.y;
                const dist = Math.sqrt(dirX * dirX + dirY * dirY);
                const velX = (dirX / dist) * 5; // fast for simplicity
                const velY = (dirY / dist) * 5;
                const damage = this.atk * (1 + this.pl / 16);
                const projHp = damage / 10;

                switch (id) {
                    case 1: // Magic Shot
                        let extraDmg = 0;
                        if (this.prechargedRings.length > 0) {
                            extraDmg = 10 * this.prechargedRings.length;
                            this.prechargedRings.pop(); // unload fast
                        }
                        projectiles.push(new Projectile(this.x, this.y, PROJECTILE_SIZE, COLOR_ORANGE, velX, velY, damage + extraDmg, this, projHp, id));
                        break;
                    case 2: // Tri-Shot
                        const angleSpread = Math.PI / 6;
                        for (let i = -1; i <= 1; i++) {
                            const a = Math.atan2(dirY, dirX) + i * angleSpread;
                            projectiles.push(new Projectile(this.x, this.y, PROJECTILE_SIZE, COLOR_BLUE, Math.cos(a) * 5, Math.sin(a) * 5, damage, this, projHp, id));
                        }
                        break;
                    case 3: // Beam Shot
                        // Instant line, check hits
                        ctx.strokeStyle = COLOR_WHITE;
                        ctx.lineWidth = 5;
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y);
                        ctx.lineTo(tx, ty);
                        ctx.stroke();
                        // Hit all in line
                        const hits = getEntitiesInLine(this.x, this.y, tx, ty, this);
                        hits.forEach(ent => {
                            ent.takeDamage(damage, this);
                            if (this.pl >= 8) ent.slowEnd = Date.now() + 2000; // stun as slow
                        });
                        break;
                    case 4: // Ice Shard
                        projectiles.push(new Projectile(this.x, this.y, PROJECTILE_SIZE * 1.5, COLOR_BLUE, velX, velY, damage, this, projHp, id));
                        break;
                    case 5: // Lightning
                        // Zigzag to target
                        let currentX = this.x;
                        let currentY = this.y;
                        let target = findNearestEnemy(this);
                        if (!target) return;
                        for (let chain = 0; chain < 1 + Math.floor(this.pl / 4); chain++) {
                            // Draw zigzag
                            drawZigzag(currentX, currentY, target.x, target.y, COLOR_YELLOW);
                            target.takeDamage(damage, this);
                            if (this.pl >= 10) target.dotEnd = Date.now() + 3000; target.dotDamage = damage / 3;
                            addParticles(target.x, target.y, 5, COLOR_YELLOW);
                            currentX = target.x;
                            currentY = target.y;
                            target = findNearestEnemy(target, 100); // chain range
                            if (!target) break;
                        }
                        break;
                    case 6: // Curve Shot
                        projectiles.push(new Projectile(this.x, this.y, PROJECTILE_SIZE, COLOR_GREEN, velX, velY, damage, this, projHp, id));
                        break;
                    case 7: // Shield Breaker
                        // Big white EMP ball around player
                        ctx.fillStyle = COLOR_WHITE;
                        ctx.globalAlpha = 0.5;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, 100, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;
                        getEntitiesInRadius(this.x, this.y, 100, this).forEach(ent => {
                            ent.takeDamage(20 + this.atk, this);
                            if (ent.shieldActive) ent.shieldStrength -= 50 + this.pl * 10;
                        });
                        break;
                    case 8: // Homing Missile
                        projectiles.push(new Projectile(this.x, this.y, PROJECTILE_SIZE * 2, COLOR_RED, velX, velY, damage, this, projHp, id));
                        break;
                    case 9: // Force Wave
                        // Cone
                        const coneAngle = Math.PI / 4;
                        const coneLength = 200;
                        ctx.fillStyle = COLOR_BLUE;
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y);
                        ctx.arc(this.x, this.y, coneLength, Math.atan2(dirY, dirX) - coneAngle / 2, Math.atan2(dirY, dirX) + coneAngle / 2);
                        ctx.fill();
                        getEntitiesInCone(this.x, this.y, Math.atan2(dirY, dirX), coneAngle, coneLength, this).forEach(ent => {
                            ent.takeDamage(damage, this);
                            // Knockback
                            const kdirX = ent.x - this.x;
                            const kdirY = ent.y - this.y;
                            const kdist = Math.sqrt(kdirX * kdirX + kdirY * kdirY);
                            ent.x += (kdirX / kdist) * 50;
                            ent.y += (kdirY / kdist) * 50;
                        });
                        break;
                    case 10: // Penta Shot
                        const pSpread = Math.PI / 8;
                        for (let i = -2; i <= 2; i++) {
                            const pa = Math.atan2(dirY, dirX) + i * pSpread;
                            projectiles.push(new Projectile(this.x, this.y, PROJECTILE_SIZE, COLOR_ORANGE, Math.cos(pa) * 5, Math.sin(pa) * 5, damage, this, projHp, id));
                        }
                        break;
                    case 11: // Recursive Shot
                        projectiles.push(new Projectile(this.x, this.y, PROJECTILE_SIZE, COLOR_GREEN, velX, velY, damage, this, projHp, id, 3 + this.pl));
                        break;
                    case 12: // Shield Attack
                        projectiles.push(new Projectile(this.x, this.y, PROJECTILE_SIZE * 1.5, COLOR_GREEN, velX, velY, damage, this, projHp, id));
                        break;
                    case 13: // Beta Laser
                        // Thick red beam
                        ctx.strokeStyle = COLOR_RED;
                        ctx.lineWidth = 10;
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y);
                        ctx.lineTo(tx, ty);
                        ctx.stroke();
                        const bhits = getEntitiesInLine(this.x, this.y, tx, ty, this);
                        bhits.forEach(ent => {
                            ent.takeDamage(damage * 2, this);
                            ent.dotEnd = Date.now() + 3000;
                            ent.dotDamage = damage / 3;
                        });
                        break;
                    case 14: // Super Speed
                        superSpeedActive = true;
                        superSpeedEnd = Date.now() + 5000;
                        this.speed *= 2;
                        if (this.pl >= 12) {
                            // Invuln frames, say ignore damage for short
                        }
                        break;
                    case 15: // Precharged Rings
                        this.prechargedRings = Array(6).fill({active: true});
                        break;
                }
            }
        }

        class Player extends Entity {
            constructor() {
                super(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2, PLAYER_SIZE, COLOR_BLUE, 100, 100, 3, 1, 1, 1);
                this.availableAttacks = ATTACKS.filter(a => a.unlocked);
                this.buffDamage = 0;
                this.buffCd = 0;
            }

            update(dt) {
                super.update(dt);

                // Movement
                let dx = 0, dy = 0;
                if (keys['w'] || keys['arrowup']) dy -= 1;
                if (keys['s'] || keys['arrowdown']) dy += 1;
                if (keys['a'] || keys['arrowleft']) dx -= 1;
                if (keys['d'] || keys['arrowright']) dx += 1;
                const mag = Math.sqrt(dx * dx + dy * dy);
                if (mag > 0) {
                    dx /= mag;
                    dy /= mag;
                    this.x += dx * this.speed;
                    this.y += dy * this.speed;
                }

                // Bound
                this.x = Math.max(this.size / 2, Math.min(CANVAS_WIDTH - this.size / 2, this.x));
                this.y = Math.max(this.size / 2, Math.min(CANVAS_HEIGHT - this.size / 2, this.y));

                // Shield
                if (keys[' ']) this.shieldActive = true;

                // Super speed end
                if (superSpeedActive && Date.now() > superSpeedEnd) {
                    superSpeedActive = false;
                    this.speed /= 2;
                }

                // Precharged rings ram
                if (this.prechargedRings.length > 0) {
                    enemies.forEach(enemy => {
                        const dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                        if (dist < this.size / 2 + enemy.size / 2 + 30) { // ring radius
                            if (this.prechargedRings.length > 0) {
                                this.prechargedRings.pop();
                                enemy.takeDamage(20, this);
                                this.takeDamage(10, enemy); // hurt self
                                addParticles(this.x, this.y, 20, COLOR_RED);
                            }
                        }
                    });
                }

                // Aim line
                ctx.strokeStyle = COLOR_GRAY;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(mouseX, mouseY);
                ctx.stroke();
            }
        }

        class Enemy extends Entity {
            constructor(type, level) {
                const color = ENEMY_COLORS[type];
                const pl = Math.floor(level / 2);
                const health = 50 + level * 20;
                const speed = 1 + level * 0.2;
                const atk = 10 + level * 5;
                const def = 5 + level * 2;
                super(Math.random() * CANVAS_WIDTH, Math.random() * CANVAS_HEIGHT, ENEMY_SIZE, color, health, 100, speed, pl, atk, def);
                this.type = type;
                this.hasShield = pl >= 4;
                this.dodgeChance = 0.02 * pl;
                this.availableAttacks = ATTACKS.filter(a => a.id <= Math.min(15, pl + 1)); // more with pl
                this.selectedAttack = Math.floor(Math.random() * this.availableAttacks.length);
                this.attackCooldown = 3000 - pl * 100; // scales down
                this.lastAttackTime = Date.now() + Math.random() * 2000;
            }

            update(dt) {
                super.update(dt);

                // AI
                const distToPlayer = Math.hypot(player.x - this.x, player.y - this.y);
                if (distToPlayer > 30) {
                    // Chase
                    const dx = player.x - this.x;
                    const dy = player.y - this.y;
                    const mag = Math.sqrt(dx * dx + dy * dy);
                    this.x += (dx / mag) * this.speed * dt * 60;
                    this.y += (dy / mag) * this.speed * dt * 60;
                }

                // Shield when low health
                if (this.hasShield && this.health < this.maxHealth / 2) {
                    this.shieldActive = true;
                }

                // Attack
                const now = Date.now();
                if (now - this.lastAttackTime > this.attackCooldown) {
                    this.selectedAttack = Math.floor(Math.random() * this.availableAttacks.length);
                    this.fireAttack(player.x, player.y);
                    this.lastAttackTime = now;
                }

                // Dodge
                if (Math.random() < this.dodgeChance / 60) {
                    // Dodge spin or something, but simple move side
                    this.x += (Math.random() - 0.5) * 50;
                    this.y += (Math.random() - 0.5) * 50;
                }
            }

            die() {
                super.die();
                enemies.splice(enemies.indexOf(this), 1);
                player.xp += 10 + this.pl * 5;
                checkWaveClear();
            }
        }

        class Boss extends Enemy {
            constructor(type, level) {
                super(type, level);
                this.size = BOSS_SIZE;
                this.pl += 1;
                this.health *= 1.5;
                this.maxHealth *= 1.5;
            }
        }

        class Projectile {
            constructor(x, y, size, color, velX, velY, damage, owner, hp, type, bounces = 0) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.color = color;
                this.velX = velX;
                this.velY = velY;
                this.damage = damage;
                this.owner = owner;
                this.hp = hp;
                this.type = type;
                this.bounces = bounces;
                this.target = null; // for homing
            }

            update(dt) {
                this.x += this.velX * 60 * dt;
                this.y += this.velY * 60 * dt;

                // Bound check
                if (this.x < 0 || this.x > CANVAS_WIDTH || this.y < 0 || this.y > CANVAS_HEIGHT) {
                    projectiles.splice(projectiles.indexOf(this), 1);
                    return;
                }

                // Type specific
                switch (this.type) {
                    case 4: // Ice Shard, triangle
                        break;
                    case 6: // Curve Shot, curve to nearest
                        const nearest = findNearestEnemy(this, 0, this.owner);
                        if (nearest) {
                            const dx = nearest.x - this.x;
                            const dy = nearest.y - this.y;
                            const da = Math.atan2(dy, dx);
                            const ca = Math.atan2(this.velY, this.velX);
                            const diff = (da - ca + Math.PI) % (2 * Math.PI) - Math.PI;
                            const turn = Math.sign(diff) * Math.min(Math.abs(diff), Math.PI / 20);
                            const newA = ca + turn;
                            this.velX = Math.cos(newA) * 5;
                            this.velY = Math.sin(newA) * 5;
                        }
                        break;
                    case 8: // Homing Missile
                        this.target = this.target || findNearestEnemy(this, 0, this.owner);
                        if (this.target) {
                            const dx = this.target.x - this.x;
                            const dy = this.target.y - this.y;
                            const da = Math.atan2(dy, dx);
                            const ca = Math.atan2(this.velY, this.velX);
                            const diff = (da - ca + Math.PI) % (2 * Math.PI) - Math.PI;
                            const turn = Math.sign(diff) * Math.min(Math.abs(diff), Math.PI / 10 * (this.owner.pl / 16 + 1));
                            const newA = ca + turn;
                            this.velX = Math.cos(newA) * 5;
                            this.velY = Math.sin(newA) * 5;
                        }
                        break;
                    case 11: // Recursive, bounce off walls/enemies
                        if (this.x < 0 || this.x > CANVAS_WIDTH) this.velX *= -1;
                        if (this.y < 0 || this.y > CANVAS_HEIGHT) this.velY *= -1;
                        break;
                    case 12: // Shield Attack, ignores shields, reflects enemy shots
                        break;
                }

                // Collision with entities
                (this.owner instanceof Player ? enemies : [player]).forEach(ent => {
                    if (Math.hypot(ent.x - this.x, ent.y - this.y) < ent.size / 2 + this.size / 2) {
                        // Dodge check
                        if (Math.random() < ent.dodgeChance) return;

                        let hit = true;
                        if (ent.shieldActive && ent.shieldStrength > 0) {
                            if (this.type === 12) { // ignores
                            } else {
                                // Reflect
                                this.owner = ent; // change owner to reflect
                                this.velX *= -1;
                                this.velY *= -1;
                                hit = false;
                            }
                        }

                        if (hit) {
                            ent.takeDamage(this.damage, this.owner);
                            if (this.type === 4) ent.slowEnd = Date.now() + 2000;
                            if (this.type === 8 && this.owner.pl >= 6) {
                                // Explode splash
                                addParticles(this.x, this.y, 20, COLOR_RED);
                                getEntitiesInRadius(this.x, this.y, 50, this.owner).forEach(e => e.takeDamage(this.damage / 2, this.owner));
                            }
                            if (this.type === 11 && this.bounces > 0) {
                                this.bounces--;
                                this.velX *= -1;
                                this.velY *= -1;
                            } else {
                                projectiles.splice(projectiles.indexOf(this), 1);
                            }
                        }
                    }
                });

                // Collision with other projectiles
                projectiles.forEach(other => {
                    if (other !== this && other.owner !== this.owner && Math.hypot(other.x - this.x, other.y - this.y) < this.size + other.size) {
                        // Compare strength
                        const myStr = this.damage * (this.owner.pl + 1);
                        const otherStr = other.damage * (other.owner.pl + 1);
                        if (myStr > otherStr) {
                            this.hp -= other.damage;
                            projectiles.splice(projectiles.indexOf(other), 1);
                            if (this.hp <= 0) projectiles.splice(projectiles.indexOf(this), 1);
                        } else if (otherStr > myStr) {
                            other.hp -= this.damage;
                            projectiles.splice(projectiles.indexOf(this), 1);
                            if (other.hp <= 0) projectiles.splice(projectiles.indexOf(other), 1);
                        } else {
                            projectiles.splice(projectiles.indexOf(other), 1);
                            projectiles.splice(projectiles.indexOf(this), 1);
                        }
                    }
                });
            }

            draw() {
                ctx.fillStyle = this.color;
                if (this.type === 4) { // triangle
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y - this.size);
                    ctx.lineTo(this.x - this.size, this.y + this.size);
                    ctx.lineTo(this.x + this.size, this.y + this.size);
                    ctx.fill();
                } else {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                }
                // Trail
                addParticles(this.x, this.y, 1, this.color, 0.5);
            }
        }

        class Particle {
            constructor(x, y, velX, velY, color, lifetime) {
                this.x = x;
                this.y = y;
                this.velX = velX;
                this.velY = velY;
                this.color = color;
                this.lifetime = lifetime;
                this.age = 0;
            }

            update(dt) {
                this.x += this.velX;
                this.y += this.velY;
                this.age += 60 * dt;
                if (this.age > this.lifetime) {
                    particles.splice(particles.indexOf(this), 1);
                }
            }

            draw() {
                ctx.fillStyle = this.color;
                const alpha = 1 - this.age / this.lifetime;
                ctx.globalAlpha = alpha;
                ctx.fillRect(this.x, this.y, 2, 2);
                ctx.globalAlpha = 1;
            }
        }

        // Helper Functions
        function addParticles(x, y, count, color, speed = 2) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const vel = Math.random() * speed;
                particles.push(new Particle(x, y, Math.cos(angle) * vel, Math.sin(angle) * vel, color, PARTICLE_LIFETIME));
            }
        }

        function drawZigzag(x1, y1, x2, y2, color) {
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            const segments = 5;
            for (let i = 1; i < segments; i++) {
                const t = i / segments;
                const px = x1 + (x2 - x1) * t + (Math.random() - 0.5) * 20;
                const py = y1 + (y2 - y1) * t + (Math.random() - 0.5) * 20;
                ctx.lineTo(px, py);
            }
            ctx.lineTo(x2, y2);
            ctx.stroke();
        }

        function findNearestEnemy(from, range = Infinity, exclude) {
            let nearest = null;
            let minDist = range;
            enemies.forEach(e => {
                if (e === exclude) return;
                const dist = Math.hypot(e.x - from.x, e.y - from.y);
                if (dist < minDist) {
                    minDist = dist;
                    nearest = e;
                }
            });
            return nearest;
        }

        function getEntitiesInLine(x1, y1, x2, y2, exclude) {
            const hits = [];
            const dx = x2 - x1;
            const dy = y2 - y1;
            const len = Math.hypot(dx, dy);
            enemies.forEach(e => {
                if (e === exclude) return;
                // Project point to line
                const px = e.x - x1;
                const py = e.y - y1;
                const proj = (px * dx + py * dy) / (len * len);
                if (proj < 0 || proj > 1) return;
                const closestX = x1 + proj * dx;
                const closestY = y1 + proj * dy;
                if (Math.hypot(e.x - closestX, e.y - closestY) < e.size / 2) {
                    hits.push(e);
                }
            });
            return hits;
        }

        function getEntitiesInRadius(x, y, r, exclude) {
            const hits = [];
            enemies.forEach(e => {
                if (e === exclude) return;
                if (Math.hypot(e.x - x, e.y - y) < r) hits.push(e);
            });
            return hits;
        }

        function getEntitiesInCone(x, y, angle, coneAngle, length, exclude) {
            const hits = [];
            enemies.forEach(e => {
                if (e === exclude) return;
                const dx = e.x - x;
                const dy = e.y - y;
                const dist = Math.hypot(dx, dy);
                if (dist > length) return;
                const eAngle = Math.atan2(dy, dx);
                const diff = Math.abs((eAngle - angle + Math.PI) % (2 * Math.PI) - Math.PI);
                if (diff < coneAngle / 2) hits.push(e);
            });
            return hits;
        }

        function cycleAttack() {
            player.selectedAttack = (player.selectedAttack + 1) % player.availableAttacks.length;
        }

        function handleClick(e) {
            if (gameState === STATE_PLAYING) {
                player.fireAttack(mouseX, mouseY);
            } else if (gameState === STATE_MENU) {
                // Check buttons
                if (mouseX > 300 && mouseX < 500 && mouseY > 200 && mouseY < 250) {
                    startGame();
                } else if (mouseX > 300 && mouseX < 500 && mouseY > 300 && mouseY < 350) {
                    gameState = STATE_ATTRIBUTES;
                }
            } else if (gameState === STATE_LEVEL_UP) {
                // Choose upgrade
                for (let i = 0; i < 3; i++) {
                    if (mouseX > 100 && mouseX < 700 && mouseY > 200 + i * 100 && mouseY < 250 + i * 100) {
                        applyUpgrade(levelUpOptions[i]);
                        gameState = STATE_PLAYING;
                        saveGame();
                    }
                }
            } else if (gameState === STATE_GAME_OVER) {
                if (mouseX > 300 && mouseX < 500 && mouseY > 300 && mouseY < 350) {
                    localStorage.removeItem(SAVE_KEY);
                    gameState = STATE_MENU;
                }
            } else if (gameState === STATE_ATTRIBUTES) {
                if (mouseX > 300 && mouseX < 500 && mouseY > 500 && mouseY < 550) {
                    gameState = STATE_MENU;
                }
            }
        }

        function startGame() {
            const save = localStorage.getItem(SAVE_KEY);
            if (save) {
                loadSave(JSON.parse(save));
            } else {
                player = new Player();
            }
            spawnWave();
            gameState = STATE_PLAYING;
        }

        function spawnWave() {
            enemies = [];
            let numEnemies = 1 + Math.floor(level / 3);
            numEnemies = Math.min(6, numEnemies);
            if (wave % 5 === 0) {
                // Boss
                const type = ENEMY_TYPES[Math.floor(Math.random() * ENEMY_TYPES.length)];
                enemies.push(new Boss(type, level));
            } else {
                for (let i = 0; i < numEnemies; i++) {
                    const type = ENEMY_TYPES[Math.floor(Math.random() * ENEMY_TYPES.length)];
                    enemies.push(new Enemy(type, level));
                }
            }
            wave++;
        }

        function checkWaveClear() {
            if (enemies.length === 0) {
                xp += wave * 10; // wave bonus
                checkLevelUp();
                spawnWave();
            }
        }

        function checkLevelUp() {
            if (xp >= xpNeeded) {
                xp -= xpNeeded;
                level++;
                xpNeeded += 50;
                generateLevelUpOptions();
                gameState = STATE_LEVEL_UP;
                // PL increase every 3-5 levels
                if (level % (3 + Math.floor(Math.random() * 3)) === 0 && player.pl < 16) {
                    player.pl++;
                }
            }
        }

        function generateLevelUpOptions() {
            levelUpOptions = [];
            const pool = UPGRADES.filter(u => !usedUpgrades.includes(u.desc));
            // Prioritize unlocks early
            const unlockPool = pool.filter(u => u.type === 'unlock' && !player.availableAttacks.find(a => a.id === u.attackId));
            const otherPool = pool.filter(u => u.type !== 'unlock');
            for (let i = 0; i < 3; i++) {
                let choice;
                if (unlockPool.length > 0 && (Math.random() < 0.7 || otherPool.length === 0)) {
                    choice = unlockPool[Math.floor(Math.random() * unlockPool.length)];
                    unlockPool.splice(unlockPool.indexOf(choice), 1);
                } else if (otherPool.length > 0) {
                    choice = otherPool[Math.floor(Math.random() * otherPool.length)];
                    otherPool.splice(otherPool.indexOf(choice), 1);
                }
                if (choice) levelUpOptions.push(choice);
            }
        }

        function applyUpgrade(upgrade) {
            usedUpgrades.push(upgrade.desc);
            switch (upgrade.type) {
                case 'unlock':
                    const attack = ATTACKS.find(a => a.id === upgrade.attackId);
                    attack.unlocked = true;
                    player.availableAttacks.push(attack);
                    break;
                case 'buff_damage':
                    player.buffDamage += upgrade.value;
                    break;
                case 'buff_cd':
                    player.buffCd += upgrade.value;
                    break;
                case 'stat_atk':
                    player.atk += upgrade.value;
                    break;
                case 'stat_def':
                    player.def += upgrade.value;
                    break;
                case 'stat_pl':
                    player.pl = Math.min(16, player.pl + upgrade.value);
                    break;
                case 'shield_yield':
                    player.shieldYield += upgrade.value;
                    break;
                case 'shield_strength':
                    shieldStrength += upgrade.value; // global? or player
                    break;
                case 'shield_omni':
                    hasOmniShield = true;
                    // Auto regen or something
                    break;
            }
        }

        function saveGame() {
            const save = {
                level: level,
                xp: xp,
                wave: wave,
                pl: player.pl,
                atk: player.atk,
                def: player.def,
                unlocked: ATTACKS.filter(a => a.unlocked).map(a => a.id),
                buffs: { damage: player.buffDamage, cd: player.buffCd },
                shieldYield: player.shieldYield,
                hasOmniShield: hasOmniShield,
                usedUpgrades: usedUpgrades
            };
            localStorage.setItem(SAVE_KEY, JSON.stringify(save));
        }

        function loadSave(save) {
            level = save.level;
            xp = save.xp;
            wave = save.wave;
            player = new Player();
            player.pl = save.pl;
            player.atk = save.atk;
            player.def = save.def;
            save.unlocked.forEach(id => {
                const a = ATTACKS.find(at => at.id === id);
                a.unlocked = true;
            });
            player.availableAttacks = ATTACKS.filter(a => a.unlocked);
            player.buffDamage = save.buffs.damage;
            player.buffCd = save.buffs.cd;
            player.shieldYield = save.shieldYield;
            hasOmniShield = save.hasOmniShield;
            usedUpgrades = save.usedUpgrades;
            xpNeeded = 100 + (level - 1) * 50;
        }

        // Game Loop
        function gameLoop(timestamp) {
            deltaTime = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            ctx.fillStyle = COLOR_BLACK;
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            if (gameState === STATE_PLAYING) {
                player.update(deltaTime);
                enemies.forEach(e => e.update(deltaTime));
                projectiles.forEach(p => p.update(deltaTime));
                particles.forEach(pt => pt.update(deltaTime));

                player.draw();
                enemies.forEach(e => e.draw());
                projectiles.forEach(p => p.draw());
                particles.forEach(pt => pt.draw());

                drawUI();

                if (player.health <= 0) {
                    gameState = STATE_GAME_OVER;
                }
            } else if (gameState === STATE_MENU) {
                drawMenu();
            } else if (gameState === STATE_LEVEL_UP) {
                drawLevelUp();
            } else if (gameState === STATE_GAME_OVER) {
                drawGameOver();
            } else if (gameState === STATE_ATTRIBUTES) {
                drawAttributes();
            }

            requestAnimationFrame(gameLoop);
        }

        function drawUI() {
            ctx.fillStyle = COLOR_WHITE;
            ctx.font = '12px Arial';
            ctx.fillText(`Health: ${Math.floor(player.health)}/${player.maxHealth}`, 10, 20);
            ctx.fillText(`Mana: ${Math.floor(player.mana)}/${player.maxMana}`, 10, 40);
            ctx.fillText(`PL: ${player.pl}`, 10, 60);
            ctx.fillText(`ATK: ${player.atk}`, 10, 80);
            ctx.fillText(`DEF: ${player.def}`, 10, 100);
            ctx.fillText(`Level: ${level}`, 10, 120);
            ctx.fillText(`XP: ${xp}/${xpNeeded}`, 10, 140);

            // Spell list
            ctx.fillText('Spells:', CANVAS_WIDTH - 100, 20);
            player.availableAttacks.forEach((a, i) => {
                ctx.fillStyle = i === player.selectedAttack ? COLOR_GREEN : COLOR_WHITE;
                ctx.fillText(`${a.name} ${a.unlocked ? '' : '[LOCKED]'}`, CANVAS_WIDTH - 100, 40 + i * 20);
            });

            // Bottom controls
            ctx.fillStyle = COLOR_GRAY;
            ctx.fillText('WASD/Arrows: Move | Mouse: Aim | Click: Fire | , : Cycle | Space: Shield', 10, CANVAS_HEIGHT - 10);
        }

        function drawMenu() {
            ctx.fillStyle = COLOR_WHITE;
            ctx.font = '30px Arial';
            ctx.fillText('Alternate\'s Magical Evolution', 200, 100);

            ctx.fillRect(300, 200, 200, 50);
            ctx.fillStyle = COLOR_BLACK;
            ctx.fillText('Play', 370, 235);

            ctx.fillStyle = COLOR_WHITE;
            ctx.fillRect(300, 300, 200, 50);
            ctx.fillStyle = COLOR_BLACK;
            ctx.fillText('Attributes', 340, 335);
        }

        function drawLevelUp() {
            ctx.fillStyle = COLOR_WHITE;
            ctx.font = '30px Arial';
            ctx.fillText('Level Up! Choose Upgrade:', 200, 100);

            levelUpOptions.forEach((opt, i) => {
                ctx.fillStyle = COLOR_WHITE;
                ctx.fillRect(100, 200 + i * 100, 600, 50);
                ctx.fillStyle = COLOR_BLACK;
                ctx.fillText(opt.desc, 120, 235 + i * 100);
            });
        }

        function drawGameOver() {
            ctx.fillStyle = COLOR_RED;
            ctx.font = '40px Arial';
            ctx.fillText('Game Over', 300, 200);

            ctx.fillStyle = COLOR_WHITE;
            ctx.fillRect(300, 300, 200, 50);
            ctx.fillStyle = COLOR_BLACK;
            ctx.fillText('Restart', 350, 335);
        }

        function drawAttributes() {
            ctx.fillStyle = COLOR_WHITE;
            ctx.font = '20px Arial';
            ctx.fillText('Attributes:', 350, 100);
            ctx.fillText(`Level: ${level}`, 300, 150);
            ctx.fillText(`PL: ${player.pl}`, 300, 180);
            ctx.fillText(`ATK: ${player.atk}`, 300, 210);
            ctx.fillText(`DEF: ${player.def}`, 300, 240);
            ctx.fillText(`Unlocked Attacks: ${player.availableAttacks.map(a => a.name).join(', ')}`, 100, 270);

            ctx.fillRect(300, 500, 200, 50);
            ctx.fillStyle = COLOR_BLACK;
            ctx.fillText('Back', 370, 535);
        }

        // Start
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
