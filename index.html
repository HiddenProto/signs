<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Keyboard Doom ‚Äî Single File</title>
<style>
  html,body{height:100%;margin:0;background:#000;font-family:monospace; -webkit-font-smoothing:none; -moz-osx-font-smoothing:none;}
  #ui{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none;}
  canvas{display:block;background:#000; image-rendering:pixelated; cursor:none;}
  .menu{pointer-events:auto; width:720px; max-width:95%; color:#fff; text-align:center;}
  .title{font-size:48px; margin-bottom:12px; text-shadow:0 0 10px #0ff;}
  .btn{display:block;background:#111;border:2px solid #fff;padding:12px 20px;margin:8px auto;width:260px;cursor:pointer;box-shadow:0 0 8px rgba(0,255,255,0.08); transition:all .12s; user-select:none;}
  .btn.locked{opacity:.5;border-color:#666; pointer-events:none;}
  .btn:hover{background:#222; transform:translateY(-2px);}
  .pass{margin-top:8px;color:#ccc;}
  .pass input{padding:8px;border:2px solid #444;background:#000;color:#fff;width:240px;}
  #yourChoiceGrid{display:grid;grid-template-columns:repeat(10,50px);gap:4px;margin-top:12px;justify-content:center;}
  .stageBtn{width:50px;height:50px;background:#111;border:2px solid #222;color:#fff;display:flex;align-items:center;justify-content:center;cursor:pointer;transition:all .08s;}
  .stageBtn:hover{background:#444; transform:scale(1.08); box-shadow:0 0 8px #0ff;}
  #backBtn{position:fixed;right:16px;top:16px;padding:6px 10px;border:2px solid #fff;background:#111;cursor:pointer;pointer-events:auto;}
  .hud{position:fixed;left:12px;top:12px;color:#fff;font-size:18px;pointer-events:none}
  .centerHud{position:fixed;left:50%;transform:translateX(-50%);top:12px;color:#fff;font-size:18px;pointer-events:none}
  .bottomHud{position:fixed;left:50%;transform:translateX(-50%);bottom:12px;color:#fff;font-size:18px;pointer-events:none}
  .small{font-size:12px;color:#888;margin-top:8px}
  .passHint{font-size:12px;color:#6f6; margin-top:6px}
  #consolehint{display:none}
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="ui">
  <div id="menu" class="menu" style="pointer-events:auto;">
    <div class="title">KEYBOARD DOOM</div>
    <div id="btnWorld1" class="btn">World 1 ‚Äî Keyboard Trials</div>
    <div id="btnWorld2" class="btn locked">World 2 ‚Äî Unicode Nexus</div>
    <div id="btnYourChoice" class="btn locked">Your Choice ‚Äî Stage Select</div>
    <div class="pass">Passcode: <input id="passInput" placeholder="enter code and press Enter"/></div>
    <div class="small">Hint: console.log('showcode -> nexus7, toasty')</div>
    <div id="yourChoiceGrid" style="display:none"></div>
  </div>
  <div id="backBtn" style="display:none">Back</div>
  <div id="hudLeft" class="hud" style="display:none"></div>
  <div id="hudCenter" class="centerHud" style="display:none"></div>
  <div id="hudBottom" class="bottomHud" style="display:none"></div>
</div>

<script>
/*
  Keyboard Doom
  Single-file game implementing the specification provided.
  NOTE: This is a compact but featureful implementation. Certain
  tuning values were set to balance complexity, stability, and
  single-file size constraints.
*/

// ----------------------------- Utilities & Globals -----------------------------
console.log('showcode -> nexus7, toasty'); // console hint per spec

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d', { alpha: false });
let W = 1280, H = 720;
function resize() {
  const ratio = window.devicePixelRatio || 1;
  W = Math.max(640, Math.floor(window.innerWidth * 0.9));
  H = Math.max(480, Math.floor(window.innerHeight * 0.85));
  canvas.width = Math.floor(W * ratio);
  canvas.height = Math.floor(H * ratio);
  canvas.style.width = W + 'px';
  canvas.style.height = H + 'px';
  ctx.setTransform(ratio,0,0,ratio,0,0);
}
window.addEventListener('resize', resize);
resize();

let lastTime = performance.now();
let lastStamp = 0;
let dt = 0;
const MAX_DT = 0.05;

function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function rand(a=0,b=1){ return a + Math.random()*(b-a); }
function randInt(a,b){ return Math.floor(rand(a,b+1)); }
function choose(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
function now(){ return performance.now()/1000; }

// ----------------------------- Persistent Progress -----------------------------
const STORAGE_KEY = 'keyboardDoomProgress';
let progress = { world1:false, world2:false, yourChoice:false };
function loadProgress(){
  try{
    const s = localStorage.getItem(STORAGE_KEY);
    if(s) Object.assign(progress, JSON.parse(s));
  }catch(e){}
}
function saveProgress(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(progress)); }
loadProgress();

// ----------------------------- Input -----------------------------
let mouse = {x:W/2,y:H/2, sx:W/2, sy:H/2};
canvas.addEventListener('mousemove', e=>{
  const rect = canvas.getBoundingClientRect();
  mouse.x = clamp((e.clientX - rect.left) * (canvas.width / rect.width) / (window.devicePixelRatio||1), 0, W);
  mouse.y = clamp((e.clientY - rect.top) * (canvas.height / rect.height) / (window.devicePixelRatio||1), 0, H);
});
window.addEventListener('keydown', e=>{
  if(state === 'playing' && e.key.toLowerCase()==='r') restartStage();
  // debug shortcuts
  if(e.key==='`'){ console.log({progress}); }
});
document.getElementById('passInput').addEventListener('keydown', (e)=>{
  if(e.key==='Enter'){ checkPasscode(e.target.value.trim()); e.target.value=''; }
});

// ----------------------------- State Machine -----------------------------
let state = 'menu'; // 'menu','playing','gameover','yourchoice'
let currentWorld = 1; // 1 or 2
let currentStage = null; // object with properties
let stageTimer = 0, stageDuration = 8;
let transitioning = false;
let transitionT = 0;
let player = null;
let projectiles = []; // pool active
let particlePool = [];
let particles = [];
let diggers = [];
let popups = [];
let eventsQueue = [];
let eventTimer = 0;
let stageIndexCounter = 0;
let seedCounter = 0;
let screenShake = 0;
let stageStartTime = 0;

// Pools sizes
const MAX_PROJECTILES = 1000;
const MAX_PARTICLES = 1000;

// ----------------------------- Collision Routines (Exact names as requested) -----------------------------
function circleCircle(x1,y1,r1,x2,y2,r2){
  const dx = x2-x1, dy = y2-y1;
  return dx*dx + dy*dy < (r1+r2)*(r1+r2);
}
function rectCircle(rx,ry,rw,rh,cx,cy,cr){
  const closestX = clamp(cx, rx, rx+rw);
  const closestY = clamp(cy, ry, ry+rh);
  const dx = cx - closestX, dy = cy - closestY;
  return dx*dx + dy*dy < cr*cr;
}
function lineCircle(x1,y1,x2,y2,cx,cy,cr){
  const vx = x2-x1, vy = y2-y1;
  const wx = cx-x1, wy = cy-y1;
  const c1 = vx*wx + vy*wy;
  if(c1 <= 0) return (cx-x1)*(cx-x1) + (cy-y1)*(cy-y1) <= cr*cr;
  const c2 = vx*vx + vy*vy;
  if(c2 <= c1) return (cx-x2)*(cx-x2) + (cy-y2)*(cy-y2) <= cr*cr;
  const b = c1 / c2;
  const px = x1 + b*vx, py = y1 + b*vy;
  const dx = cx-px, dy = cy-py;
  return dx*dx + dy*dy <= cr*cr;
}
function rotatedRectCircle(x,y,w,h,angle,cx,cy,cr){
  // rotate circle into rect local space
  const s = Math.sin(-angle), c = Math.cos(-angle);
  const rx = c*(cx-x) - s*(cy-y) + x;
  const ry = s*(cx-x) + c*(cy-y) + y;
  return rectCircle(x - w/2, y - h/2, w, h, rx, ry, cr);
}

// ----------------------------- Visual helpers -----------------------------
function drawText(s,x,y,size=18,align='center',color='#fff',shadow=false){
  ctx.save();
  ctx.font = `${size}px monospace`;
  ctx.textAlign = align;
  ctx.fillStyle = color;
  if(shadow){
    ctx.shadowColor = color;
    ctx.shadowBlur = 10;
  } else ctx.shadowBlur = 0;
  ctx.fillText(s, x, y);
  ctx.restore();
}
function screenShakeOffset(){
  if(screenShake <= 0) return {x:0,y:0};
  const s = screenShake;
  return {x: rand(-s,s), y: rand(-s,s)};
}

// ----------------------------- Player -----------------------------
function createPlayer(){
  return {
    x: W/2, y: H/2, r:10, color:'#0f0',
    maxHP:100, hp:100,
    maxShield:50, shield:0,
    overshieldCap:100,
    moveLerp:0.08, // will be modified by speed effects
    status:[], // {type,duration,stack}
    speedMultiplier:1,
    invulnerable: false
  };
}
function applyDamage(amount, bypassShield=false){
  if(player.invulnerable) return;
  let amt = amount;
  // Protection buff halves damage
  const prot = player.status.find(s=>s.type==='protection' && s.duration>0);
  if(prot) amt *= 0.5;
  // Shield first unless bypass
  let rem = amt;
  if(!bypassShield && player.shield>0){
    const d = Math.min(player.shield, rem);
    player.shield -= d;
    rem -= d;
  }
  if(rem>0){
    player.hp = Math.max(0, player.hp - rem);
  }
  pushPopup(`-${Math.round(amt)}`, player.x, player.y - 20, '#f55');
  screenShake = Math.min(20, screenShake + Math.min(20, amt));
  // death
  if(player.hp <= 0){
    onPlayerDeath();
  }
}
function healPlayer(amount){
  const prev = player.hp;
  player.hp = Math.min(player.maxHP, player.hp + amount);
  pushPopup(`+${Math.round(player.hp-prev)}`, player.x, player.y - 20, '#9f9');
}
function addShield(amount){
  player.shield = Math.min(player.overshieldCap, player.shield + amount);
  pushPopup(`+${Math.round(amount)} Shield`, player.x, player.y - 20, '#9ff');
}

// ----------------------------- Particles & Popups -----------------------------
function pushParticle(x,y,vx,vy,life,color,size=3){
  if(particles.length >= MAX_PARTICLES) return;
  particles.push({x,y,vx,vy,life,age:0,color,size});
}
function spawnBurst(x,y,count,color){
  for(let i=0;i<count;i++){
    const a = rand(0,Math.PI*2);
    const s = rand(30,120);
    pushParticle(x,y, Math.cos(a)*s, Math.sin(a)*s, rand(0.6,1.2), color, rand(1,3));
  }
}
function pushPopup(text,x,y,color='#fff',life=1.2){
  popups.push({text,x,y,vy:-40,age:0,life,color});
}

// ----------------------------- Projectiles -----------------------------
function makeProjectile(o){
  // structure: {x,y,vx,vy,r,color,owner,ttl,meta}
  projectiles.push(Object.assign({
    x:0,y:0,vx:0,vy:0,r:5,color:'#fff',owner:'enemy',ttl:5,meta:{}
  }, o));
}
function clearProjectiles(){
  projectiles.length = 0;
}

// ----------------------------- Diggers -----------------------------
const DIGGER_TIERS = [
  {name:'Common', color:'#888', hp:100, regen:1, size:12, bonus:null, prob:0.6},
  {name:'Uncommon', color:'#00f', hp:150, regen:2, size:14, bonus:'spin', prob:0.2},
  {name:'Rare', color:'#0f0', hp:200, regen:3, size:16, bonus:'aoe', prob:0.1},
  {name:'Epic', color:'#f0f', hp:250, regen:5, size:18, bonus:'deflect', prob:0.03},
  {name:'Legendary', color:'#ff0', hp:300, regen:7, size:20, bonus:'ram', prob:0.02},
  {name:'Legionary', color:'#f80', hp:350, regen:10, size:22, bonus:'homing', prob:0.015},
  {name:'Mythic', color:'#0ff', hp:400, regen:15, size:24, bonus:'aura', prob:0.01},
  {name:'Myth', color:'#fff', hp:500, regen:20, size:26, bonus:'reflect', prob:0.025}
];

// compute cumulative probabilities
(function computeCum(){
  let sum=0;
  for(let t of DIGGER_TIERS){ sum += t.prob; t.cum = sum; }
  // normalize to 1
  for(let t of DIGGER_TIERS){ t.cum /= sum; }
})();

function trySpawnDigger(dt){
  // spawn chance ~0.005/dt per spec; scale with dt
  const chance = 0.005;
  if(Math.random() < chance * (dt*60)){
    // select tier by cum probability
    const r = Math.random();
    let chosen = DIGGER_TIERS[0];
    for(let t of DIGGER_TIERS){ if(r <= t.cum){ chosen = t; break; } }
    if(diggers.length >= 3) return;
    const behavior = choose(['Sentinel','Rammer','Guardian']);
    const x = rand(50, W-50), y = rand(50, H-50);
    const dig = {
      id: 'd'+(seedCounter++),
      x,y, vx:0, vy:0,
      tier: chosen,
      hp: chosen.hp,
      maxHp: chosen.hp,
      regen: chosen.regen,
      r: chosen.size,
      color: chosen.color,
      behavior,
      orbitAngle: rand(0,Math.PI*2),
      spin: rand(0.5,2),
      alive:true,
      persist: ['Epic','Legendary','Legionary','Mythic','Myth'].includes(chosen.name)
    };
    diggers.push(dig);
    pushPopup(`‚öô Digger Spawned: ${chosen.name} ${behavior}`, dig.x, dig.y-10, '#ffd');
  }
}

function updateDiggers(dt){
  for(let i=diggers.length-1;i>=0;i--){
    const d = diggers[i];
    if(!d.alive) continue;
    // regen
    d.hp = Math.min(d.maxHp, d.hp + d.regen*dt);
    // behavior
    if(d.behavior === 'Sentinel'){
      // stay
    }else if(d.behavior==='Rammer'){
      // seek nearest projectile
      let nearest = null; let nd = 1e9;
      for(let p of projectiles){
        if(p.owner === 'enemy'){
          const dx = p.x - d.x, dy = p.y - d.y;
          const dist = dx*dx + dy*dy;
          if(dist < nd){ nd=dist; nearest=p; }
        }
      }
      if(nearest){
        const angle = Math.atan2(nearest.y - d.y, nearest.x - d.x);
        const sp = 100;
        d.vx += Math.cos(angle)*sp*dt;
        d.vy += Math.sin(angle)*sp*dt;
        const cap = 100;
        const speed = Math.hypot(d.vx,d.vy);
        if(speed > cap){ d.vx *= cap/speed; d.vy *= cap/speed; }
        d.x += d.vx*dt; d.y += d.vy*dt;
      }
    }else if(d.behavior==='Guardian'){
      // orbit player
      d.orbitAngle += 0.5 * dt;
      const rad = 100 + d.r;
      d.x = player.x + Math.cos(d.orbitAngle) * rad;
      d.y = player.y + Math.sin(d.orbitAngle) * rad;
    }
    // collisions with projectiles
    for(let j=projectiles.length-1;j>=0;j--){
      const p = projectiles[j];
      if(p.owner !== 'enemy') continue;
      if(circleCircle(d.x,d.y,d.r, p.x,p.y,p.r)){
        // process based on tier bonuses
        if(d.tier.bonus === 'deflect' && Math.random() < 0.3){
          // destroy projectile
          spawnBurst(p.x,p.y,8,'#fff');
          projectiles.splice(j,1);
          pushPopup('Deflect', d.x, d.y-6, '#ff0');
        }else if(d.tier.bonus === 'reflect' && Math.random() < 0.5){
          // reverse velocity, boost
          p.vx *= -1.5; p.vy *= -1.5; p.owner = 'digger';
          pushPopup('Reflect', d.x, d.y-6, '#0ff');
        }else{
          // destroy projectile and damage digger slightly
          d.hp -= 5;
          spawnBurst(p.x,p.y,6,'#fff');
          projectiles.splice(j,1);
        }
        if(d.hp <= 0){ explodeDigger(i); break; }
      }
    }
    // keep bounds
    d.x = clamp(d.x, 20, W-20);
    d.y = clamp(d.y, 20, H-20);
  }
}
function explodeDigger(index){
  const d = diggers[index];
  spawnBurst(d.x,d.y,50,d.color);
  screenShake = Math.min(30, screenShake + 10);
  pushPopup(`DIGGER DOWN`, d.x, d.y-6, '#f55');
  d.alive = false;
  diggers.splice(index,1);
}

// call on stage transition
function handleDiggerDonations(){
  for(let i=diggers.length-1;i>=0;i--){
    const d = diggers[i];
    if(!d.persist){
      // donate HP/10 to player shield as overshield
      if(d.hp>0){
        const donate = Math.floor(d.hp/10);
        player.overshieldCap = Math.max(player.overshieldCap, player.maxShield*2);
        addShield(donate);
        pushPopup(`+${donate} Shield (Digger Donation)`, player.x, player.y-12, '#9ff');
      }
      diggers.splice(i,1);
    }
  }
}

// ----------------------------- Stage Patterns -----------------------------
const KEY_STAGE_LIST = (function(){
  // build keys: a-z, 0-9, symbols approx, specials
  const keys = [];
  for(let i=0;i<26;i++) keys.push(String.fromCharCode(97+i));
  for(let i=0;i<10;i++) keys.push(String.fromCharCode(48+i));
  const symbols = ['!','@','#','$','%','^','&','*','(',')','-','_','=','+','[',']','{','}','|',';',':',"'",'"',',','.','<','>','/','?','`','~'];
  keys.push(...symbols);
  const specials = ['Space','Enter','Backspace','Tab','Shift','Ctrl','Alt','CapsLock','Escape','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'];
  keys.push(...specials);
  return keys;
})();
const UNICODE_SYMBOLS = ['‚òÖ','‚ò†','‚ùÑ','‚ô†','‚ô•','‚ô¶','‚ô£','‚òÄ','‚òÅ','‚òÇ','‚òÉ','‚òÜ','‚ôÄ','‚ôÇ','‚óà','‚óâ','‚óé','‚óè','‚óã','‚ñ†','‚ñ°','‚ñ≤','‚ñ≥','‚ñ∂','‚ñ∑','‚ñº','‚ñΩ','‚óÄ','‚óÅ','‚òé','‚òè','‚åõ','‚è∞','‚úà','‚òÑ','üíß','üí®','üî•','‚ö°','üåô','‚≠ê','üåü','üí´','‚ú®'];
// ensure at least 40
while(UNICODE_SYMBOLS.length < 40){
  UNICODE_SYMBOLS.push(String.fromCharCode(0x2600 + UNICODE_SYMBOLS.length));
}

// Pattern generator functions
function stagePatternForKey(key, idx){
  // produce an object describing the pattern parameters based on index
  const baseSpeed = 80 + (idx % 10) * 6;
  const count = 3 + (idx % 8);
  const type = idx % 6; // variety
  return {key, type, speed:baseSpeed, count, idx};
}
function stagePatternForUnicode(sym, idx){
  const baseSpeed = 120 + idx*3;
  const arms = 1 + (idx % 4);
  const amp = 20 + (idx%8)*8;
  const freq = 0.05 + (idx%11)*0.008;
  const count = 4 + (idx%6)*2;
  return {sym, arms, speed:baseSpeed, amp, freq, count, idx};
}

// create arrays of stage objects
const WORLD1_STAGES = KEY_STAGE_LIST.map((k,i)=>({
  id:'k_'+k,
  display: (k.length===1? k.toUpperCase() : k),
  key:k,
  pattern: stagePatternForKey(k,i)
}));
const WORLD2_STAGES = UNICODE_SYMBOLS.map((s,i)=>({
  id:'u_'+i,
  display: s,
  symbol: s,
  pattern: stagePatternForUnicode(s,i)
}));

// ----------------------------- Stage Execution -----------------------------
function startStage(world, stageObj){
  state = 'playing';
  currentWorld = world;
  currentStage = stageObj;
  stageIndexCounter++;
  stageStartTime = now();
  stageDuration = (world===1 ? randInt(5,12) : (stageObj.forceDuration || randInt(5,12)));
  if(world===3) stageDuration = 20;
  stageTimer = stageDuration;
  transitioning = false;
  player.invulnerable = false;
  // stage-specific init: spawn some patterned projectiles immediately
  if(world===1){
    generatePatternWorld1(stageObj.pattern);
  } else {
    generatePatternWorld2(stageObj.pattern);
  }
}

function restartStage(){
  // clear hazards but keep diggers per rules
  clearProjectiles();
  particles.length = 0;
  popups.length = 0;
  player.hp = player.maxHP;
  player.shield = 0;
  player.overshieldCap = player.maxShield*1;
  if(currentStage) startStage(currentWorld, currentStage);
}

function endStage(success=true){
  // healing
  if(success){
    healPlayer(12);
    // progression
    if(currentWorld===1){
      progress.world1 = true;
      if(!progress.world2) { /* unlock hint remains */ }
    } else if(currentWorld===2){
      progress.world2 = true;
      progress.world1 = true;
    }
    saveProgress();
  }
  // donations
  handleDiggerDonations();
  // transitions
  transitioning = true;
  transitionT = 0;
  clearProjectiles(); // cleanup as spec
}

// ----------------------------- Procedural Pattern Implementations -----------------------------
function generatePatternWorld1(p){
  // create patterns based on p.type
  const cx = W/2, cy = H/2;
  const idx = p.idx;
  if(p.type === 0){
    // radial burst
    const n = 6 + (idx%6);
    for(let i=0;i<n;i++){
      const a = i / n * Math.PI*2;
      makeProjectile({x:cx, y:cy, vx:Math.cos(a)*p.speed, vy:Math.sin(a)*p.speed, r:6, color:'#0ff', ttl:6});
    }
  } else if(p.type === 1){
    // zigzag lasers: spawn waves from left/right
    const waves = 4;
    for(let w=0; w<waves; w++){
      const y = rand(50,H-50);
      const dir = w%2===0?1:-1;
      const amp = 60;
      let t=0;
      for(let i=0;i<8;i++){
        const a = Math.sin(t)*amp;
        makeProjectile({x: dir>0? -20 : W+20, y: y + a, vx: dir*p.speed, vy: rand(-20,20), r:5, color:'#f0f', ttl:6});
        t += 0.5;
      }
    }
  } else if(p.type === 2){
    // expanding rings
    for(let ring=1; ring<=3; ring++){
      const n = 8 + ring*4;
      const sp = p.speed + ring*40;
      for(let i=0;i<n;i++){
        const a = i/n*Math.PI*2;
        makeProjectile({x:cx,y:cy,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,r:5,color:'#ff0',ttl:6});
      }
    }
  } else if(p.type === 3){
    // moving shield wall (Shift-like)
    const wallY = rand(80,H-80);
    const w = 300, h = 20;
    // simulate by many projectiles forming line
    for(let i=0;i<40;i++){
      const px = i/40*W;
      makeProjectile({x:px,y: wallY + (i%2?8:-8), vx:0,vy:0, r:10, color:'#0ff', ttl:6, meta:{static:true, rect:[px-8, wallY-10, 16, 20]}});
    }
  } else if(p.type === 4){
    // slicing beams: long thin lasers sweeping
    const len = 400;
    const center = {x: W/2, y: H/2};
    for(let i=0;i<3;i++){
      const ang = rand(0,Math.PI*2);
      const vx = Math.cos(ang)* (p.speed*0.4);
      const vy = Math.sin(ang)* (p.speed*0.4);
      makeProjectile({x:center.x, y:center.y, vx: vx, vy: vy, r:8, color:'#f55', ttl:6, meta:{beam:true, len}});
    }
  } else {
    // fallback: spiral orbitals
    const arms = 2 + (idx%4);
    for(let a=0;a<arms;a++){
      const angle = a/arms*Math.PI*2;
      for(let i=0;i<6;i++){
        const sp = p.speed + i*10;
        makeProjectile({x:W/2,y:H/2,vx:Math.cos(angle+i*0.2)*sp,vy:Math.sin(angle+i*0.2)*sp,r:4,color:'#9f9',ttl:6});
      }
    }
  }
}

function generatePatternWorld2(p){
  // more complex patterns
  const cx = W/2, cy = H/2;
  const idx = p.idx;
  const variant = idx % 6;
  if(p.sym === '‚òÖ' || variant===0){
    // spiral arms
    const arms = p.arms;
    const base = p.speed;
    for(let a=0;a<arms;a++){
      for(let i=0;i<12;i++){
        const t = i/12;
        const angle = t*Math.PI*2 + a*(Math.PI*2/arms);
        const sp = base + i*6;
        makeProjectile({x:cx + Math.cos(angle)*20, y:cy + Math.sin(angle)*20, vx:Math.cos(angle)*sp, vy:Math.sin(angle)*sp, r:5, color:'#ff9', ttl:6});
      }
    }
  } else if(p.sym === '‚ò†' || variant===1){
    // homing poison burst
    for(let i=0;i<8;i++){
      const a = rand(0,Math.PI*2);
      const sp = p.speed;
      makeProjectile({x:rand(0,W),y:rand(0,H),vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,r:6,color:'#a0f',ttl:6, meta:{homing:true, strength:120}});
    }
  } else if(variant===2){
    // freeze wave (sinusoidal)
    for(let i=0;i<6;i++){
      const y0 = i/(6-1)*(H-100)+50;
      for(let x=0;x<W;x+=80){
        const vx = 0;
        const vy = 0;
        makeProjectile({x:x,y:y0 + Math.sin(x/60 + i)*p.amp, vx:0, vy:0, r:6, color:'#9ff', ttl:6, meta:{wave:true}});
      }
    }
  } else if(variant===3){
    // orbitals with rotating center
    const centerX = rand(100,W-100), centerY = rand(100,H-100);
    for(let a=0;a< p.count; a++){
      const ang = a / p.count * Math.PI*2;
      const sp = p.speed + a*5;
      makeProjectile({x:centerX + Math.cos(ang)*40, y:centerY + Math.sin(ang)*40, vx:Math.cos(ang)*sp, vy:Math.sin(ang)*sp, r:5, color:'#f0f', ttl:6});
    }
  } else {
    // rotating laser fan
    const n = 12 + (idx%8);
    const speed = p.speed;
    for(let i=0;i<n;i++){
      const a = i/n*Math.PI*2 + idx*0.1;
      makeProjectile({x:cx,y:cy,vx:Math.cos(a)*speed,vy:Math.sin(a)*speed,r:5,color:'#f55',ttl:6});
    }
  }
}

// ----------------------------- Event System (World 2 Only) -----------------------------
const ACTIVE_EVENTS = [];
const EVENT_BUFFS = [
  {id:'protection', label:'Protection', icon:'üõ°Ô∏è', chance:0.6, effect:()=>{ ACTIVE_EVENTS.push({id:'protection', duration:5}); player.status.push({type:'protection', duration:5}); }},
  {id:'shieldRegen', label:'Shield Regen', icon:'üîÑ', chance:0.6, effect:()=>{ ACTIVE_EVENTS.push({id:'shieldRegen', duration:6}); player.overshieldCap = Math.max(player.overshieldCap, player.maxShield*2); player.status.push({type:'shieldRegen', duration:6}); }},
  {id:'speedBoost', label:'Speed Boost', icon:'‚ö°', chance:0.6, effect:()=>{ ACTIVE_EVENTS.push({id:'speedBoost', duration:5}); player.status.push({type:'speedBoost', duration:5}); player.speedMultiplier = 1.5; }},
  {id:'regen', label:'Regen', icon:'‚ù§Ô∏è', chance:0.6, effect:()=>{ ACTIVE_EVENTS.push({id:'regen', duration:5}); player.status.push({type:'regen', duration:5}); }}
];
const EVENT_DEBUFFS = [
  {id:'slow', label:'Slow', icon:'üêå', chance:0.4, effect:()=>{ ACTIVE_EVENTS.push({id:'slow', duration:4}); player.status.push({type:'slow', duration:4}); player.speedMultiplier = 0.6; }},
  {id:'poison', label:'Poison', icon:'‚ò†', chance:0.4, effect:()=>{ ACTIVE_EVENTS.push({id:'poison', duration:4}); player.status.push({type:'poison', duration:4}); }}
];

function world2EventTick(){
  if(currentWorld!==2 || state!=='playing') return;
  if(eventTimer <= 0){
    eventTimer = rand(4,7);
    // warning: flash a unicode symbol center-screen for 1.5s
    const sym = choose(UNICODE_SYMBOLS);
    pushPopup(sym, W/2, H/2 - 40, '#fff', 1.5);
    // after 1.5s, resolve
    setTimeout(()=>{
      // 60% buff, 40% debuff
      const roll = Math.random();
      if(roll < 0.6){
        const buff = choose(EVENT_BUFFS);
        buff.effect();
        pushPopup('+'+buff.label, W/2, H/2-20, '#9f9');
      } else {
        const db = choose(EVENT_DEBUFFS);
        db.effect();
        pushPopup('-'+db.label, W/2, H/2-20, '#f99');
      }
    }, 1500);
  }
}

// ----------------------------- Update Loop -----------------------------
function update(dt){
  // cap dt
  dt = Math.min(dt, MAX_DT);

  // smooth player movement toward mouse with lerp
  const effectiveLerp = player.moveLerp * (1 + (0.08 * (1 - player.speedMultiplier || 0)));
  player.x += (mouse.x - player.x) * clamp(8 * dt * (player.speedMultiplier || 1), 0.02, 1);
  player.y += (mouse.y - player.y) * clamp(8 * dt * (player.speedMultiplier || 1), 0.02, 1);
  player.x = clamp(player.x, player.r, W - player.r);
  player.y = clamp(player.y, player.r, H - player.r);

  // update projectiles
  for(let i=projectiles.length-1;i>=0;i--){
    const p = projectiles[i];
    // apply homing
    if(p.meta && p.meta.homing){
      // home toward player
      const ang = Math.atan2(player.y - p.y, player.x - p.x);
      const s = 60;
      p.vx += Math.cos(ang) * (s * dt);
      p.vy += Math.sin(ang) * (s * dt);
    }
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.ttl -= dt;
    // collision with player
    if(circleCircle(player.x, player.y, player.r + (player.shield>0?2:0), p.x, p.y, p.r)){
      // determine damage
      let dmg = 10;
      if(p.meta && p.meta.beam) dmg = 25;
      if(p.meta && p.meta.strong) dmg = 20;
      const bypass = p.meta && p.meta.poison;
      applyDamage(dmg, bypass);
      // spawn hit particles
      spawnBurst(p.x,p.y,8,p.color || '#fff');
      projectiles.splice(i,1);
      continue;
    }
    // remove if out of bounds or ttl
    if(p.x < -50 || p.x > W+50 || p.y < -50 || p.y > H+50 || p.ttl<=0){
      projectiles.splice(i,1);
    }
  }

  // update particles
  for(let i=particles.length-1;i>=0;i--){
    const pt = particles[i];
    pt.age += dt;
    if(pt.age >= pt.life){ particles.splice(i,1); continue; }
    pt.x += pt.vx * dt;
    pt.y += pt.vy * dt;
    pt.vx *= 0.98;
    pt.vy *= 0.98;
  }

  // update popups
  for(let i=popups.length-1;i>=0;i--){
    const p = popups[i];
    p.age += dt;
    if(p.age >= p.life){ popups.splice(i,1); continue;}
    p.y += p.vy * dt;
    p.vy *= 0.95;
  }

  // update status effects timers
  player.speedMultiplier = 1;
  const newStatus = [];
  for(let s of player.status){
    s.duration -= dt;
    if(s.duration > 0) newStatus.push(s);
    // per-frame effects
    if(s.type==='regen'){ healPlayer(25*dt); }
    if(s.type==='shieldRegen'){ addShield(30*dt); }
    if(s.type==='poison'){ if(player.hp > 20) applyDamage(7*dt, true); }
    if(s.type==='speedBoost'){ player.speedMultiplier = Math.max(player.speedMultiplier, 1.5); }
    if(s.type==='slow'){ player.speedMultiplier = Math.min(player.speedMultiplier, 0.6); }
  }
  player.status = newStatus;

  // update diggers
  updateDiggers(dt);

  // try spawning diggers occasionally
  trySpawnDigger(dt);

  // events for world 2
  if(currentWorld===2){
    eventTimer -= dt;
    world2EventTick();
  }

  // update stage timer
  if(!transitioning && state==='playing'){
    stageTimer -= dt;
    if(stageTimer <= 0){
      // end stage success
      endStage(true);
    }
  }else if(transitioning){
    transitionT += dt;
    if(transitionT > 2){
      // transition complete -> go back to menu or next stage
      transitioning = false;
      // after stage, auto-select next stage randomly
      if(currentWorld===1){
        // pick next random key stage
        const next = choose(WORLD1_STAGES);
        startStage(1, next);
      } else {
        const next = choose(WORLD2_STAGES);
        startStage(2, next);
      }
    }
  }

  // screen shake decay
  screenShake *= Math.pow(0.9, dt*60);
  if(screenShake < 0.01) screenShake = 0;
}

// ----------------------------- Render -----------------------------
function render(){
  // background
  ctx.fillStyle = '#000';
  ctx.fillRect(0,0,W,H);

  // apply screen shake
  const off = screenShakeOffset();
  ctx.save();
  ctx.translate(off.x, off.y);

  // draw projectiles
  for(const p of projectiles){
    ctx.save();
    ctx.beginPath();
    ctx.fillStyle = p.color || '#fff';
    ctx.shadowColor = p.color || '#fff';
    ctx.shadowBlur = 10;
    ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  // draw diggers
  for(const d of diggers){
    // core
    ctx.save();
    ctx.translate(d.x, d.y);
    ctx.beginPath();
    ctx.fillStyle = d.color;
    ctx.shadowColor = d.color;
    ctx.shadowBlur = 20;
    ctx.arc(0,0,d.r,0,Math.PI*2);
    ctx.fill();
    // spikes
    ctx.fillStyle = '#fff';
    for(let i=0;i<8;i++){
      const a = i/8*Math.PI*2 + now()*d.spin;
      ctx.beginPath();
      const bx = Math.cos(a)*(d.r+2), by = Math.sin(a)*(d.r+2);
      ctx.moveTo(bx,by);
      const tx = Math.cos(a)*(d.r+14), ty = Math.sin(a)*(d.r+14);
      ctx.lineTo(tx,ty);
      ctx.lineTo(Math.cos(a+0.2)*(d.r+6), Math.sin(a+0.2)*(d.r+6));
      ctx.closePath();
      ctx.fill();
    }
    // hp bar
    const barW = 40, barH = 6;
    ctx.fillStyle = '#222';
    ctx.fillRect(-barW/2, -d.r-12, barW, barH);
    const pct = clamp(d.hp / d.maxHp, 0, 1);
    ctx.fillStyle = pct>0.6? '#0f0' : pct>0.3? '#ff0' : '#f55';
    ctx.fillRect(-barW/2, -d.r-12, barW*pct, barH);
    ctx.restore();
  }

  // draw player
  ctx.save();
  ctx.beginPath();
  ctx.fillStyle = player.color;
  ctx.shadowColor = '#0ff';
  ctx.shadowBlur = player.shield>player.maxShield?30:10;
  ctx.arc(player.x, player.y, player.r, 0, Math.PI*2);
  ctx.fill();
  // shield ring
  ctx.lineWidth = 2;
  ctx.strokeStyle = '#0ff';
  ctx.beginPath();
  ctx.arc(player.x, player.y, player.r + 6 + (player.shield/10), 0, Math.PI*2);
  ctx.stroke();
  ctx.restore();

  // draw particles
  for(const pt of particles){
    ctx.save();
    ctx.globalAlpha = 1 - pt.age/pt.life;
    ctx.fillStyle = pt.color;
    ctx.shadowColor = pt.color;
    ctx.shadowBlur = 8;
    ctx.fillRect(pt.x-pt.size/2, pt.y-pt.size/2, pt.size, pt.size);
    ctx.restore();
  }

  // popups
  for(const p of popups){
    ctx.save();
    ctx.globalAlpha = 1 - (p.age / p.life);
    ctx.font = '16px monospace';
    ctx.fillStyle = p.color;
    ctx.textAlign = 'center';
    ctx.fillText(p.text, p.x, p.y);
    ctx.restore();
  }

  ctx.restore(); // end screen shake

  // HUD overlay
  document.getElementById('hudLeft').style.display = state==='playing' ? 'block' : 'none';
  document.getElementById('hudCenter').style.display = state==='playing' ? 'block' : 'none';
  document.getElementById('hudBottom').style.display = state==='playing' ? 'block' : 'none';

  // top-left
  const hudLeft = document.getElementById('hudLeft');
  hudLeft.innerHTML = `HP: ${Math.round(player.hp)}/${player.maxHP}<br>Shield: ${Math.round(player.shield)}/${player.maxShield}${player.overshieldCap>player.maxShield?' (OS)':''}<br>Stage: ${currentStage? (currentStage.display||currentStage.symbol) : '---'}`;

  // top-center
  const hudCenter = document.getElementById('hudCenter');
  hudCenter.innerHTML = `Time: ${Math.max(0,Math.round(stageTimer))}s`;

  // bottom
  const hudBottom = document.getElementById('hudBottom');
  hudBottom.innerHTML = `DODGE | UNICODE BUFFS | R = RESTART`;

  // draw center event warning if any active events
  // draw transition fade
  if(transitioning){
    const t = clamp(transitionT/2,0,1);
    ctx.fillStyle = `rgba(0,0,0,${t})`;
    ctx.fillRect(0,0,W,H);
  }
  // game over
  if(state==='gameover'){
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(0,0,W,H);
    drawText('GAME OVER', W/2, H/2-20, 48, 'center', '#f33', true);
    drawText('Press R to Restart', W/2, H/2+30, 24, 'center', '#fff', false);
  }
}

// ----------------------------- Stage Selection UI (Your Choice) -----------------------------
const yourChoiceGrid = document.getElementById('yourChoiceGrid');
function buildYourChoiceGrid(){
  yourChoiceGrid.innerHTML = '';
  for(let s of WORLD1_STAGES.slice(0,70)){
    const btn = document.createElement('div');
    btn.className = 'stageBtn';
    btn.textContent = s.display.length>2 ? s.display.slice(0,2) : s.display;
    btn.style.pointerEvents = 'auto';
    btn.addEventListener('click', ()=>{ startStage(1, s); showInGameUI(); });
    yourChoiceGrid.appendChild(btn);
  }
  for(let s of WORLD2_STAGES.slice(0,40)){
    const btn = document.createElement('div');
    btn.className = 'stageBtn';
    btn.textContent = s.display;
    btn.style.pointerEvents = 'auto';
    btn.addEventListener('click', ()=>{ startStage(2, s); showInGameUI(); });
    yourChoiceGrid.appendChild(btn);
  }
}

// ----------------------------- UI Controls -----------------------------
const btnWorld1 = document.getElementById('btnWorld1');
const btnWorld2 = document.getElementById('btnWorld2');
const btnYourChoice = document.getElementById('btnYourChoice');
const menu = document.getElementById('menu');
const backBtn = document.getElementById('backBtn');

function updateMenuLocks(){
  if(progress.world2){ btnWorld2.classList.remove('locked'); }
  else btnWorld2.classList.add('locked');
  if(progress.yourChoice){ btnYourChoice.classList.remove('locked'); }
  else btnYourChoice.classList.add('locked');
}
updateMenuLocks();

btnWorld1.addEventListener('click', ()=>{
  buildYourChoiceGrid();
  player = createPlayer();
  startStage(1, choose(WORLD1_STAGES));
  showInGameUI();
});
btnWorld2.addEventListener('click', ()=>{
  if(!progress.world2){ alert('World 2 locked. Enter passcode or complete World 1.'); return; }
  buildYourChoiceGrid();
  player = createPlayer();
  startStage(2, choose(WORLD2_STAGES));
  showInGameUI();
});
btnYourChoice.addEventListener('click', ()=>{
  if(!progress.yourChoice){ alert('Your Choice locked. Finish both worlds or enter passcode.'); return; }
  // show selection grid
  menu.querySelector('.title').textContent = 'YOUR CHOICE ‚Äî Select Stage';
  yourChoiceGrid.style.display = 'grid';
  backBtn.style.display = 'block';
  btnWorld1.style.display = 'none';
  btnWorld2.style.display = 'none';
  btnYourChoice.style.display = 'none';
});

backBtn.addEventListener('click', ()=>{
  // reset menu
  menu.querySelector('.title').textContent = 'KEYBOARD DOOM';
  yourChoiceGrid.style.display = 'none';
  backBtn.style.display = 'none';
  btnWorld1.style.display = 'block';
  btnWorld2.style.display = 'block';
  btnYourChoice.style.display = 'block';
});

function showInGameUI(){
  menu.style.display = 'none';
  document.getElementById('hudLeft').style.display = 'block';
  document.getElementById('hudCenter').style.display = 'block';
  document.getElementById('hudBottom').style.display = 'block';
  canvas.style.cursor = 'none';
  backBtn.style.display = 'none';
}

// ----------------------------- Passcode Logic -----------------------------
function checkPasscode(input){
  // nexus7 -> world2
  const nexus = String.fromCharCode(110,101,120,117,115,55); // 'nexus7'
  if(input === nexus){
    progress.world2 = true;
    saveProgress();
    updateMenuLocks();
    alert('ACCESS GRANTED ‚Äî World 2 Unlocked');
    return;
  }
  // Toasty via atob('VG9hc3R5')
  try{
    const toast = atob('VG9hc3R5'); // resolves to 'Toasty'
    if(input === toast){
      progress.yourChoice = true;
      saveProgress();
      updateMenuLocks();
      alert('ACCESS GRANTED ‚Äî Your Choice Unlocked');
      return;
    }
  }catch(e){}
  alert('ACCESS DENIED');
}

// ----------------------------- Player Death -----------------------------
function onPlayerDeath(){
  state = 'gameover';
  // clear projectiles to avoid infinite death loops
  clearProjectiles();
  // drop diggers? keep
}

// ----------------------------- Initialization -----------------------------
player = createPlayer();
buildYourChoiceGrid();

// start main loop
function loop(t){
  const time = t;
  dt = (time - lastTime) / 1000;
  lastTime = time;
  dt = Math.min(dt, MAX_DT);
  if(state==='playing') update(dt);
  render();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// ----------------------------- Extra: Ensure uniqueness & logs -----------------------------
(function validateUniqueness(){
  // log unique type counts for debug assurance
  console.log('World1 stages:', WORLD1_STAGES.length, 'World2 stages:', WORLD2_STAGES.length);
  const types = {};
  WORLD1_STAGES.forEach((s,i)=>{ types[s.pattern.type] = (types[s.pattern.type]||0)+1; });
  console.log('World1 pattern type distribution:', types);
})();

</script>
</body>
</html>
