<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alternate's Magical Evolution</title>
    <style>
        body { margin: 0; background-color: #111; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; font-family: 'Arial', sans-serif; }
        #gameCanvas { 
            border: 1px solid #333; 
            background-color: #000000; /* Plain Black Arena */
            display: block;
        }
        #ui { 
            position: absolute; 
            top: 10px; 
            left: 10px; 
            color: #FFFFFF; 
            font-size: 14px; 
            background: rgba(0, 0, 0, 0.7); 
            padding: 10px; 
            border-radius: 5px; 
            user-select: none;
            width: 250px;
        }
       .bar { height: 10px; border: 1px solid #FFF; margin-top: 2px; }
       .hp-fill { background-color: #FF4444; transition: width 0.1s; }
       .mana-fill { background-color: #4444FF; transition: width 0.1s; }
       .stat-line { margin-bottom: 4px; }
       .ability-list { margin-top: 10px; max-height: 200px; overflow-y: auto; }
       .ability-item { margin: 2px 0; padding: 2px; border-radius: 3px; }
       .ability-selected { background-color: rgba(0, 255, 0, 0.2); }
       .ability-locked { color: #888; font-style: italic; }
       .ability-cooldown { background-color: rgba(255, 0, 0, 0.2); }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="ui">
        <h2>Alternate's Magical Evolution</h2>
        <div class="stat-line">LEVEL: <span id="level">1</span> | WAVE: <span id="wave">1</span> | XP: <span id="xp">0</span></div>
        <div class="stat-line">PL: <span id="mpl">1</span> (Cap 16)</div>
        <div class="stat-line">ATK: <span id="atk">20</span> | DEF: <span id="def">10</span></div>
        
        <p>HP: <span id="hpValue">100</span>/<span id="maxHp">100</span></p>
        <div class="bar"><div id="hpBar" class="hp-fill"></div></div>
        
        <p>MANA: <span id="manaValue">100</span>/<span id="maxMana">100</span></p>
        <div class="bar"><div id="manaBar" class="mana-fill"></div></div>

        <h3>Abilities (Cycle: , key)</h3>
        <div id="abilityList" class="ability-list"></div>
        
        <h3>Controls</h3>
        <p>Move: WASD/Arrows</p>
        <p>Aim: Mouse Pointer</p>
        <p>Fire/Charge: Left Click (Hold for Charge)</p>
        <p>Shield: Hold SPACE (Drain Mana)</p>
        <p>Cycle: , key</p>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        let gameRunning = true;
        let keys = {};
        let mouse = { x: WIDTH / 2, y: HEIGHT / 2, down: false };
        let projectiles =;
        let enemies =;
        let particles =;
        let lastTime = performance.now();
        let frameCount = 0;
        let shakeTime = 0; // For screen shake effect

        // --- Game Constants & Scaling ---
        const PL_MAX = 16;
        const BASE_DMG_BONUS = 2; // Damage boost per PL level

        // --- Player Stats & State (Alternate) ---
        const Player = {
            x: WIDTH / 2,
            y: HEIGHT / 2,
            size: 15,
            hp: 100, maxHp: 100,
            mana: 100, maxMana: 100,
            speed: 3,
            mpl: 1, mplCap: PL_MAX,
            atk: 20, def: 10,
            level: 1, xp: 0, xpNeeded: 500,
            color: '#0077FF', // Blue
            hatColor: '#8A2BE2', // Purple
            invulnerableTimer: 0,
            shieldActive: false,
            shieldStrength: 100, maxShieldStrength: 100,
            shieldAbsorbYield: 1.0, // Mana cost = Damage absorbed * yield
            isCharging: false,
            chargeLevel: 0,
            
            // Progression
            upgrades: new Set(),
            unlockedAbilities:,
            selectedAbilityIndex: 0,

            // Regeneration rates
            regen: {
                hp: 5 / 60, // 5 per second off-combat
                mana: 20 / 60, // 20 per second
                shield: 50 / 60, // 50 per second off-hold
            },
            currentCooldowns: {},
        };

        // --- Ability Definitions ---
        const Abilities = {
            // ID:
            MagicShot:      { cost: 5, cd: 0.2, pl: 1, color: '#FF7700', type: 'Projectile', dmgM: 1.0, homing: 0 },
            TriShot:        { cost: 15, cd: 1.5, pl: 4, color: '#44AAFF', type: 'Projectile', dmgM: 0.8, homing: 0 },
            BeamShot:       { cost: 30, cd: 3.0, pl: 8, color: '#FFFFFF', type: 'Beam', dmgM: 1.5, piercing: true, stun: 1.0 },
            IceShard:       { cost: 20, cd: 2.0, pl: 4, color: '#44FFFF', type: 'Projectile', dmgM: 1.2, slow: 0.5, slowDur: 2.0 },
            Lightning:      { cost: 35, cd: 4.0, pl: 4, color: '#FFFF44', type: 'Chain', dmgM: 1.0, chains: 3, dot: 5, dotDur: 3 },
            CurveShot:      { cost: 25, cd: 2.5, pl: 6, color: '#77FF77', type: 'Projectile', dmgM: 1.3, homing: 0.03 },
            ShieldBreaker:  { cost: 40, cd: 5.0, pl: 8, color: '#AA00FF', type: 'AoE', dmgM: 0.5, breaker: 50 },
            HomingMissile:  { cost: 30, cd: 3.5, pl: 6, color: '#FF0000', type: 'Projectile', dmgM: 2.0, splash: 20, homing: 0.05 },
            ForceWave:      { cost: 20, cd: 1.0, pl: 10, color: '#00AAFF', type: 'Cone', dmgM: 0.5, knockback: 20, stagger: 0.5 },
            PentaShot:      { cost: 45, cd: 3.0, pl: 12, color: '#44FF88', type: 'Projectile', dmgM: 0.7 },
            RecursiveShot:  { cost: 50, cd: 6.0, pl: 12, color: '#FF00FF', type: 'Projectile', dmgM: 1.0, bounces: 3 },
            ShieldAttack:   { cost: 35, cd: 4.0, pl: 10, color: '#00FF00', type: 'Projectile', dmgM: 1.5, ignoreShield: true },
            BetaLaser:      { cost: 70, cd: 15.0, pl: 14, color: '#FF0000', type: 'Beam', dmgM: 3.0, piercing: true, dot: 10, dotDur: 3 },
            SuperSpeed:     { cost: 50, cd: 10.0, pl: 12, color: '#FFD700', type: 'Buff', duration: 5.0, speedM: 2.0 },
        };

        // Initialize Cooldowns
        Object.keys(Abilities).forEach(key => {
            Player.currentCooldowns[key] = 0;
        });

        // --- Core Mechanics ---

        function applyPLScaling(baseValue) {
            // Apply PL scaling: Base * (1 + PL/16)
            return baseValue * (1 + Player.mpl / PL_MAX);
        }

        function calculateDamage(attacker, target, baseDmg) {
            // Dmg = (ATK + PL bonus) - (DEF + PL resist), min 1
            // PL bonus/resist: PL * (Base Dmg Bonus)
            const attackerPLBonus = attacker.mpl * BASE_DMG_BONUS;
            const targetPLResist = target.mpl * BASE_DMG_BONUS;

            const finalDmg = Math.max(1, (baseDmg * attacker.atk + attackerPLBonus) - (target.def + targetPLResist));
            
            return finalDmg;
        }

        // --- Drawing Utilities ---
        
        function drawStickFigure(entity, color, hatColor, angle = 0, sizeScale = 1) {
            ctx.save();
            ctx.translate(entity.x, entity.y);
            ctx.rotate(angle);
            
            const size = entity.size * sizeScale;
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            
            // Barrel Arm (Aiming)
            const barrelLength = size * 1.5;
            ctx.beginPath();
            ctx.moveTo(0, 0); 
            ctx.lineTo(barrelLength, 0); 
            ctx.stroke();

            // Body (Square)
            ctx.fillStyle = color;
            ctx.fillRect(-size / 2, -size / 2, size, size);

            // Hat (Square on top)
            if (hatColor) {
                ctx.fillStyle = hatColor;
                ctx.fillRect(-size / 2, -size * 1.5, size, size);
            }
            
            // Idle bob/movement tilt (simplified to just angle rotation above)
            
            ctx.restore();
        }
        
        function screenShake() {
            if (shakeTime > 0) {
                const intensity = Math.min(10, shakeTime * 10);
                const dx = (Math.random() - 0.5) * intensity;
                const dy = (Math.random() - 0.5) * intensity;
                ctx.translate(dx, dy);
                shakeTime -= 1/60;
            }
        }

        // --- Entity Classes ---

        class Particle {
            constructor(x, y, color, speed, friction = 0.98, life = 60) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.life = life;
                this.radius = Math.random() * 2 + 1;
                this.dx = (Math.random() - 0.5) * speed;
                this.dy = (Math.random() - 0.5) * speed;
                this.friction = friction;
            }

            update() {
                this.x += this.dx;
                this.y += this.dy;
                this.dx *= this.friction;
                this.dy *= this.friction;
                this.life--;
                return this.life > 0;
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class Projectile {
            constructor(caster, targetX, targetY, abilityID) {
                const ability = Abilities;
                this.id = abilityID;
                this.source = (caster === Player)? 'player' : 'enemy';
                this.x = caster.x;
                this.y = caster.y;
                this.size = 5;
                this.color = ability.color;
                this.mpl = caster.mpl;
                this.casterATK = caster.atk;
                this.dmgM = ability.dmgM |

| 1.0;
                this.speed = 10;
                this.piercing = ability.piercing |

| false;
                this.homing = ability.homing |

| 0;
                this.bounces = ability.bounces |

| 0;
                this.ignoreShield = ability.ignoreShield |

| false;
                this.reflected = false;

                const angle = Math.atan2(targetY - caster.y, targetX - caster.x);
                this.dx = Math.cos(angle) * this.speed;
                this.dy = Math.sin(angle) * this.speed;
            }

            update() {
                if (this.homing > 0 && this.source === 'player') {
                    // Curved Shot Logic: Home towards nearest enemy
                    const nearestEnemy = enemies.find(e => e.isAlive);
                    if (nearestEnemy) {
                        const targetAngle = Math.atan2(nearestEnemy.y - this.y, nearestEnemy.x - this.x);
                        let currentAngle = Math.atan2(this.dy, this.dx);
                        
                        let angleDiff = targetAngle - currentAngle;
                        if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                        if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                        
                        const turn = Math.min(Math.abs(angleDiff), this.homing) * Math.sign(angleDiff);
                        currentAngle += turn;

                        this.dx = Math.cos(currentAngle) * this.speed;
                        this.dy = Math.sin(currentAngle) * this.speed;
                    }
                }
                
                this.x += this.dx;
                this.y += this.dy;

                // Collision with boundaries for Recursive Shot
                if (this.bounces > 0) {
                    let bounced = false;
                    if (this.x < 0 |

| this.x > WIDTH) {
                        this.dx *= -1;
                        bounced = true;
                    }
                    if (this.y < 0 |

| this.y > HEIGHT) {
                        this.dy *= -1;
                        bounced = true;
                    }
                    if (bounced) this.bounces--;
                }

                // Boundary check removal for non-bouncing projectiles
                if (this.bounces === 0 && (this.x < -50 |

| this.x > WIDTH + 50 |
| this.y < -50 |
| this.y > HEIGHT + 50)) {
                    return false;
                }
                return true;
            }

            draw() {
                // Glow/Trail effect
                ctx.shadowBlur = 15;
                ctx.shadowColor = this.color;
                
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();

                ctx.shadowBlur = 0; // Reset shadow for other objects
            }
        }

        class Enemy {
            constructor(waveNum, type = 'Minion') {
                this.type = type;
                this.size = 10;
                this.mpl = Math.min(PL_MAX, Math.floor(waveNum / 2) + 1); // PL=level/2
                
                // Exponential Stat Scaling (based on MPL)
                const scaleFactor = 1 + this.mpl / PL_MAX;
                this.atk = Math.floor(10 + waveNum * 5 * scaleFactor);
                this.def = Math.floor(5 + waveNum * 2 * scaleFactor);
                this.maxHp = Math.floor(50 + waveNum * 20 * scaleFactor * (this.mpl >= 8? 1.5 : 1)); 
                
                this.hp = this.maxHp;
                this.speed = 1 + this.mpl * 0.1;
                this.color = '#FF0000'; // Default Red
                this.isAlive = true;
                this.attackTimer = 0;
                this.attackCooldown = Math.max(1.0, 3.0 / scaleFactor);
                this.angle = 0;
                this.mplLock = this.mpl; // PL locked to generation level
                
                // Random spawn location near edges
                if (Math.random() < 0.5) {
                    this.x = Math.random() * WIDTH;
                    this.y = Math.random() < 0.5? 0 : HEIGHT;
                } else {
                    this.x = Math.random() < 0.5? 0 : WIDTH;
                    this.y = Math.random() * HEIGHT;
                }
            }

            update(dt) {
                if (!this.isAlive) return;

                // AI Movement: Chase Player
                const angleToPlayer = Math.atan2(Player.y - this.y, Player.x - this.x);
                this.angle = angleToPlayer; // Aim barrel arm
                
                // Simple chase/ranged behavior
                const distance = Math.hypot(Player.x - this.x, Player.y - this.y);
                if (distance > 100) {
                    this.x += Math.cos(angleToPlayer) * this.speed * dt * 60;
                    this.y += Math.sin(angleToPlayer) * this.speed * dt * 60;
                }

                // AI Attack Logic: PL-based ability usage
                this.attackTimer += dt;
                if (this.attackTimer >= this.attackCooldown) {
                    this.attackTimer = 0;
                    this.castAbility();
                }
            }
            
            castAbility() {
                // Simple enemy attack logic: Higher PL enables better attacks
                let abilityID = 'MagicShot'; // Default
                let targetX = Player.x;
                let targetY = Player.y;

                if (this.mplLock >= 8 && Math.random() < 0.4) {
                    abilityID = 'BeamShot';
                } else if (this.mplLock >= 4 && Math.random() < 0.6) {
                    abilityID = 'TriShot';
                }
                
                const ability = Abilities;
                // Note: Enemy projectiles use the Enemy's ATK/DMG_M for calculation
                projectiles.push(new Projectile(this, targetX, targetY, abilityID)); 
            }

            takeDamage(rawDamage) {
                const finalDamage = calculateDamage(Player, this, rawDamage);
                this.hp -= finalDamage;
                if (this.hp <= 0) {
                    this.isAlive = false;
                    Player.xp += 100 + this.mplLock * 50; // XP from kill
                    shakeTime = 0.5; // Trigger shake on enemy death
                }
            }

            draw() {
                if (!this.isAlive) return;
                
                // Draw figure
                drawStickFigure(this, this.color, null, this.angle);

                // Draw HP bar
                const hpRatio = Math.max(0, this.hp / this.maxHp);
                ctx.fillStyle = '#330000';
                ctx.fillRect(this.x - this.size, this.y - this.size * 2.5, this.size * 2, 5);
                ctx.fillStyle = '#FF0000';
                ctx.fillRect(this.x - this.size, this.y - this.size * 2.5, this.size * 2 * hpRatio, 5);
            }
        }
        
        // --- Ability Handling ---

        function castAbility(abilityID) {
            const ability = Abilities;
            if (!Player.unlockedAbilities.includes(abilityID) |

| Player.mana < ability.cost |
| Player.currentCooldowns > 0) {
                return false;
            }
            
            Player.mana -= ability.cost;
            Player.currentCooldowns = applyPLScaling(ability.cd);

            const targetX = mouse.x;
            const targetY = mouse.y;
            const angle = Math.atan2(targetY - Player.y, targetX - Player.x);

            // PL Scaling for Multipliers
            const finalDmgM = ability.dmgM * (1 + Player.mpl / PL_MAX);
            
            switch (abilityID) {
                case 'MagicShot':
                case 'CurveShot':
                case 'HomingMissile':
                case 'RecursiveShot':
                case 'ShieldAttack':
                    projectiles.push(new Projectile(Player, targetX, targetY, abilityID));
                    break;
                case 'TriShot':
                    for (let i = -1; i <= 1; i++) {
                        const offsetAngle = angle + i * (Math.PI / 10);
                        const tx = Player.x + Math.cos(offsetAngle) * 500;
                        const ty = Player.y + Math.sin(offsetAngle) * 500;
                        projectiles.push(new Projectile(Player, tx, ty, abilityID));
                    }
                    break;
                case 'BeamShot':
                case 'BetaLaser':
                    // Beam: Instant damage/hit detection along the line to targetX/Y
                    // Implemented as an instant, very fast projectile for simplicity in the current framework
                    const beamProj = new Projectile(Player, targetX, targetY, abilityID);
                    beamProj.speed = 1000; 
                    projectiles.push(beamProj);
                    break;
                case 'Lightning':
                    // Lightning: Find target, chain to 3+ nearby enemies
                    // Implemented by instantly creating projectiles targeting multiple enemies
                    let targets = enemies.filter(e => e.isAlive).sort((a, b) => Math.hypot(Player.x - a.x, Player.y - a.y) - Math.hypot(Player.x - b.x, Player.y - b.y));
                    targets = targets.slice(0, Math.min(targets.length, ability.chains |

| 3));
                    targets.forEach(target => {
                        const lightningProj = new Projectile(Player, target.x, target.y, abilityID);
                        lightningProj.speed = 20; 
                        projectiles.push(lightningProj);
                    });
                    break;
                case 'ShieldBreaker':
                    // AoE pulse at cursor
                    particles.push(new Particle(targetX, targetY, ability.color, 5, 0.9, 30));
                    enemies.forEach(e => {
                        if (Math.hypot(targetX - e.x, targetY - e.y) < 50 + Player.mpl * 5) {
                             e.takeDamage(finalDmgM); // Low base damage
                             // Ignore shield breaking logic for now (requires shield implementation on enemies)
                        }
                    });
                    break;
                case 'SuperSpeed':
                    Player.speed *= ability.speedM;
                    setTimeout(() => Player.speed /= ability.speedM, ability.duration * 1000);
                    break;
            }
            return true;
        }

        function handleChargeMechanic(dt) {
            if (mouse.down &&!Player.isCharging) {
                Player.isCharging = true;
                Player.chargeLevel = 0;
            } else if (Player.isCharging) {
                // Charge up logic
                const manaCost = 10 * dt;
                if (Player.mana >= manaCost) {
                    Player.mana -= manaCost;
                    Player.chargeLevel = Math.min(3, Player.chargeLevel + dt * 0.5); // Max 3x charge
                }
            }
        }

        function releaseChargeOrFire() {
            if (Player.isCharging) {
                // Release charged Mana Ball
                const chargeDMG = Player.chargeLevel * 1.5; // Extra damage multiplier
                const chargedProj = new Projectile(Player, mouse.x, mouse.y, 'MagicShot');
                chargedProj.dmgM += chargeDMG;
                chargedProj.size = 5 + Player.chargeLevel * 5;
                projectiles.push(chargedProj);
                
                // If SPACE was held while charging (>50% charge), shoot Shield Projectile
                if (keys[' '] && Player.chargeLevel > 1.5) {
                    const shieldProj = new Projectile(Player, mouse.x, mouse.y, 'ShieldAttack');
                    shieldProj.dmgM *= 0.8; // 20% weaker
                    projectiles.push(shieldProj);
                }

                Player.isCharging = false;
                Player.chargeLevel = 0;
            } else {
                // Fire selected ability
                const selectedAbilityID = Player.unlockedAbilities[Player.selectedAbilityIndex];
                if (selectedAbilityID) {
                    castAbility(selectedAbilityID);
                }
            }
        }

        // --- Collision Logic ---
        
        function checkCollisions() {
            // Player Shield management
            const shieldRadius = 40 + Player.mpl * 2.5; // 40px + 20 omni + PL factor

            // Projectile-Enemy collision & Projectile-Player collision
            projectiles = projectiles.filter(p => {
                let hitTarget = false;
                
                if (p.source === 'player') {
                    // Check collision with enemies
                    for (let i = 0; i < enemies.length; i++) {
                        const e = enemies[i];
                        if (e.isAlive) {
                            const dist = Math.hypot(p.x - e.x, p.y - e.y);
                            if (dist < p.size + e.size) {
                                e.takeDamage(p.dmgM);
                                hitTarget = true;
                                if (!p.piercing) return false; // Destroy non-piercing projectile
                            }
                        }
                    }
                } else if (p.source === 'enemy') {
                    // Check collision with Player
                    const dist = Math.hypot(p.x - Player.x, p.y - Player.y);
                    if (dist < p.size + Player.size) {
                        
                        // 1. Plot Shield Invulnerability (Prevents all except True Damage/Lightning)
                        if (Player.invulnerableTimer > 0 && p.id!== 'Lightning' && p.id!== 'BetaLaser') {
                            p.reflected = true; // Still reflects even if invulnerable
                            
                        } 
                        
                        // 2. Shield Reflection (Active hold SPACE)
                        if (Player.shieldActive && dist < shieldRadius &&!p.ignoreShield) {
                            // Reflection Logic: reflect random/opposite direction
                            p.source = 'player';
                            p.color = '#FFFF00'; 
                            p.reflected = true;
                            
                            // Degradation by 50% + PL factor
                            const degradation = (p.dmgM * 0.5) + (p.mpl / PL_MAX) * 50;
                            Player.shieldStrength = Math.max(0, Player.shieldStrength - degradation);

                            // Mana drain (mana cost = absorbed * yield)
                            const damageAbsorbed = calculateDamage(p, Player, p.dmgM);
                            const manaCost = damageAbsorbed * Player.shieldAbsorbYield;
                            Player.mana = Math.max(0, Player.mana - manaCost);

                            // Randomize reflection angle
                            const angle = Math.atan2(p.dy, p.dx) + Math.PI + (Math.random() - 0.5) * 0.5;
                            p.dx = Math.cos(angle) * p.speed;
                            p.dy = Math.sin(angle) * p.speed;
                            
                            return true; // Keep reflected projectile
                        }

                        // 3. Hit Player
                        if (!p.reflected) { // Only hit if not reflected/invuln (invuln prevents damage but allows reflection)
                            const rawDamage = p.dmgM;
                            // Since enemy ATK is baked into the projectile via dmgM, use p.mpl for damage calculation
                            const tempEnemy = { atk: p.casterATK, mpl: p.mpl, def: Player.def };
                            const finalDamage = calculateDamage(tempEnemy, Player, rawDamage);
                            
                            if (Player.isCharging) {
                                // Charge Absorption/Overpower
                                const overpowerChance = Math.random();
                                if (overpowerChance < 0.75) {
                                    // 75% Overpower: explode, hurt player 50%
                                    Player.hp -= finalDamage * 0.5;
                                } else {
                                    // Absorb: Add to charge level (simplified)
                                    Player.chargeLevel = Math.min(3, Player.chargeLevel + 0.5);
                                }
                            } else if (Player.invulnerableTimer <= 0) {
                                Player.hp -= finalDamage;
                            }
                            shakeTime = 0.2;
                            hitTarget = true;
                        }
                        return false; // Destroy enemy projectile on player hit
                    }
                }
                return p.update(); // Keep projectile if it hasn't hit
            });
            
            // Check Projectile-Projectile Overpower (Simplified check)
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p1 = projectiles[i];
                if (p1.reflected |

| p1.source!== 'player') continue; 
                
                for (let j = 0; j < projectiles.length; j++) {
                    const p2 = projectiles[j];
                    if (p2.reflected |

| p2.source!== 'enemy' |
| i === j) continue;
                    
                    const dist = Math.hypot(p1.x - p2.x, p1.y - p2.y);
                    if (dist < p1.size + p2.size) {
                        // Projectile collision
                        if (p1.id === 'BeamShot' |

| p1.id === 'BetaLaser') {
                            // High PL Beam overpowers Mana Ball
                            projectiles.splice(projectiles.indexOf(p2), 1); // Destroy p2
                        } else if (p1.mpl > p2.mpl) {
                            // Higher PL attack pierces/ignores lower
                            projectiles.splice(projectiles.indexOf(p2), 1); // Destroy p2 (p1 survives)
                        } else if (p2.mpl > p1.mpl) {
                            projectiles.splice(i, 1); // Destroy p1 (p2 survives)
                            break;
                        } else {
                            // Equal PL: mutual destruction/spark
                            projectiles.splice(i, 1);
                            projectiles.splice(projectiles.indexOf(p2), 1);
                            break;
                        }
                    }
                }
            }

            // Player death check
            if (Player.hp <= 0) {
                gameRunning = false;
                saveGame(false);
                alert(`Game Over! Alternate succumbed to the evolutionary pressure on Wave ${wave}. MPL achieved: ${Player.mpl.toFixed(1)}`);
            }
        }
        
        // --- Wave Management and Progression ---

        let wave = 1;
        
        function spawnWave() {
            const baseEnemies = 3;
            const extraEnemies = Math.min(3, Math.floor(wave / 3)); // +1 every 3 levels, max 6 total extra
            const totalEnemies = baseEnemies + extraEnemies;
            enemies =;

            // Boss every 5 levels
            if (wave % 5 === 0) {
                enemies.push(new Enemy(wave, 'Boss'));
            }

            for (let i = 0; i < totalEnemies; i++) {
                enemies.push(new Enemy(wave, 'Minion'));
            }
        }

        function handleLevelUp() {
            Player.level++;
            Player.xp = 0;
            Player.xpNeeded = Math.floor(Player.xpNeeded * 1.5);

            // Simple Stat/PL boost on level up (Upgrades needed for variety)
            
            if (Player.level % 5 === 0) {
                 Player.maxHp += 50;
                 Player.maxMana += 50;
            }

            // Rare PL increase (every 3-5 levels, depending on system)
            if (Player.level % 4 === 0 && Player.mpl < PL_MAX) {
                Player.mpl = Math.min(PL_MAX, Player.mpl + 0.5);
            }
            
            // Unlock a random ability if available (70% pool early)
            const availableAbilities = Object.keys(Abilities).filter(id => 
               !Player.unlockedAbilities.includes(id) && Abilities[id].pl <= Player.mpl
            );
            
            if (availableAbilities.length > 0) {
                const newAbility = availableAbilities[Math.floor(Math.random() * availableAbilities.length)];
                Player.unlockedAbilities.push(newAbility);
                console.log(`Ability Unlocked: ${newAbility}`);
            }
        }

        // --- Save/Load System (localStorage) ---
        function saveGame(isAutoSave = true) {
            const gameState = {
                player: {
                    hp: Player.hp, maxHp: Player.maxHp,
                    mana: Player.mana, maxMana: Player.maxMana,
                    mpl: Player.mpl, atk: Player.atk, def: Player.def,
                    level: Player.level, xp: Player.xp, xpNeeded: Player.xpNeeded,
                    unlockedAbilities: Player.unlockedAbilities
                },
                wave: wave
            };
            localStorage.setItem('alternateEvolutionSave', JSON.stringify(gameState));
            if (isAutoSave) console.log("Game auto-saved.");
        }

        function loadGame() {
            const savedState = localStorage.getItem('alternateEvolutionSave');
            if (savedState) {
                const state = JSON.parse(savedState);
                Object.assign(Player, state.player);
                wave = state.wave;
                console.log(`Game loaded at Wave ${wave}.`);
                return true;
            }
            return false;
        }

        // --- Game Loop and Rendering ---

        function updateGame(dt) {
            if (!gameRunning) return;

            // Handle Input/Movement
            let dx = 0, dy = 0;
            if (keys['w'] |

| keys['ArrowUp']) dy -= 1;
            if (keys['s'] |

| keys) dy += 1;
            if (keys['a'] |

| keys['ArrowLeft']) dx -= 1;
            if (keys['d'] |

| keys) dx += 1;

            if (dx!== 0 |

| dy!== 0) {
                const length = Math.sqrt(dx * dx + dy * dy);
                Player.x += (dx / length) * Player.speed * dt * 60;
                Player.y += (dy / length) * Player.speed * dt * 60;
            }
            // Boundary checks
            Player.x = Math.max(Player.size, Math.min(WIDTH - Player.size, Player.x));
            Player.y = Math.max(Player.size * 2, Math.min(HEIGHT - Player.size, Player.y)); 
            
            // Resources and Cooldowns
            Player.mpl = Math.min(PL_MAX, Player.mpl);
            Player.hp = Math.min(Player.maxHp, Player.hp + (enemies.length === 0? Player.regen.hp : 0));
            Player.mana = Math.min(Player.maxMana, Player.mana + Player.regen.mana);
            
            // Shield status
            Player.shieldActive = keys[' '];
            if (Player.shieldActive) {
                // If shield is held, it does not regenerate and can be degraded
            } else {
                 Player.shieldStrength = Math.min(Player.maxShieldStrength, Player.shieldStrength + Player.regen.shield);
            }
            
            Object.keys(Player.currentCooldowns).forEach(key => {
                Player.currentCooldowns[key] = Math.max(0, Player.currentCooldowns[key] - dt);
            });
            Player.invulnerableTimer = Math.max(0, Player.invulnerableTimer - dt);

            // Charging mechanic update
            handleChargeMechanic(dt);

            // Entity Updates
            enemies.forEach(e => e.update(dt));
            enemies = enemies.filter(e => e.isAlive);
            
            particles = particles.filter(p => p.update());

            // Check collisions
            checkCollisions();

            // Wave/Level Logic
            if (enemies.length === 0) {
                wave++;
                spawnWave();
                handleLevelUp();
                saveGame();
            }
        }

        function drawGame() {
            // Clear canvas
            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
            
            ctx.save();
            screenShake(); // Apply screen shake translation

            // Draw entities
            projectiles.forEach(p => p.draw());
            enemies.forEach(e => e.draw());
            
            // Draw Player (Alternate)
            const angleToCursor = Math.atan2(mouse.y - Player.y, mouse.x - Player.x);
            drawStickFigure(Player, Player.color, Player.hatColor, angleToCursor);

            // Draw Player Shield
            if (Player.shieldActive |

| Player.invulnerableTimer > 0) {
                const shieldRadius = 40 + Player.mpl * 2.5;
                const shieldColor = Player.invulnerableTimer > 0? '#AAFFDD' : (Player.shieldStrength > 0? '#44FF44' : '#FF4444');
                ctx.strokeStyle = shieldColor;
                ctx.lineWidth = 4;
                ctx.globalAlpha = Player.shieldStrength / Player.maxShieldStrength * 0.5 + 0.3; // Opacity based on strength
                ctx.beginPath();
                ctx.arc(Player.x, Player.y, shieldRadius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.globalAlpha = 1.0;
            }

            // Draw Charge Aura
            if (Player.isCharging) {
                ctx.strokeStyle = '#FF7700';
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.5;
                ctx.beginPath();
                ctx.arc(Player.x, Player.y, 10 + Player.chargeLevel * 10, 0, Math.PI * 2);
                ctx.stroke();
                ctx.globalAlpha = 1.0;
            }
            
            // Particles
            particles.forEach(p => p.draw());

            ctx.restore(); // Undo screen shake translation
            
            // UI Update (Done outside save/restore)
            updateUI();
        }

        function updateUI() {
            document.getElementById('wave').textContent = wave;
            document.getElementById('level').textContent = Player.level;
            document.getElementById('xp').textContent = Player.xp;
            document.getElementById('mpl').textContent = Player.mpl.toFixed(1);
            document.getElementById('atk').textContent = Player.atk;
            document.getElementById('def').textContent = Player.def;
            
            document.getElementById('hpValue').textContent = Math.ceil(Player.hp);
            document.getElementById('maxHp').textContent = Player.maxHp;
            document.getElementById('hpBar').style.width = `${(Player.hp / Player.maxHp) * 100}%`;

            document.getElementById('manaValue').textContent = Math.ceil(Player.mana);
            document.getElementById('maxMana').textContent = Player.maxMana;
            document.getElementById('manaBar').style.width = `${(Player.mana / Player.maxMana) * 100}%`;

            const abilityList = document.getElementById('abilityList');
            abilityList.innerHTML = '';

            Object.keys(Abilities).forEach((id, index) => {
                const ability = Abilities[id];
                const isUnlocked = Player.unlockedAbilities.includes(id);
                const isSelected = index === Player.selectedAbilityIndex;
                const onCooldown = Player.currentCooldowns[id] > 0;
                
                const div = document.createElement('div');
                div.className = 'ability-item';
                
                let text = `[PL ${ability.pl}] ${id} (${ability.dmgM}x): `;

                if (isUnlocked) {
                    text += onCooldown? `CD: ${Player.currentCooldowns[id].toFixed(1)}s` : `Cost: ${ability.cost} Mana`;
                    if (isSelected) div.classList.add('ability-selected');
                    if (onCooldown) div.classList.add('ability-cooldown');
                } else {
                    text += `(Locked: PL ${ability.pl} Required)`;
                    div.classList.add('ability-locked');
                }
                
                div.textContent = text;
                abilityList.appendChild(div);
            });
        }
        
        // --- Event Listeners ---
        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            keys[key] = true;
            
            // Ability Cycling (',' key)
            if (key === ',' |

| key === '<') {
                Player.selectedAbilityIndex = (Player.selectedAbilityIndex - 1 + Player.unlockedAbilities.length) % Player.unlockedAbilities.length;
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
        });
        
        canvas.addEventListener('mousedown', () => {
            mouse.down = true;
        });
        
        canvas.addEventListener('mouseup', () => {
            if (mouse.down) {
                releaseChargeOrFire();
            }
            mouse.down = false;
        });

        // Disable right-click context menu inside canvas
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        // --- Initialization ---

        function gameLoop(currentTime) {
            if (!gameRunning) return;
            
            const dt = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            updateGame(dt);
            drawGame();
            
            requestAnimationFrame(gameLoop);
        }

        function initGame() {
            if (!loadGame()) {
                // If no save found, start first wave
                spawnWave();
            }
            gameLoop(performance.now());
        }

        initGame();
    </script>
</body>
</html>
