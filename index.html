<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alternate's Magical Evolution</title>
    <style>
        body { margin: 0; padding: 0; background: black; display: flex; justify-content: center; align-items: center; height: 100vh; font-family: Arial, sans-serif; }
        canvas { border: 1px solid #333; background: black; }
        #ui { position: absolute; top: 10px; left: 10px; color: white; font-size: 12px; }
        #spellList { position: absolute; top: 10px; right: 10px; color: white; font-size: 10px; max-height: 400px; overflow-y: auto; }
        #controls { position: absolute; bottom: 10px; left: 10px; color: white; font-size: 10px; }
        #menu { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; text-align: center; }
        button { padding: 10px 20px; margin: 10px; font-size: 16px; }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="ui"></div>
    <div id="spellList"></div>
    <div id="controls">WASD/Arrows: Move | Mouse: Aim/Fire | , : Cycle Spell | Space: Shield</div>
    <div id="menu">
        <h1>Alternate's Magical Evolution</h1>
        <button onclick="startGame()">Play</button>
        <button onclick="viewAttributes()">Attributes</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const ui = document.getElementById('ui');
        const spellList = document.getElementById('spellList');
        const menu = document.getElementById('menu');

        // Game state
        let gameState = 'menu'; // menu, playing, paused, gameOver
        let player = null;
        let enemies = [];
        let projectiles = [];
        let particles = [];
        let currentWave = 0;
        let enemiesInWave = 0;
        let level = 1;
        let xp = 0;
        let xpToNext = 100;
        let keys = {};
        let mouse = { x: 0, y: 0, down: false };
        let selectedSpell = 0;
        let lastTime = 0;
        let animationFrame = 0;

        // Save data
        let saveData = {
            pl: 1,
            atk: 20,
            def: 10,
            unlocks: [0], // 0: Magic Shot
            upgrades: {}
        };

        // Load save
        function loadSave() {
            const saved = localStorage.getItem('alternateSave');
            if (saved) {
                saveData = JSON.parse(saved);
            }
            player.pl = saveData.pl;
            player.atk = saveData.atk;
            player.def = saveData.def;
            player.unlocks = saveData.unlocks;
        }

        // Save game
        function saveGame() {
            saveData.pl = player.pl;
            saveData.atk = player.atk;
            saveData.def = player.def;
            saveData.unlocks = player.unlocks;
            localStorage.setItem('alternateSave', JSON.stringify(saveData));
        }

        // Spells data
        const spells = [
            { name: 'Magic Shot', cd: 500, mana: 5, dmg: 20, unlocked: true, func: magicShot, color: 'orange' },
            { name: 'Tri-Shot', cd: 800, mana: 10, dmg: 15, unlocked: false, func: triShot, color: 'blue' },
            { name: 'Beam Shot', cd: 1500, mana: 20, dmg: 40, unlocked: false, func: beamShot, color: 'white' },
            { name: 'Ice Shard', cd: 1000, mana: 15, dmg: 25, unlocked: false, func: iceShard, color: 'cyan' },
            { name: 'Lightning', cd: 1200, mana: 18, dmg: 30, unlocked: false, func: lightning, color: 'yellow' },
            { name: 'Curve Shot', cd: 700, mana: 8, dmg: 22, unlocked: false, func: curveShot, color: 'green' },
            { name: 'Shield Breaker', cd: 2000, mana: 25, dmg: 10, unlocked: false, func: shieldBreaker, color: 'purple' },
            { name: 'Homing Missile', cd: 1500, mana: 22, dmg: 35, unlocked: false, func: homingMissile, color: 'red' },
            { name: 'Force Wave', cd: 1800, mana: 30, dmg: 28, unlocked: false, func: forceWave, color: 'blue' },
            { name: 'Penta Shot', cd: 600, mana: 12, dmg: 12, unlocked: false, func: pentaShot, color: 'lightblue' },
            { name: 'Recursive Shot', cd: 2500, mana: 35, dmg: 45, unlocked: false, func: recursiveShot, color: 'pink' },
            { name: 'Shield Attack', cd: 2200, mana: 28, dmg: 40, unlocked: false, func: shieldAttack, color: 'gold' },
            { name: 'Beta Laser', cd: 3000, mana: 50, dmg: 60, unlocked: false, func: betaLaser, color: 'crimson' },
            { name: 'Super Speed', cd: 10000, mana: 40, dmg: 0, unlocked: false, func: superSpeed, color: 'silver' }
        ];

        // Player class
        class Player {
            constructor() {
                this.x = 400;
                this.y = 300;
                this.health = 100;
                this.maxHealth = 100;
                this.mana = 100;
                this.maxMana = 100;
                this.speed = 3;
                this.pl = 1;
                this.atk = 20;
                this.def = 10;
                this.unlocks = [0];
                this.shieldActive = false;
                this.shieldStrength = 50;
                this.shieldRadius = 40;
                this.shieldYield = 1.0;
                this.superSpeed = false;
                this.superSpeedTimer = 0;
                this.lastSpell = 0;
                this.anim = { idle: 0, move: 0 };
            }

            update(dt) {
                // Movement
                let dx = 0, dy = 0;
                if (keys['w'] || keys['ArrowUp']) dy -= 1;
                if (keys['s'] || keys['ArrowDown']) dy += 1;
                if (keys['a'] || keys['ArrowLeft']) dx -= 1;
                if (keys['d'] || keys['ArrowRight']) dx += 1;
                let len = Math.sqrt(dx*dx + dy*dy);
                if (len > 0) {
                    dx /= len; dy /= len;
                    this.x += dx * this.speed * (this.superSpeed ? 2 : 1) * dt;
                    this.y += dy * this.speed * (this.superSpeed ? 2 : 1) * dt;
                    this.anim.move += dt * 10;
                } else {
                    this.anim.idle += dt * 2;
                }
                // Bounds
                this.x = Math.max(20, Math.min(780, this.x));
                this.y = Math.max(20, Math.min(580, this.y));
                // Regen
                this.mana = Math.min(this.maxMana, this.mana + 20 * dt / 1000);
                if (!this.shieldActive) this.shieldStrength = Math.min(50, this.shieldStrength + 10 * dt / 1000);
                if (this.superSpeedTimer > 0) {
                    this.superSpeedTimer -= dt;
                    if (this.superSpeedTimer <= 0) this.superSpeed = false;
                }
                // Shield
                if (keys[' ']) {
                    if (this.mana >= 1 && this.shieldStrength > 0) {
                        this.shieldActive = true;
                    } else {
                        this.shieldActive = false;
                    }
                } else {
                    this.shieldActive = false;
                }
            }

            castSpell(index, targetX, targetY) {
                const spell = spells[index];
                if (this.mana >= spell.mana && Date.now() - this.lastSpell >= spell.cd && spell.unlocked) {
                    spell.func(this, targetX, targetY);
                    this.mana -= spell.mana;
                    this.lastSpell = Date.now();
                    return true;
                }
                return false;
            }

            takeDamage(dmg) {
                let netDmg = Math.max(1, dmg - this.def);
                netDmg *= (1 - this.pl * 0.05); // PL DEF ignore
                if (this.shieldActive && this.shieldStrength > 0) {
                    let absorbed = Math.min(netDmg, this.shieldStrength);
                    this.shieldStrength -= absorbed;
                    this.mana -= absorbed * this.shieldYield;
                    netDmg -= absorbed;
                    // Particles
                    for (let i = 0; i < 5; i++) {
                        particles.push(new Particle(this.x, this.y, 'green', Math.random()*Math.PI*2, Math.random()*3 + 1));
                    }
                }
                this.health -= netDmg;
                if (this.health <= 0) gameOver();
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                let angle = Math.atan2(mouse.y - this.y, mouse.x - this.x);
                ctx.rotate(angle);

                // Stick figure body
                ctx.strokeStyle = 'blue';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(0, -20); // head
                ctx.lineTo(0, 0); // torso
                ctx.moveTo(0, -10);
                ctx.lineTo(-10, 0); // arm1
                ctx.moveTo(0, -10);
                ctx.lineTo(10, 0); // arm2
                ctx.moveTo(0, 0);
                ctx.lineTo(-8, 20 + Math.sin(this.anim.move) * 5); // leg1
                ctx.moveTo(0, 0);
                ctx.lineTo(8, 20 - Math.sin(this.anim.move) * 5); // leg2
                ctx.stroke();

                // Hat
                ctx.fillStyle = 'purple';
                ctx.beginPath();
                ctx.arc(0, -25, 8, 0, Math.PI*2);
                ctx.fill();

                // Shield
                if (this.shieldActive) {
                    ctx.strokeStyle = 'cyan';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.shieldRadius, 0, Math.PI*2);
                    ctx.stroke();
                    // Pulse
                    let pulse = Math.sin(animationFrame * 0.1) * 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.shieldRadius + pulse, 0, Math.PI*2);
                    ctx.stroke();
                }

                // Super speed trail
                if (this.superSpeed) {
                    ctx.strokeStyle = 'silver';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, -10);
                    ctx.stroke();
                }

                ctx.restore();
            }
        }

        // Enemy class
        class Enemy {
            constructor(x, y, type, pl) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.pl = pl || Math.floor(level / 2);
                this.health = 50 + level * 20;
                this.maxHealth = this.health;
                this.speed = 1 + level * 0.2;
                this.atk = 10 + level * 5;
                this.def = 5 + level * 2;
                this.size = this.pl >= 12 ? 1.5 : 1;
                this.color = ['gray', 'red', 'blue', 'yellow', 'green'][type] || 'gray';
                this.shield = this.pl >= 4 ? 30 : 0;
                this.lastAttack = 0;
                this.anim = { move: 0 };
                this.dodgeChance = 0.02 * this.pl;
                this.aiComplexity = this.pl;
                this.target = player;
            }

            update(dt) {
                // AI
                let dx = player.x - this.x;
                let dy = player.y - this.y;
                let dist = Math.sqrt(dx*dx + dy*dy);
                if (dist > 30) {
                    // Chase
                    dx /= dist; dy /= dist;
                    this.x += dx * this.speed * dt;
                    this.y += dy * this.speed * dt;
                    this.anim.move += dt * 8;
                } else {
                    // Melee
                    player.takeDamage(this.atk * dt / 1000);
                }
                // Dodge
                if (Math.random() < this.dodgeChance * dt) {
                    let dodgeAngle = Math.random() * Math.PI * 2;
                    this.x += Math.cos(dodgeAngle) * 20;
                    this.y += Math.sin(dodgeAngle) * 20;
                }
                // Attack
                if (Date.now() - this.lastAttack > (3000 - this.pl * 100) && Math.random() < 0.01 * this.pl * dt) {
                    this.attack();
                    this.lastAttack = Date.now();
                }
            }

            attack() {
                // Simple shot for now, scale with PL
                let spellIndex = Math.min(Math.floor(this.pl / 2), spells.length - 1);
                spells[spellIndex].func(this, player.x, player.y, true); // enemy cast
            }

            takeDamage(dmg, ignoreShield = false) {
                if (!ignoreShield && this.shield > 0) {
                    this.shield -= dmg;
                    if (this.shield < 0) {
                        dmg = -this.shield;
                        this.shield = 0;
                    } else {
                        dmg = 0;
                    }
                }
                let netDmg = Math.max(1, dmg - this.def);
                this.health -= netDmg;
                if (this.health <= 0) {
                    // Death particles
                    for (let i = 0; i < 10; i++) {
                        particles.push(new Particle(this.x, this.y, this.color, Math.random()*Math.PI*2, Math.random()*5 + 2));
                    }
                    xp += 10 + this.pl * 5;
                    enemiesInWave--;
                    if (enemiesInWave <= 0) nextWave();
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(this.size, this.size);

                // Stick figure
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, -15, 5, 0, Math.PI*2); // head
                ctx.moveTo(0, -10);
                ctx.lineTo(0, 10); // body
                ctx.moveTo(0, 0);
                ctx.lineTo(-8, 20 + Math.sin(this.anim.move) * 3); // leg1
                ctx.moveTo(0, 0);
                ctx.lineTo(8, 20 - Math.sin(this.anim.move) * 3); // leg2
                ctx.moveTo(0, 0);
                ctx.lineTo(10 * Math.sin(animationFrame * 0.05), -10 + 10 * Math.cos(animationFrame * 0.05)); // arm cast
                ctx.stroke();

                // Crown for high PL
                if (this.pl >= 8) {
                    ctx.fillStyle = 'gold';
                    ctx.beginPath();
                    ctx.moveTo(-5, -20);
                    ctx.lineTo(0, -30);
                    ctx.lineTo(5, -20);
                    ctx.closePath();
                    ctx.fill();
                }

                // Shield
                if (this.shield > 0) {
                    ctx.strokeStyle = 'gray';
                    ctx.beginPath();
                    ctx.arc(0, 0, 30, 0, Math.PI*2);
                    ctx.stroke();
                }

                ctx.restore();
                // Health bar
                ctx.fillStyle = 'red';
                ctx.fillRect(this.x - 15, this.y - 30, 30, 3);
                ctx.fillStyle = 'green';
                ctx.fillRect(this.x - 15, this.y - 30, 30 * (this.health / this.maxHealth), 3);
            }
        }

        // Projectile class
        class Projectile {
            constructor(x, y, vx, vy, color, dmg, owner, homing = false, slow = 0) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.color = color;
                this.dmg = dmg;
                this.owner = owner;
                this.homing = homing;
                this.slow = slow;
                this.life = 3000;
                this.trail = [];
            }

            update(dt) {
                if (this.homing && player && Math.random() < 0.1) {
                    let dx = player.x - this.x;
                    let dy = player.y - this.y;
                    let dist = Math.sqrt(dx*dx + dy*dy);
                    this.vx += (dx / dist) * 0.5;
                    this.vy += (dy / dist) * 0.5;
                }
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.trail.push({x: this.x, y: this.y});
                if (this.trail.length > 10) this.trail.shift();
                this.life -= dt;
                if (this.life <= 0 || this.x < 0 || this.x > 800 || this.y < 0 || this.y > 600) {
                    return false;
                }
                // Collision with enemies/player
                if (this.owner === player) {
                    enemies.forEach((e, i) => {
                        let dist = Math.sqrt((this.x - e.x)**2 + (this.y - e.y)**2);
                        if (dist < 15) {
                            e.takeDamage(this.dmg * (1 + player.pl / 16));
                            return false;
                        }
                    });
                } else {
                    let dist = Math.sqrt((this.x - player.x)**2 + (this.y - player.y)**2);
                    if (dist < 15) {
                        player.takeDamage(this.dmg);
                        return false;
                    }
                }
                return true;
            }

            draw() {
                // Trail
                ctx.strokeStyle = this.color + '40';
                ctx.lineWidth = 2;
                ctx.beginPath();
                this.trail.forEach((p, i) => {
                    if (i === 0) ctx.moveTo(p.x, p.y);
                    else ctx.lineTo(p.x, p.y);
                });
                ctx.stroke();

                // Main
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 5, 0, Math.PI*2);
                ctx.fill();
            }
        }

        // Particle class
        class Particle {
            constructor(x, y, color, angle, speed) {
                this.x = x;
                this.y = y;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.color = color;
                this.life = 1000;
                this.decay = 0.98;
            }

            update(dt) {
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.vx *= this.decay;
                this.vy *= this.decay;
                this.life -= dt;
                return this.life > 0;
            }

            draw() {
                ctx.fillStyle = this.color + Math.floor(this.life / 10).toString(16).padStart(2, '0');
                ctx.beginPath();
                ctx.arc(this.x, this.y, 2, 0, Math.PI*2);
                ctx.fill();
            }
        }

        // Spell functions
        function magicShot(caster, tx, ty, isEnemy = false) {
            let angle = Math.atan2(ty - caster.y, tx - caster.x);
            let vx = Math.cos(angle) * 5;
            let vy = Math.sin(angle) * 5;
            projectiles.push(new Projectile(caster.x, caster.y, vx, vy, 'orange', caster.atk, caster, caster.pl > 8));
        }

        function triShot(caster, tx, ty, isEnemy = false) {
            let angle = Math.atan2(ty - caster.y, tx - caster.x);
            for (let i = -1; i <= 1; i++) {
                let a = angle + i * 0.3;
                let vx = Math.cos(a) * 4;
                let vy = Math.sin(a) * 4;
                projectiles.push(new Projectile(caster.x, caster.y, vx, vy, 'blue', caster.atk * 0.8, caster));
            }
        }

        function beamShot(caster, tx, ty, isEnemy = false) {
            let angle = Math.atan2(ty - caster.y, tx - caster.x);
            let dist = 400;
            let ex = caster.x + Math.cos(angle) * dist;
            let ey = caster.y + Math.sin(angle) * dist;
            // Draw beam
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(caster.x, caster.y);
            ctx.lineTo(ex, ey);
            ctx.stroke();
            // Damage along line
            enemies.forEach(e => {
                let proj = {x: caster.x, y: caster.y, vx: Math.cos(angle)*10, vy: Math.sin(angle)*10};
                let t = 0;
                while (t < dist) {
                    proj.x += proj.vx;
                    proj.y += proj.vy;
                    let d = Math.sqrt((proj.x - e.x)**2 + (proj.y - e.y)**2);
                    if (d < 15) {
                        e.takeDamage(caster.atk * 2, caster.pl >= 8); // stun via dmg
                        break;
                    }
                    t += 10;
                }
            });
            // Temp projectile for pierce
            projectiles.push(new Projectile(caster.x, caster.y, Math.cos(angle)*10, Math.sin(angle)*10, 'white', caster.atk * 2, caster, false, caster.pl >= 8 ? 0.5 : 0));
        }

        function iceShard(caster, tx, ty, isEnemy = false) {
            let angle = Math.atan2(ty - caster.y, tx - caster.x);
            let vx = Math.cos(angle) * 6;
            let vy = Math.sin(angle) * 6;
            projectiles.push(new Projectile(caster.x, caster.y, vx, vy, 'cyan', caster.atk, caster, false, 0.5));
        }

        function lightning(caster, tx, ty, isEnemy = false) {
            // Zigzag to target
            let dx = tx - caster.x;
            let dy = ty - caster.y;
            let steps = 10 + caster.pl * 2;
            let path = [];
            path.push({x: caster.x, y: caster.y});
            for (let i = 1; i <= steps; i++) {
                let px = caster.x + (dx / steps) * i + (Math.random() - 0.5) * 20;
                let py = caster.y + (dy / steps) * i + (Math.random() - 0.5) * 20;
                path.push({x: px, y: py});
            }
            // Draw
            ctx.strokeStyle = 'yellow';
            ctx.lineWidth = 3;
            ctx.beginPath();
            path.forEach((p, i) => {
                if (i === 0) ctx.moveTo(p.x, p.y);
                else ctx.lineTo(p.x, p.y);
            });
            ctx.stroke();
            // Damage nearest
            let closest = null;
            let minDist = Infinity;
            enemies.forEach(e => {
                let d = Math.sqrt((tx - e.x)**2 + (ty - e.y)**2);
                if (d < minDist && d < 50 + caster.pl * 5) {
                    minDist = d;
                    closest = e;
                }
            });
            if (closest) closest.takeDamage(caster.atk * 1.5);
            if (caster.pl >= 10) {
                // Chain
                let chained = [closest];
                for (let c = 0; c < 3; c++) {
                    let next = null;
                    let minD = Infinity;
                    enemies.forEach(e => {
                        if (chained.includes(e)) return;
                        let d = Math.sqrt((chained[c].x - e.x)**2 + (chained[c].y - e.y)**2);
                        if (d < minD && d < 60) {
                            minD = d;
                            next = e;
                        }
                    });
                    if (next) {
                        chained.push(next);
                        next.takeDamage(caster.atk);
                    } else break;
                }
            }
        }

        function curveShot(caster, tx, ty, isEnemy = false) {
            let angle = Math.atan2(ty - caster.y, tx - caster.x);
            let vx = Math.cos(angle) * 4;
            let vy = Math.sin(angle) * 4;
            projectiles.push(new Projectile(caster.x, caster.y, vx, vy, 'green', caster.atk, caster, true));
        }

        function shieldBreaker(caster, tx, ty, isEnemy = false) {
            let dx = tx - caster.x;
            let dy = ty - caster.y;
            let dist = Math.sqrt(dx*dx + dy*dy);
            let ex = caster.x + (dx / dist) * 100;
            let ey = caster.y + (dy / dist) * 100;
            // Pulse
            ctx.strokeStyle = 'purple';
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.arc(tx, ty, 50 + caster.pl * 5, 0, Math.PI*2);
            ctx.stroke();
            // Damage shields
            enemies.forEach(e => {
                let d = Math.sqrt((tx - e.x)**2 + (ty - e.y)**2);
                if (d < 50 + caster.pl * 5) {
                    e.shield = Math.max(0, e.shield - (50 + caster.pl * 10));
                    e.takeDamage(caster.atk * 0.5);
                }
            });
        }

        function homingMissile(caster, tx, ty, isEnemy = false) {
            let angle = Math.atan2(ty - caster.y, tx - caster.x);
            let vx = Math.cos(angle) * 3;
            let vy = Math.sin(angle) * 3;
            let proj = new Projectile(caster.x, caster.y, vx, vy, 'red', caster.atk * 1.5, caster, caster.pl >= 6);
            proj.explodeRadius = caster.pl >= 6 ? 40 : 0;
            projectiles.push(proj);
        }

        function forceWave(caster, tx, ty, isEnemy = false) {
            let angle = Math.atan2(ty - caster.y, tx - caster.x);
            // Cone
            ctx.strokeStyle = 'blue';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(caster.x, caster.y);
            let ex1 = caster.x + Math.cos(angle - 0.5) * 200;
            let ey1 = caster.y + Math.sin(angle - 0.5) * 200;
            let ex2 = caster.x + Math.cos(angle + 0.5) * 200;
            let ey2 = caster.y + Math.sin(angle + 0.5) * 200;
            ctx.lineTo(ex1, ey1);
            ctx.moveTo(caster.x, caster.y);
            ctx.lineTo(ex2, ey2);
            ctx.stroke();
            // Damage and knockback
            enemies.forEach(e => {
                let dx = e.x - caster.x;
                let dy = e.y - caster.y;
                let a = Math.atan2(dy, dx);
                let da = Math.abs(a - angle);
                if (da < 0.5 && Math.sqrt(dx*dx + dy*dy) < 200) {
                    e.takeDamage(caster.atk);
                    // Knockback
                    let kb = Math.cos(a) * 100;
                    let kby = Math.sin(a) * 100;
                    e.x += kb;
                    e.y += kby;
                }
            });
        }

        function pentaShot(caster, tx, ty, isEnemy = false) {
            let angle = Math.atan2(ty - caster.y, tx - caster.x);
            for (let i = -2; i <= 2; i++) {
                let a = angle + i * 0.4;
                let vx = Math.cos(a) * 5;
                let vy = Math.sin(a) * 5;
                projectiles.push(new Projectile(caster.x, caster.y, vx, vy, 'lightblue', caster.atk * 0.6, caster));
            }
        }

        function recursiveShot(caster, tx, ty, isEnemy = false) {
            let angle = Math.atan2(ty - caster.y, tx - caster.x);
            let vx = Math.cos(angle) * 4;
            let vy = Math.sin(angle) * 4;
            let proj = new Projectile(caster.x, caster.y, vx, vy, 'pink', caster.atk * 2, caster);
            proj.bounces = 3 + caster.pl;
            projectiles.push(proj);
        }

        function shieldAttack(caster, tx, ty, isEnemy = false) {
            // Shield proj
            let angle = Math.atan2(ty - caster.y, tx - caster.x);
            let vx = Math.cos(angle) * 5;
            let vy = Math.sin(angle) * 5;
            let proj = new Projectile(caster.x, caster.y, vx, vy, 'gold', caster.atk, caster);
            proj.ignoreShield = true;
            proj.reflect = true;
            projectiles.push(proj);
        }

        function betaLaser(caster, tx, ty, isEnemy = false) {
            let angle = Math.atan2(ty - caster.y, tx - caster.x);
            let dist = 500;
            let ex = caster.x + Math.cos(angle) * dist;
            let ey = caster.y + Math.sin(angle) * dist;
            // Thick beam
            let grad = ctx.createLinearGradient(caster.x, caster.y, ex, ey);
            grad.addColorStop(0, 'crimson');
            grad.addColorStop(1, 'darkred');
            ctx.strokeStyle = grad;
            ctx.lineWidth = 8;
            ctx.beginPath();
            ctx.moveTo(caster.x, caster.y);
            ctx.lineTo(ex, ey);
            ctx.stroke();
            // Damage
            enemies.forEach(e => {
                let projx = caster.x;
                let projy = caster.y;
                let t = 0;
                while (t < dist) {
                    projx += Math.cos(angle) * 10;
                    projy += Math.sin(angle) * 10;
                    let d = Math.sqrt((projx - e.x)**2 + (projy - e.y)**2);
                    if (d < 20) {
                        e.takeDamage(caster.atk * 3);
                        // DoT
                        if (caster.pl >= 12) e.health -= caster.atk * 0.1; // over time
                        break;
                    }
                    t += 10;
                }
            });
        }

        function superSpeed(caster, tx, ty, isEnemy = false) {
            caster.superSpeed = true;
            caster.superSpeedTimer = 5000;
            // Trail effect
            for (let i = 0; i < 20; i++) {
                setTimeout(() => {
                    particles.push(new Particle(caster.x, caster.y, 'silver', Math.random()*Math.PI*2, Math.random()*4 + 2));
                }, i * 50);
            }
            if (caster.pl >= 12) {
                // Invuln 1s
                setTimeout(() => caster.health = Math.min(caster.maxHealth, caster.health + 50), 1000);
            }
        }

        // Input handlers
        window.addEventListener('keydown', e => {
            keys[e.key.toLowerCase()] = true;
            if (e.key === ',') {
                selectedSpell = (selectedSpell + 1) % spells.length;
                while (!spells[selectedSpell].unlocked && spells.length > 1) {
                    selectedSpell = (selectedSpell + 1) % spells.length;
                }
            }
            if (e.key === ' ' && !keys[' ']) {
                // Shield toggle, but hold
            }
        });

        window.addEventListener('keyup', e => {
            keys[e.key.toLowerCase()] = false;
        });

        canvas.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
        });

        canvas.addEventListener('mousedown', e => {
            mouse.down = true;
            if (gameState === 'playing') {
                player.castSpell(selectedSpell, mouse.x, mouse.y);
            }
        });

        canvas.addEventListener('mouseup', e => {
            mouse.down = false;
        });

        // Game functions
        function startGame() {
            gameState = 'playing';
            menu.style.display = 'none';
            loadSave();
            player = new Player();
            player.unlocks = saveData.unlocks;
            nextWave();
            gameLoop();
        }

        function viewAttributes() {
            alert(`PL: ${saveData.pl}\nATK: ${saveData.atk}\nDEF: ${saveData.def}\nUnlocked Spells: ${saveData.unlocks.map(i => spells[i].name).join(', ')}`);
        }

        function gameOver() {
            gameState = 'gameOver';
            menu.innerHTML = '<h1>Game Over</h1><button onclick="location.reload()">Restart</button>';
            menu.style.display = 'block';
            saveGame();
        }

        function nextWave() {
            currentWave++;
            let numEnemies = Math.min(1 + Math.floor(currentWave / 3), 6);
            enemiesInWave = numEnemies;
            enemies = [];
            for (let i = 0; i < numEnemies; i++) {
                let x = Math.random() * 800;
                let y = Math.random() * 600;
                let type = Math.floor(Math.random() * 5);
                let pl = Math.floor(currentWave / 2);
                enemies.push(new Enemy(x, y, type, pl));
            }
            if (currentWave % 5 === 0) {
                // Boss
                let boss = new Enemy(400, 300, 0, level + 1);
                boss.health *= 3;
                boss.size = 1.5;
                boss.color = 'red';
                enemies.push(boss);
                enemiesInWave++;
            }
            // Level up check
            if (xp >= xpToNext) {
                level++;
                xp = 0;
                xpToNext = level * 100;
                showUpgrades();
            }
        }

        function showUpgrades() {
            // Pause and show 3 random upgrades
            gameState = 'paused';
            let upgrades = generateUpgrades();
            // For simplicity, auto apply one random
            let upgrade = upgrades[Math.floor(Math.random() * upgrades.length)];
            applyUpgrade(upgrade);
            setTimeout(() => gameState = 'playing', 1000);
        }

        function generateUpgrades() {
            let pool = [];
            // Unlocks
            for (let i = 0; i < spells.length; i++) {
                if (!player.unlocks.includes(i)) pool.push({type: 'unlock', index: i});
            }
            // Buffs
            pool.push({type: 'buff', spell: Math.floor(Math.random()*spells.length), value: 'dmg+10'});
            // Stats rare
            if (Math.random() < 0.1) pool.push({type: 'stat', stat: 'atk', value: 2});
            if (Math.random() < 0.1 && player.pl < 16) pool.push({type: 'stat', stat: 'pl', value: 1});
            return pool.slice(0, 3);
        }

        function applyUpgrade(upgrade) {
            if (upgrade.type === 'unlock') {
                player.unlocks.push(upgrade.index);
            } else if (upgrade.type === 'buff') {
                // Apply buff
                console.log('Buff applied');
            } else if (upgrade.type === 'stat') {
                if (upgrade.stat === 'atk') player.atk += upgrade.value;
                if (upgrade.stat === 'pl') {
                    player.pl = Math.min(16, player.pl + upgrade.value);
                    // God mode effects
                    if (player.pl === 16) {
                        canvas.style.filter = 'brightness(1.2)';
                    }
                }
            }
            saveGame();
        }

        // Update
        function update(dt) {
            if (gameState !== 'playing') return;
            animationFrame += dt;
            player.update(dt);
            enemies.forEach(e => e.update(dt));
            projectiles = projectiles.filter(p => p.update(dt));
            particles = particles.filter(p => p.update(dt));
            // PL effects
            if (player.pl >= 16) {
                // Screen shake
                ctx.save();
                ctx.translate(Math.random()*4 - 2, Math.random()*4 - 2);
            }
            // Mana cost for shield
            if (player.shieldActive) {
                player.mana = Math.max(0, player.mana - dt / 100); // drain
            }
            // Enemy flee at PL16
            if (player.pl >= 16) {
                enemies.forEach(e => {
                    if (Math.random() < 0.01) {
                        let fleeAngle = Math.atan2(player.y - e.y, player.x - e.x) + Math.PI;
                        e.x += Math.cos(fleeAngle) * 50;
                        e.y += Math.sin(fleeAngle) * 50;
                    }
                });
            }
        }

        // Render
        function render() {
            ctx.clearRect(0, 0, 800, 600);

            // Aim line
            ctx.strokeStyle = 'gray';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(player.x, player.y);
            ctx.lineTo(mouse.x, mouse.y);
            ctx.stroke();

            player.draw();
            enemies.forEach(e => e.draw());
            projectiles.forEach(p => p.draw());
            particles.forEach(p => p.draw());

            if (player.pl >= 16) ctx.restore();

            // UI
            ui.innerHTML = `
                Health: ${Math.floor(player.health)}/${player.maxHealth}<br>
                Mana: ${Math.floor(player.mana)}/${player.maxMana}<br>
                PL: ${player.pl}<br>
                ATK: ${player.atk}<br>
                DEF: ${player.def}<br>
                Level: ${level}<br>
                XP: ${xp}/${xpToNext}<br>
                Wave: ${currentWave}
            `;

            // Spell list
            let list = '';
            spells.forEach((s, i) => {
                let status = player.unlocks.includes(i) ? 'UNLOCKED' : 'LOCKED';
                let selected = i === selectedSpell ? ' style="color: lime;"' : '';
                let cd = s.unlocked ? Math.max(0, (s.cd - (Date.now() - player.lastSpell)) / 1000) : '∞';
                list += `<div${selected}>${s.name} [${cd}s] - ${status}</div>`;
            });
            spellList.innerHTML = list;
        }

        // Game loop
        function gameLoop(time) {
            if (!lastTime) lastTime = time;
            let dt = time - lastTime;
            lastTime = time;
            update(dt);
            render();
            if (gameState === 'playing') requestAnimationFrame(gameLoop);
        }

        // Init
        startGame(); // Wait for button, but for demo
    </script>
</body>
</html>
