<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alternate's Magical Evolution</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #000;
            color: #fff;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 1px solid #fff;
            background-color: #111;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
            display: none;
        }
        #spells {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border: 1px solid #fff;
            width: 200px;
            display: none;
            font-size: 12px;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            font-size: 12px;
            opacity: 0.7;
            display: none;
        }
        #levelUp {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border: 1px solid #fff;
            display: none;
            text-align: center;
            max-width: 300px;
        }
        button {
            margin: 5px;
            padding: 10px;
            background: #333;
            color: #fff;
            border: 1px solid #fff;
            cursor: pointer;
            display: block;
            width: 80%;
        }
        button:hover {
            background: #555;
        }
        #mainMenu, #attributes {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border: 1px solid #fff;
            text-align: center;
            display: none;
        }
        #mainMenu {
            display: block;
        }
        ul {
            text-align: left;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="ui">
        <div>Health: <span id="health">100</span>/100</div>
        <div>Mana: <span id="mana">100</span>/100</div>
        <div>PL: <span id="pl">1</span> | ATK: <span id="atk">20</span> | DEF: <span id="def">10</span></div>
        <div>Level: <span id="level">1</span></div>
        <div>XP: <span id="xp">0</span>/<span id="nextLevel">100</span></div>
    </div>
    <div id="spells">
        <h3>Spells</h3>
        <div>1: Magic Shot (CD: <span id="cd1">0</span>s) [UNLOCKED]</div>
        <div>2: Tri-Shot (CD: <span id="cd2">∞</span>s) [LOCKED]</div>
        <div>3: Beam Shot (CD: <span id="cd3">∞</span>s) [LOCKED]</div>
        <div>4: Ice Shard (CD: <span id="cd4">∞</span>s) [LOCKED]</div>
        <div>5: Lightning (CD: <span id="cd5">∞</span>s) [LOCKED]</div>
        <div>6: Curve Shot (CD: <span id="cd6">∞</span>s) [LOCKED]</div>
        <div>7: Shield Breaker (CD: <span id="cd7">∞</span>s) [LOCKED]</div>
        <div>8: Homing Missile (CD: <span id="cd8">∞</span>s) [LOCKED]</div>
        <div>9: Force Wave (CD: <span id="cd9">∞</span>s) [LOCKED]</div>
        <div>C: Penta Shot (CD: <span id="cd10">∞</span>s) [LOCKED]</div>
        <div>V: Recursive Shot (CD: <span id="cd11">∞</span>s) [LOCKED]</div>
        <div>B: Shield Attack (CD: <span id="cd12">∞</span>s) [LOCKED]</div>
        <div>N: Beta Laser (CD: <span id="cd13">∞</span>s) [LOCKED]</div>
        <div>M: Super Speed (CD: <span id="cd14">∞</span>s) [LOCKED]</div>
    </div>
    <div id="controls">
        Movement: WASD/Arrows. Aim: Mouse. Spells: 1-9, C-V-B-N-M. Shield: Hold SPACE. R: Restart.
    </div>
    <div id="mainMenu">
        <h1>Alternate's Magical Evolution</h1>
        <button onclick="startGame()">Play</button>
        <br><br>
        <button onclick="showAttributes()">Attributes</button>
        <br><br>
        <p>Inspired by Zeruel82Mk2's Stickworld!</p>
    </div>
    <div id="attributes">
        <h2>Attributes</h2>
        <div id="stats"></div>
        <br>
        <button onclick="backToMenu()">Back to Menu</button>
    </div>
    <div id="levelUp">
        <h2>Level Up! Choose Upgrade:</h2>
        <div id="upgradeOptions"></div>
        <p id="upgradeDesc"></p>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const uiHealth = document.getElementById('health');
        const uiMana = document.getElementById('mana');
        const uiPL = document.getElementById('pl');
        const uiATK = document.getElementById('atk');
        const uiDEF = document.getElementById('def');
        const uiLevel = document.getElementById('level');
        const uiXP = document.getElementById('xp');
        const uiNext = document.getElementById('nextLevel');
        const cds = ['cd1','cd2','cd3','cd4','cd5','cd6','cd7','cd8','cd9','cd10','cd11','cd12','cd13','cd14'].map(id => document.getElementById(id));
        const levelUpDiv = document.getElementById('levelUp');
        const upgradeOptions = document.getElementById('upgradeOptions');
        const mainMenu = document.getElementById('mainMenu');
        const attributes = document.getElementById('attributes');
        const statsDiv = document.getElementById('stats');

        // Game state
        let gameState = {
            currentScreen: 'menu',
            player: {
                x: 400, y: 300, width: 20, height: 20,
                health: 100, maxHealth: 100,
                mana: 100, maxMana: 100,
                speed: 3,
                level: 1, xp: 0, xpToNext: 100,
                pl: 1, atk: 20, def: 10,
                unlocked: new Set([1]), // Start with only 1
                spells: {
                    1: { name: 'Magic Shot', damage: 20, cost: 20, cooldown: 0, maxCd: 500, type: 'projectile' },
                    2: { name: 'Tri-Shot', damage: 15, cost: 25, cooldown: Infinity, maxCd: 700, type: 'multi' },
                    3: { name: 'Beam Shot', damage: 30, cost: 30, cooldown: Infinity, maxCd: 1500, type: 'beam' },
                    4: { name: 'Ice Shard', damage: 15, cost: 15, cooldown: Infinity, maxCd: 800, type: 'ice' },
                    5: { name: 'Lightning', damage: 25, cost: 25, cooldown: Infinity, maxCd: 1000, type: 'chain' },
                    6: { name: 'Curve Shot', damage: 25, cost: 25, cooldown: Infinity, maxCd: 900, type: 'homing', homingStrength: 0.05 },
                    7: { name: 'Shield Breaker', damage: 0, cost: 40, cooldown: Infinity, maxCd: 2000, type: 'aoe_break', breakStrength: 50 },
                    8: { name: 'Homing Missile', damage: 35, cost: 35, cooldown: Infinity, maxCd: 1200, type: 'homing_missile' },
                    9: { name: 'Force Wave', damage: 20, cost: 30, cooldown: Infinity, maxCd: 1100, type: 'wave', aoeRadius: 50 },
                    10: { name: 'Penta Shot', damage: 12, cost: 30, cooldown: Infinity, maxCd: 1000, type: 'multi_penta' },
                    11: { name: 'Recursive Shot', damage: 25, cost: 25, cooldown: Infinity, maxCd: 800, type: 'recursive' },
                    12: { name: 'Shield Attack', damage: 40, cost: 35, cooldown: Infinity, maxCd: 1200, type: 'shield_proj' },
                    13: { name: 'Beta Laser', damage: 50, cost: 50, cooldown: Infinity, maxCd: 2000, type: 'beta_beam' },
                    14: { name: 'Super Speed', damage: 0, cost: 20, cooldown: Infinity, maxCd: 5000, type: 'buff_speed' }
                },
                shield: { active: false, strength: 100, absorbed: 0, yield: 1.0, omni: false },
                usedUpgrades: new Set(),
                manaRegen: 20
            },
            enemies: [],
            bosses: [],
            projectiles: [],
            beams: [],
            enemyProjectiles: [],
            particles: [],
            keys: {},
            mouseX: 0,
            mouseY: 0,
            lastTime: 0,
            gameOver: false,
            paused: false,
            upgradePool: [
                // Unlocks
                {id: 'unlock_2', name: 'Unlock Tri-Shot (2)', apply: (p) => { p.unlocked.add(2); p.spells[2].cooldown = 0; }},
                {id: 'unlock_3', name: 'Unlock Beam Shot (3)', apply: (p) => { p.unlocked.add(3); p.spells[3].cooldown = 0; }},
                {id: 'unlock_4', name: 'Unlock Ice Shard (4)', apply: (p) => { p.unlocked.add(4); p.spells[4].cooldown = 0; }},
                {id: 'unlock_5', name: 'Unlock Lightning (5)', apply: (p) => { p.unlocked.add(5); p.spells[5].cooldown = 0; }},
                {id: 'unlock_6', name: 'Unlock Curve Shot (6)', apply: (p) => { p.unlocked.add(6); p.spells[6].cooldown = 0; }},
                {id: 'unlock_7', name: 'Unlock Shield Breaker (7)', apply: (p) => { p.unlocked.add(7); p.spells[7].cooldown = 0; }},
                {id: 'unlock_8', name: 'Unlock Homing Missile (8)', apply: (p) => { p.unlocked.add(8); p.spells[8].cooldown = 0; }},
                {id: 'unlock_9', name: 'Unlock Force Wave (9)', apply: (p) => { p.unlocked.add(9); p.spells[9].cooldown = 0; }},
                {id: 'unlock_10', name: 'Unlock Penta Shot (C)', apply: (p) => { p.unlocked.add(10); p.spells[10].cooldown = 0; }},
                {id: 'unlock_11', name: 'Unlock Recursive Shot (V)', apply: (p) => { p.unlocked.add(11); p.spells[11].cooldown = 0; }},
                {id: 'unlock_12', name: 'Unlock Shield Attack (B)', apply: (p) => { p.unlocked.add(12); p.spells[12].cooldown = 0; }},
                {id: 'unlock_13', name: 'Unlock Beta Laser (N)', apply: (p) => { p.unlocked.add(13); p.spells[13].cooldown = 0; }},
                {id: 'unlock_14', name: 'Unlock Super Speed (M)', apply: (p) => { p.unlocked.add(14); p.spells[14].cooldown = 0; }},
                // Other upgrades (damage, stats, etc.)
                {id: 'fire_dmg', name: 'Magic Shot + Damage', apply: (p) => p.spells[1].damage += 10 },
                {id: 'atk_up', name: 'ATK +5', apply: (p) => p.atk += 5 },
                {id: 'def_up', name: 'DEF +5', apply: (p) => p.def += 5 },
                {id: 'pl_up', name: 'PL +1', apply: (p) => p.pl += 1 },
                {id: 'mana_regen', name: 'Mana Regen +10%', apply: (p) => p.manaRegen *= 1.1 },
                {id: 'shield_yield', name: 'Shield Better Yield', apply: (p) => p.shield.yield = Math.max(0.5, p.shield.yield - 0.1) },
                {id: 'omni_shield', name: 'Omni-Shield', apply: (p) => p.shield.omni = true },
                {id: 'shield_str', name: 'Shield Strength +50', apply: (p) => p.shield.strength += 50 }
            ]
        };

        // Draw refined stick figure
        function drawStickFigure(x, y, color, hat = false, size = 1) {
            ctx.save();
            ctx.translate(x, y);
            ctx.scale(size, size);
            // Body
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, -10);
            ctx.lineTo(0, 10);
            ctx.stroke();
            // Arms
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-8, 5);
            ctx.moveTo(0, 0);
            ctx.lineTo(8, 5);
            ctx.stroke();
            // Legs
            ctx.beginPath();
            ctx.moveTo(0, 10);
            ctx.lineTo(-5, 20);
            ctx.moveTo(0, 10);
            ctx.lineTo(5, 20);
            ctx.stroke();
            // Head
            ctx.beginPath();
            ctx.arc(0, -15, 5, 0, Math.PI * 2);
            ctx.stroke();
            if (hat) {
                ctx.fillStyle = '#f0f';
                ctx.fillRect(-3, -25, 6, 10);
            }
            ctx.restore();
        }

        // Menu functions
        window.startGame = function() {
            gameState.currentScreen = 'game';
            mainMenu.style.display = 'none';
            document.getElementById('ui').style.display = 'block';
            document.getElementById('spells').style.display = 'block';
            document.getElementById('controls').style.display = 'block';
            loadSave();
            // Ensure fresh spawn
            gameState.enemies = [];
            gameState.bosses = [];
            generateWave(gameState.player.level);
            gameState.gameOver = false;
            gameState.paused = false;
            gameState.lastTime = performance.now();
            updateUI();
            // Restart the loop
            cancelAnimationFrame(animationId);
            gameLoop(performance.now());
        };

        window.showAttributes = function() {
            gameState.currentScreen = 'attributes';
            mainMenu.style.display = 'none';
            attributes.style.display = 'block';
            let statsHtml = `
                <ul>
                    <li>Level: ${gameState.player.level}</li>
                    <li>PL: ${gameState.player.pl}</li>
                    <li>ATK: ${gameState.player.atk}</li>
                    <li>DEF: ${gameState.player.def}</li>
                    <li>Health: ${Math.floor(gameState.player.health)}/${gameState.player.maxHealth}</li>
                    <li>Mana: ${Math.floor(gameState.player.mana)}/${gameState.player.maxMana}</li>
                    <li>Speed: ${gameState.player.speed}</li>
                    <li>XP: ${Math.floor(gameState.player.xp)}/${gameState.player.xpToNext}</li>
                    <li>Shield Yield: ${gameState.player.shield.yield.toFixed(2)}</li>
                    <li>Unlocked Spells: ${Array.from(gameState.player.unlocked).join(', ')}</li>
                    <li>Spells:</li><ul>
            `;
            for (let key of [1,2,3,4,5,6,7,8,9,10,11,12,13,14]) {
                const spell = gameState.player.spells[key];
                const status = gameState.player.unlocked.has(key) ? 'UNLOCKED' : 'LOCKED';
                statsHtml += `<li>${key}: ${spell.name} - Dmg ${spell.damage}, Cost ${spell.cost}, CD ${spell.maxCd/1000}s [${status}]</li>`;
            }
            statsHtml += '</ul></ul>';
            statsDiv.innerHTML = statsHtml;
        };

        window.backToMenu = function() {
            gameState.currentScreen = 'menu';
            attributes.style.display = 'none';
            mainMenu.style.display = 'block';
            if (gameState.gameOver) restart();
        };

        // Save/Load
        function loadSave() {
            const saved = localStorage.getItem('alternateSave');
            if (saved) {
                const data = JSON.parse(saved);
                gameState.player = { ...gameState.player, ...data.player };
                gameState.player.unlocked = new Set(data.player.unlocked || [1]);
                gameState.player.usedUpgrades = new Set(data.player.usedUpgrades);
            } else {
                // New game defaults
                gameState.player.unlocked = new Set([1]);
                for (let key of [2,3,4,5,6,7,8,9,10,11,12,13,14]) {
                    gameState.player.spells[key].cooldown = Infinity;
                }
            }
        }

        function saveGame() {
            const saveData = { 
                player: { 
                    ...gameState.player, 
                    unlocked: [...gameState.player.unlocked],
                    usedUpgrades: [...gameState.player.usedUpgrades]
                } 
            };
            localStorage.setItem('alternateSave', JSON.stringify(saveData));
        }

        // Generate wave or boss
        function generateWave(level) {
            gameState.enemies = [];
            gameState.bosses = [];
            const isBoss = level % 5 === 0;
            const num = isBoss ? 1 : Math.min(1 + Math.floor(level / 2), 5);
            if (isBoss) {
                const boss = {
                    x: 400, y: 100, width: 30, height: 30,
                    health: 500 + level * 100, maxHealth: 500 + level * 100,
                    speed: 1.5 + level * 0.1,
                    atk: 30 + level * 10, def: 20 + level * 5, pl: level,
                    color: '#f00',
                    type: 'Boss Magician',
                    lastAttack: 0, attackCooldown: 1500,
                    lastSpell: 0, spellCooldown: 2000,
                    aiState: 'chase',
                    dodgeDir: { x: 0, y: 0 },
                    slow: 0,
                    shield: { active: false, strength: 200 }
                };
                gameState.bosses.push(boss);
            } else {
                for (let i = 0; i < num; i++) {
                    const enemy = {
                        x: Math.random() * (canvas.width - 40) + 20,
                        y: Math.random() * (canvas.height - 40) + 20,
                        width: 20, height: 20,
                        health: 50 + level * 20, maxHealth: 50 + level * 20,
                        speed: 1 + level * 0.2,
                        atk: 10 + level * 5, def: 5 + level * 2, pl: Math.floor(level / 2),
                        color: `hsl(${level * 30}, 70%, 50%)`,
                        type: ['Fire Mage', 'Ice Sorcerer', 'Shadow Warlock', 'Storm Caller', 'Arcane Beast'][level % 5],
                        lastAttack: 0, attackCooldown: 2000 - level * 50,
                        lastSpell: 0, spellCooldown: 3000 - level * 100,
                        aiState: 'chase',
                        dodgeDir: { x: 0, y: 0 },
                        slow: 0,
                        shield: { active: false, strength: 50 + level * 10 }
                    };
                    gameState.enemies.push(enemy);
                }
            }
        }

        // Input
        window.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            gameState.keys[key] = true;
            if (key === 'r' && gameState.currentScreen === 'game') restart();
            // Spell keys
            let spellKey = null;
            if (key >= '1' && key <= '9') spellKey = parseInt(key);
            else if (key === 'c') spellKey = 10;
            else if (key === 'v') spellKey = 11;
            else if (key === 'b') spellKey = 12;
            else if (key === 'n') spellKey = 13;
            else if (key === 'm') spellKey = 14;
            if (spellKey && gameState.currentScreen === 'game' && !gameState.gameOver && !gameState.paused) {
                castSpell(spellKey);
            }
        });
        window.addEventListener('keyup', (e) => {
            gameState.keys[e.key.toLowerCase()] = false;
        });
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            gameState.mouseX = e.clientX - rect.left;
            gameState.mouseY = e.clientY - rect.top;
        });

        function castSpell(key) {
            if (!gameState.player.unlocked.has(key)) return;
            const spell = gameState.player.spells[key];
            if (gameState.player.mana < spell.cost || spell.cooldown > 0) return;
            const dx = gameState.mouseX - gameState.player.x;
            const dy = gameState.mouseY - gameState.player.y;
            const dist = Math.sqrt(dx * dx + dy * dy) || 1;
            const angle = Math.atan2(dy, dx);
            const dirX = dx / dist;
            const dirY = dy / dist;

            if (spell.type === 'beam' || spell.type === 'beta_beam') {
                gameState.beams.push({ startX: gameState.player.x, startY: gameState.player.y, endX: gameState.mouseX, endY: gameState.mouseY, damage: spell.damage, life: 200 });
                [...gameState.enemies, ...gameState.bosses].forEach(ent => {
                    if (lineIntersectsRect(gameState.player.x, gameState.player.y, gameState.mouseX, gameState.mouseY, ent.x - 15, ent.y - 15, 30, 30)) {
                        const dmg = Math.max(0, spell.damage - ent.def);
                        ent.health -= dmg;
                        ent.shield.active = false;
                        addParticles(ent.x, ent.y, 'beam', 10);
                    }
                });
            } else if (['projectile', 'homing', 'homing_missile'].includes(spell.type)) {
                gameState.projectiles.push({
                    x: gameState.player.x, y: gameState.player.y,
                    vx: dirX * 8, vy: dirY * 8,
                    damage: spell.damage, type: spell.name.toLowerCase().replace(/ /g, '-'),
                    life: 1000, angle: angle, homing: spell.homingStrength || 0
                });
            } else if (spell.type === 'multi' || spell.type === 'multi_penta') {
                const spread = spell.type === 'multi' ? 1 : 2;
                for (let i = -spread; i <= spread; i++) {
                    const a = angle + i * 0.3;
                    gameState.projectiles.push({
                        x: gameState.player.x, y: gameState.player.y,
                        vx: Math.cos(a) * 8, vy: Math.sin(a) * 8,
                        damage: spell.damage, type: spell.type,
                        life: 1000, angle: a
                    });
                }
            } else if (spell.type === 'ice') {
                gameState.projectiles.push({
                    x: gameState.player.x, y: gameState.player.y,
                    vx: dirX * 8, vy: dirY * 8,
                    damage: spell.damage, type: 'ice',
                    life: 1000, angle: angle, slow: 0.5
                });
            } else if (spell.type === 'chain') {
                gameState.projectiles.push({
                    x: gameState.player.x, y: gameState.player.y,
                    vx: dirX * 8, vy: dirY * 8,
                    damage: spell.damage, type: 'lightning',
                    life: 1000, angle: angle, chainRange: 50
                });
            } else if (spell.type === 'aoe_break') {
                const cx = gameState.mouseX, cy = gameState.mouseY;
                [...gameState.enemies, ...gameState.bosses].forEach(ent => {
                    const edist = Math.sqrt((ent.x - cx)**2 + (ent.y - cy)**2);
                    if (edist < 100) {
                        ent.shield.strength = Math.max(0, ent.shield.strength - spell.breakStrength);
                        if (ent.shield.strength <= 0) ent.shield.active = false;
                        const dmg = Math.max(0, spell.damage - ent.def);
                        ent.health -= dmg;
                        addParticles(ent.x, ent.y, 'breaker', 5);
                    }
                });
            } else if (spell.type === 'wave') {
                [...gameState.enemies, ...gameState.bosses].forEach(ent => {
                    const dx2 = ent.x - gameState.player.x;
                    const dy2 = ent.y - gameState.player.y;
                    const dist2 = Math.sqrt(dx2**2 + dy2**2);
                    if (dist2 < spell.aoeRadius && Math.abs(Math.atan2(dy2, dx2) - angle) < 0.5) {
                        const dmg = Math.max(0, spell.damage - ent.def);
                        ent.health -= dmg;
                        ent.x += dirX * 20; ent.y += dirY * 20;
                        addParticles(ent.x, ent.y, 'wave', 5);
                    }
                });
            } else if (spell.type === 'buff_speed') {
                // Temp speed boost
                gameState.player.speed *= 2;
                setTimeout(() => gameState.player.speed /= 2, 5000);
            } // Add more types as needed for recursive, shield_proj, etc.

            gameState.player.mana -= spell.cost;
            spell.cooldown = spell.maxCd;
            updateUI();
        }

        // Line intersect (simplified)
        function lineIntersectsRect(x1, y1, x2, y2, rx, ry, rw, rh) {
            const distToLine = Math.abs((y2 - y1) * (rx + rw/2 - x1) - (x2 - x1) * (ry + rh/2 - y1)) / Math.sqrt((y2 - y1)**2 + (x2 - x1)**2);
            return distToLine < Math.max(rw, rh) / 2 && Math.min(x1, x2) < rx + rw && Math.max(x1, x2) > rx && Math.min(y1, y2) < ry + rh && Math.max(y1, y2) > ry;
        }

        function addParticles(x, y, type, num = 5) {
            const colors = { beam: '#fff', ice: '#0ff', lightning: '#ff0', breaker: '#f0f', wave: '#00f', shield: '#0f0' };
            for (let i = 0; i < num; i++) {
                gameState.particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 6,
                    vy: (Math.random() - 0.5) * 6,
                    life: 500,
                    color: colors[type] || '#f80',
                    size: 2
                });
            }
        }

        function updatePlayer(dt) {
            if (gameState.currentScreen !== 'game') return;

            // Shield
            const space = gameState.keys[' '];
            gameState.player.shield.active = space;

            // Movement
            const up = gameState.keys['w'] || gameState.keys['arrowup'];
            const down = gameState.keys['s'] || gameState.keys['arrowdown'];
            const left = gameState.keys['a'] || gameState.keys['arrowleft'];
            const right = gameState.keys['d'] || gameState.keys['arrowright'];
            let mx = 0, my = 0;
            if (up) my -= 1;
            if (down) my += 1;
            if (left) mx -= 1;
            if (right) mx += 1;
            const moveDist = Math.sqrt(mx**2 + my**2);
            if (moveDist > 0) {
                gameState.player.x += (mx / moveDist) * gameState.player.speed * dt * 60;
                gameState.player.y += (my / moveDist) * gameState.player.speed * dt * 60;
            }

            // Regen
            const regen = gameState.player.manaRegen || 20;
            gameState.player.mana = Math.min(gameState.player.maxMana, gameState.player.mana + dt * regen);
            Object.values(gameState.player.spells).forEach(s => s.cooldown = Math.max(0, s.cooldown - dt * 1000));

            // Bounds
            gameState.player.x = Math.max(10, Math.min(canvas.width - 30, gameState.player.x));
            gameState.player.y = Math.max(10, Math.min(canvas.height - 30, gameState.player.y));
        }

        // ... (updateEntities, updateProjectiles, updateBeams, updateParticles, addXP, levelUp, showLevelUp, selectUpgrade, gameOver, restart, updateUI, draw, gameLoop remain similar, with adjustments for new spells and keys)

        function updateEntities(entities, dt, isBoss = false) {
            // Similar to previous, omitted for brevity
            entities.forEach((ent, idx) => {
                // AI, movement, attacks as before
                // ...
                if (ent.health <= 0) {
                    if (isBoss) gameState.bosses.splice(idx, 1);
                    else gameState.enemies.splice(idx, 1);
                    addXP(isBoss ? 500 : 50 + gameState.player.level * 10);
                }
            });
        }

        function updateProjectiles(dt) {
            // Similar, with homing for curve/homing_missile
            gameState.projectiles.forEach((proj, pidx) => {
                if (proj.homing && proj.life > 500) {
                    let closest = null, minDist = Infinity;
                    [...gameState.enemies, ...gameState.bosses].forEach(ent => {
                        const pdist = Math.sqrt((proj.x - ent.x)**2 + (proj.y - ent.y)**2);
                        if (pdist < minDist) {
                            minDist = pdist;
                            closest = ent;
                        }
                    });
                    if (closest) {
                        const hdx = closest.x - proj.x;
                        const hdy = closest.y - proj.y;
                        const hdist = Math.sqrt(hdx**2 + hdy**2) || 1;
                        proj.vx += (hdx / hdist) * proj.homing * dt * 60;
                        proj.vy += (hdy / hdist) * proj.homing * dt * 60;
                    }
                }
                // Movement, collisions as before
                proj.x += proj.vx * dt * 60;
                proj.y += proj.vy * dt * 60;
                proj.life -= dt * 1000;
                proj.angle = Math.atan2(proj.vy, proj.vx);

                // Collisions with entities
                [...gameState.enemies, ...gameState.bosses].forEach(ent => {
                    if (Math.abs(proj.x - ent.x) < 15 && Math.abs(proj.y - ent.y) < 15) {
                        let dmg = Math.max(0, proj.damage - ent.def);
                        if (ent.shield.active && ent.shield.strength > 0) {
                            const absorbed = Math.min(dmg, ent.shield.strength);
                            ent.shield.strength -= absorbed;
                            dmg -= absorbed;
                            if (ent.shield.strength <= 0) ent.shield.active = false;
                        }
                        ent.health -= dmg;
                        gameState.projectiles.splice(pidx, 1);
                        addParticles(ent.x, ent.y, proj.type || 'fire', 5);
                        if (proj.slow) ent.slow = 2000;
                        // Chain for lightning
                        if (proj.type === 'lightning') {
                            [...gameState.enemies, ...gameState.bosses].forEach(other => {
                                if (other !== ent && Math.hypot(other.x - ent.x, other.y - ent.y) < 50) {
                                    other.health -= proj.damage * 0.5;
                                    addParticles(other.x, other.y, 'lightning', 3);
                                }
                            });
                        }
                        return true;
                    }
                });

                if (proj.x < 0 || proj.x > canvas.width || proj.y < 0 || proj.y > canvas.height || proj.life <= 0) {
                    gameState.projectiles.splice(pidx, 1);
                }
            });

            // Enemy projectiles shield logic as before
            gameState.enemyProjectiles.forEach((proj, eidx) => {
                proj.x += proj.vx * dt * 60;
                proj.y += proj.vy * dt * 60;
                proj.life -= dt * 1000;

                if (gameState.player.shield.active && gameState.player.shield.strength > 0 &&
                    Math.hypot(proj.x - gameState.player.x, proj.y - gameState.player.y) < 40) {
                    const dmg = proj.damage;
                    const absorbed = Math.min(dmg, gameState.player.shield.strength);
                    gameState.player.shield.strength -= absorbed;
                    gameState.player.mana -= absorbed * gameState.player.shield.yield;
                    gameState.enemyProjectiles.splice(eidx, 1);
                    addParticles(proj.x, proj.y, 'shield', 5);
                    if (gameState.player.shield.strength <= 0) gameState.player.shield.active = false;
                } else if (Math.abs(proj.x - gameState.player.x) < 20 && Math.abs(proj.y - gameState.player.y) < 20) {
                    let dmg = Math.max(0, proj.damage - gameState.player.def);
                    gameState.player.health -= dmg;
                    gameState.enemyProjectiles.splice(eidx, 1);
                    if (gameState.player.health <= 0) gameOver();
                }

                if (proj.x < 0 || proj.x > canvas.width || proj.y < 0 || proj.y > canvas.height || proj.life <= 0) {
                    gameState.enemyProjectiles.splice(eidx, 1);
                }
            });
        }

        function updateBeams(dt) {
            gameState.beams.forEach((beam, idx) => {
                beam.life -= dt * 1000;
                if (beam.life <= 0) gameState.beams.splice(idx, 1);
            });
        }

        function updateParticles(dt) {
            gameState.particles.forEach((part, idx) => {
                part.x += part.vx * dt * 60;
                part.y += part.vy * dt * 60;
                part.life -= dt * 1000;
                if (part.life <= 0) gameState.particles.splice(idx, 1);
            });
        }

        function addXP(amount) {
            gameState.player.xp += amount;
            while (gameState.player.xp >= gameState.player.xpToNext) {
                gameState.player.xp -= gameState.player.xpToNext;
                gameState.player.level++;
                gameState.player.xpToNext = Math.floor(gameState.player.xpToNext * 1.5);
                gameState.player.maxHealth += 20;
                gameState.player.health = gameState.player.maxHealth;
                gameState.player.maxMana += 20;
                gameState.player.mana = gameState.player.maxMana;
                gameState.player.speed += 0.2;
                gameState.player.atk += 5;
                gameState.player.def += 3;
                gameState.player.pl += 0.5;
                showLevelUp();
            }
            updateUI();
            saveGame();
        }

        function levelUp() {
            addXP(100);
            generateWave(gameState.player.level);
        }

        function showLevelUp() {
            gameState.paused = true;
            const available = gameState.upgradePool.filter(u => !gameState.player.usedUpgrades.has(u.id));
            if (available.length === 0) available = gameState.upgradePool.filter(u => u.id.startsWith('unlock_')); // Prioritize unlocks if depleted
            const choices = [];
            while (choices.length < 3 && available.length > 0) {
                const randIdx = Math.floor(Math.random() * available.length);
                const rand = available[randIdx];
                if (!choices.some(c => c.id === rand.id)) {
                    choices.push(rand);
                    available.splice(randIdx, 1);
                }
            }
            upgradeOptions.innerHTML = choices.map(c => `<button onclick="selectUpgrade('${c.id}')">${c.name}</button>`).join('');
            document.getElementById('upgradeDesc').innerHTML = `Level ${gameState.player.level}!`;
            levelUpDiv.style.display = 'block';
        }

        window.selectUpgrade = function(id) {
            const upgrade = gameState.upgradePool.find(u => u.id === id);
            if (upgrade) upgrade.apply(gameState.player);
            gameState.player.usedUpgrades.add(id);
            levelUpDiv.style.display = 'none';
            gameState.paused = false;
            saveGame();
            updateUI(); // Refresh spell CDs/status
        };

        function gameOver() {
            gameState.gameOver = true;
            alert('Game Over! Press R or back to menu.');
        }

        function restart() {
            gameState.player = {
                x: 400, y: 300, width: 20, height: 20,
                health: 100, maxHealth: 100,
                mana: 100, maxMana: 100,
                speed: 3,
                level: 1, xp: 0, xpToNext: 100,
                pl: 1, atk: 20, def: 10,
                unlocked: new Set([1]),
                spells: {
                    1: { name: 'Magic Shot', damage: 20, cost: 20, cooldown: 0, maxCd: 500, type: 'projectile' },
                    // ... all other spells with cooldown: Infinity
                    2: { name: 'Tri-Shot', damage: 15, cost: 25, cooldown: Infinity, maxCd: 700, type: 'multi' },
                    3: { name: 'Beam Shot', damage: 30, cost: 30, cooldown: Infinity, maxCd: 1500, type: 'beam' },
                    4: { name: 'Ice Shard', damage: 15, cost: 15, cooldown: Infinity, maxCd: 800, type: 'ice' },
                    5: { name: 'Lightning', damage: 25, cost: 25, cooldown: Infinity, maxCd: 1000, type: 'chain' },
                    6: { name: 'Curve Shot', damage: 25, cost: 25, cooldown: Infinity, maxCd: 900, type: 'homing', homingStrength: 0.05 },
                    7: { name: 'Shield Breaker', damage: 0, cost: 40, cooldown: Infinity, maxCd: 2000, type: 'aoe_break', breakStrength: 50 },
                    8: { name: 'Homing Missile', damage: 35, cost: 35, cooldown: Infinity, maxCd: 1200, type: 'homing_missile' },
                    9: { name: 'Force Wave', damage: 20, cost: 30, cooldown: Infinity, maxCd: 1100, type: 'wave', aoeRadius: 50 },
                    10: { name: 'Penta Shot', damage: 12, cost: 30, cooldown: Infinity, maxCd: 1000, type: 'multi_penta' },
                    11: { name: 'Recursive Shot', damage: 25, cost: 25, cooldown: Infinity, maxCd: 800, type: 'recursive' },
                    12: { name: 'Shield Attack', damage: 40, cost: 35, cooldown: Infinity, maxCd: 1200, type: 'shield_proj' },
                    13: { name: 'Beta Laser', damage: 50, cost: 50, cooldown: Infinity, maxCd: 2000, type: 'beta_beam' },
                    14: { name: 'Super Speed', damage: 0, cost: 20, cooldown: Infinity, maxCd: 5000, type: 'buff_speed' }
                },
                shield: { active: false, strength: 100, absorbed: 0, yield: 1.0, omni: false },
                usedUpgrades: new Set(),
                manaRegen: 20
            };
            gameState.enemies = [];
            gameState.bosses = [];
            gameState.projectiles = [];
            gameState.beams = [];
            gameState.enemyProjectiles = [];
            gameState.particles = [];
            gameState.gameOver = false;
            gameState.paused = false;
            generateWave(1);
            updateUI();
            localStorage.removeItem('alternateSave');
        }

        function updateUI() {
            if (gameState.currentScreen !== 'game') return;
            uiHealth.textContent = Math.floor(gameState.player.health);
            uiMana.textContent = Math.floor(gameState.player.mana);
            uiPL.textContent = gameState.player.pl.toFixed(1);
            uiATK.textContent = gameState.player.atk;
            uiDEF.textContent = gameState.player.def;
            uiLevel.textContent = gameState.player.level;
            uiXP.textContent = Math.floor(gameState.player.xp);
            uiNext.textContent = gameState.player.xpToNext;
            for (let i = 1; i <= 14; i++) {
                const spell = gameState.player.spells[i];
                const cdEl = document.getElementById(`cd${i < 10 ? i : i === 10 ? '10' : i === 11 ? '11' : i === 12 ? '12' : i === 13 ? '13' : '14'}`);
                cdEl.textContent = gameState.player.unlocked.has(i) ? (spell.cooldown / 1000).toFixed(1) : '∞';
                const row = cdEl.parentElement;
                row.innerHTML = `${i < 10 ? i : i === 10 ? 'C' : i === 11 ? 'V' : i === 12 ? 'B' : i === 13 ? 'N' : 'M'}: ${spell.name} (CD: <span id="cd${i < 10 ? i : i === 10 ? '10' : i === 11 ? '11' : i === 12 ? '12' : i === 13 ? '13' : '14'}">${cdEl.textContent}</span>s) [${gameState.player.unlocked.has(i) ? 'UNLOCKED' : 'LOCKED'}]`;
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (gameState.currentScreen !== 'game') return;

            // Shield draw
            if (gameState.player.shield.active) {
                ctx.strokeStyle = gameState.player.shield.omni ? '#0ff' : '#00f';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(gameState.player.x, gameState.player.y, 40 + (gameState.player.shield.omni ? 20 : 0), 0, Math.PI * 2);
                ctx.stroke();
            }

            // Player draw
            drawStickFigure(gameState.player.x, gameState.player.y, '#00f', true);

            // Entities draw with health bars
            [...gameState.enemies, ...gameState.bosses].forEach(ent => {
                const size = ent.width > 20 ? 1.5 : 1;
                drawStickFigure(ent.x, ent.y, ent.color, ent.type.includes('Mage'), size);
                ctx.fillStyle = '#f00';
                ctx.fillRect(ent.x - 15 * size, ent.y - 35 * size, 30 * size, 3);
                ctx.fillStyle = '#0f0';
                ctx.fillRect(ent.x - 15 * size, ent.y - 35 * size, (ent.health / ent.maxHealth) * 30 * size, 3);
            });

            // Projectiles draw (simplified for brevity, add unique designs per type)
            gameState.projectiles.forEach(proj => {
                ctx.save();
                ctx.translate(proj.x, proj.y);
                ctx.rotate(proj.angle);
                ctx.fillStyle = proj.type.includes('beam') ? '#fff' : proj.type.includes('ice') ? '#0ff' : proj.type.includes('lightning') ? '#ff0' : '#f80';
                ctx.beginPath();
                ctx.arc(0, 0, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });

            // Enemy proj, beams, particles as before (omitted for brevity)

            // Aim line
            ctx.strokeStyle = '#888';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(gameState.player.x, gameState.player.y);
            ctx.lineTo(gameState.mouseX, gameState.mouseY);
            ctx.stroke();

            if (gameState.gameOver || gameState.paused) {
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#fff';
                ctx.font = '30px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(gameState.gameOver ? 'Game Over' : 'Paused', canvas.width / 2, canvas.height / 2);
            }
        }

        let animationId;
        function gameLoop(currentTime) {
            if (gameState.currentScreen !== 'game') {
                animationId = requestAnimationFrame(gameLoop);
                return;
            }

            const dt = Math.min((currentTime - gameState.lastTime) / 1000, 1/30);
            gameState.lastTime = currentTime;

            if (!gameState.gameOver && !gameState.paused) {
                updatePlayer(dt);
                updateEntities(gameState.enemies, dt);
                updateEntities(gameState.bosses, dt, true);
                updateProjectiles(dt);
                updateBeams(dt);
                updateParticles(dt);
                updateUI();

                if (gameState.enemies.length === 0 && gameState.bosses.length === 0) {
                    levelUp();
                }
            }

            draw();
            animationId = requestAnimationFrame(gameLoop);
        }

        // Init
        mainMenu.style.display = 'block';
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
