<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rhythm Dodge</title>
    <style>
        body { 
            margin: 0; 
            background: #000; 
            overflow: hidden;
            font-family: monospace; 
            color: #fff; 
        }
        canvas { 
            display: block; 
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Resize canvas to full screen
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Game state
        let gameState = 'menu'; // 'menu', 'shop', 'playing', 'gameOver'
        let player = { x: canvas.width / 2, y: canvas.height / 2, size: 10, vx: 0, vy: 0, speed: 5 };
        let attacks = [];
        let score = 0;
        let lives = 5;
        let creds = parseInt(localStorage.getItem('creds')) || 0;
        let selectedSkin = localStorage.getItem('selectedSkin') || 'Default Cube';
        let isDashing = false;
        let dashCooldown = 0;
        let dashDuration = 0;
        let invincibleTime = 0;
        let lastSpawn = 0;
        let beatThreshold = 0.7;
        let lastBeatTime = 0;
        let beatInterval = 500;

        // Audio
        let audioContext, analyser, microphone, rafId;

        // Skins
        const skins = [
            { name: 'Default Cube', shape: 'square', color: '#ffffff', price: 0 },
            { name: 'Neon Red', shape: 'square', color: '#ff0040', price: 50 },
            { name: 'Cyber Blue', shape: 'square', color: '#00bfff', price: 100 },
            { name: 'Lime Pulse', shape: 'circle', color: '#00ff41', price: 75 },
            { name: 'Violet Star', shape: 'star', color: '#8a2be2', price: 150 },
            { name: 'Golden Dash', shape: 'square', color: '#ffd700', price: 200 }
        ];
        let ownedSkins = JSON.parse(localStorage.getItem('ownedSkins')) || ['Default Cube'];

        // Keys
        const keys = {};
        document.addEventListener('keydown', (e) => { keys[e.code] = true; });
        document.addEventListener('keyup', (e) => { keys[e.code] = false; });

        // Mouse for UI
        let mouseX = 0, mouseY = 0;
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        });
        canvas.addEventListener('click', (e) => handleClick(e.clientX - canvas.getBoundingClientRect().left, e.clientY - canvas.getBoundingClientRect().top));

        function handleClick(x, y) {
            if (gameState === 'menu') {
                // Play button
                if (x > canvas.width/2 - 50 && x < canvas.width/2 + 50 && y > canvas.height/2 + 50 && y < canvas.height/2 + 80) {
                    startGame();
                }
                // Shop button
                if (x > canvas.width/2 - 50 && x < canvas.width/2 + 50 && y > canvas.height/2 && y < canvas.height/2 + 30) {
                    showShop();
                }
            } else if (gameState === 'shop') {
                // Back button
                if (x > canvas.width/2 - 50 && x < canvas.width/2 + 50 && y > canvas.height - 60 && y < canvas.height - 30) {
                    backToMenu();
                }
                // Skin buttons
                skins.forEach((skin, i) => {
                    const btnY = 200 + i * 40;
                    if (x > canvas.width/2 - 60 && x < canvas.width/2 + 60 && y > btnY && y < btnY + 30) {
                        buyOrSelect(skin.name);
                    }
                });
            } else if (gameState === 'gameOver') {
                startGame();
            }
        }

        function updateCreds() {
            localStorage.setItem('creds', creds.toString());
        }

        async function setupAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                microphone = audioContext.createMediaStreamSource(stream);
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                const dataArray = new Uint8Array(analyser.frequencyBinCount);
                microphone.connect(analyser);

                function detectBeat() {
                    if (gameState !== 'playing') {
                        rafId = requestAnimationFrame(detectBeat);
                        return;
                    }
                    analyser.getByteFrequencyData(dataArray);
                    let bassEnergy = 0;
                    for (let i = 0; i < 20; i++) bassEnergy += dataArray[i];
                    bassEnergy /= 20;
                    const now = Date.now();
                    if (bassEnergy > beatThreshold * 255 && now - lastBeatTime > beatInterval) {
                        spawnAttack();
                        lastBeatTime = now;
                        score++;
                    }
                    rafId = requestAnimationFrame(detectBeat);
                }
                detectBeat();
            } catch (err) {
                console.error('Mic access denied');
            }
        }

        function showShop() {
            gameState = 'shop';
        }

        function backToMenu() {
            gameState = 'menu';
        }

        function buyOrSelect(skinName) {
            const skin = skins.find(s => s.name === skinName);
            const owned = ownedSkins.includes(skinName);
            if (owned) {
                selectedSkin = skinName;
                localStorage.setItem('selectedSkin', selectedSkin);
            } else if (creds >= skin.price) {
                creds -= skin.price;
                ownedSkins.push(skinName);
                localStorage.setItem('ownedSkins', JSON.stringify(ownedSkins));
                updateCreds();
                selectedSkin = skinName;
                localStorage.setItem('selectedSkin', selectedSkin);
            }
        }

        async function startGame() {
            await setupAudio();
            gameState = 'playing';
            player.x = canvas.width / 2;
            player.y = canvas.height / 2;
            attacks = [];
            score = 0;
            lives = 5;
            lastBeatTime = 0;
            isDashing = false;
            dashCooldown = 0;
            invincibleTime = 0;
            lastSpawn = Date.now();
            if (audioContext) {
                setInterval(() => {
                    if (Date.now() - lastBeatTime > beatInterval * 2) {
                        spawnAttack();
                        score++;
                    }
                }, 600); // Fallback ~100 BPM
            }
            gameLoop();
        }

        function earnCreds() {
            let earned = Math.floor(score / 10) + (score >= 100 ? 50 : 0);
            creds += earned;
            updateCreds();
        }

        function spawnAttack() {
            const types = ['line', 'circle', 'pulse', 'spiral', 'wave', 'burst', 'grid', 'comet', 'vortex'];
            const type = types[Math.floor(Math.random() * types.length)];
            let attack;
            const time = Date.now() / 1000;

            switch (type) {
                case 'line':
                    const side = Math.floor(Math.random() * 4);
                    let x1, y1, x2, y2;
                    switch (side) {
                        case 0: x1 = Math.random() * canvas.width; y1 = 0; x2 = Math.random() * canvas.width; y2 = canvas.height; break;
                        case 1: x1 = canvas.width; y1 = Math.random() * canvas.height; x2 = 0; y2 = Math.random() * canvas.height; break;
                        case 2: x1 = Math.random() * canvas.width; y1 = canvas.height; x2 = Math.random() * canvas.width; y2 = 0; break;
                        case 3: x1 = 0; y1 = Math.random() * canvas.height; x2 = canvas.width; y2 = Math.random() * canvas.height; break;
                    }
                    attack = { type, x1, y1, x2, y2, progress: 0, speed: 2 + Math.random() * 2, color: '#fff' };
                    break;
                case 'circle':
                    const cx = Math.random() * canvas.width;
                    const cy = Math.random() * canvas.height;
                    attack = { type, x: cx, y: cy, radius: 0, maxRadius: 100 + Math.random() * 150, speed: 3 + Math.random() * 3, color: '#fff' };
                    break;
                case 'pulse':
                    attack = { type, x: canvas.width/2, y: canvas.height/2, radius: 0, maxRadius: 300, speed: 5 + Math.random() * 3, color: '#fff' };
                    break;
                case 'spiral':
                    attack = { type, x: canvas.width/2, y: canvas.height/2, radius: 0, angle: 0, speed: 2, arms: 3, color: '#fff' };
                    break;
                case 'wave':
                    attack = { type, x: 0, y: Math.random() * canvas.height, progress: 0, amplitude: 50, speed: 3, color: '#fff' };
                    break;
                case 'burst':
                    attack = { type, x: Math.random() * canvas.width, y: Math.random() * canvas.height, angle: 0, speed: 4, rays: 8, color: '#fff' };
                    break;
                case 'grid':
                    attack = { type, startX: Math.random() * canvas.width, startY: 0, spacing: 50 + Math.random() * 50, speed: 2, color: '#fff' };
                    break;
                case 'comet':
                    const dir = Math.random() * Math.PI * 2;
                    attack = { type, x: Math.random() * canvas.width, y: Math.random() * canvas.height, vx: Math.cos(dir) * 5, vy: Math.sin(dir) * 5, tail: [], color: '#fff' };
                    break;
                case 'vortex':
                    attack = { type, x: canvas.width/2, y: canvas.height/2, radius: 0, angle: 0, speed: 3, pull: 0.1, color: '#fff' };
                    break;
            }
            attacks.push(attack);
        }

        function updatePlayer() {
            if (gameState !== 'playing') return;
            player.vx = 0;
            player.vy = 0;
            if (keys['KeyW'] || keys['ArrowUp']) player.vy = -player.speed;
            if (keys['KeyS'] || keys['ArrowDown']) player.vy = player.speed;
            if (keys['KeyA'] || keys['ArrowLeft']) player.vx = -player.speed;
            if (keys['KeyD'] || keys['ArrowRight']) player.vx = player.speed;

            // Dash on space
            if ((keys['Space'] || keys['Space'] === false) && dashCooldown <= 0 && !isDashing) { // Space triggers
                keys['Space'] = false; // Prevent repeat
                startDash();
            }

            player.x += player.vx;
            player.y += player.vy;
            player.x = Math.max(player.size/2, Math.min(canvas.width - player.size/2, player.x));
            player.y = Math.max(player.size/2, Math.min(canvas.height - player.size/2, player.y));
        }

        function startDash() {
            isDashing = true;
            dashDuration = 200;
            dashCooldown = 2000;
            player.speed *= 2; // Temp speed boost
            setTimeout(() => { player.speed /= 2; }, 200);
        }

        function updateDash() {
            if (isDashing) {
                dashDuration -= 16;
                if (dashDuration <= 0) {
                    isDashing = false;
                    player.speed /= 2;
                }
            }
            if (dashCooldown > 0) dashCooldown -= 16;
        }

        function updateInvincible() {
            if (invincibleTime > 0) {
                invincibleTime -= 16;
                if (invincibleTime <= 0) lives--; // Lose life after invinc
                if (lives <= 0) gameOver();
            }
        }

        function update() {
            if (gameState !== 'playing') return;
            updatePlayer();
            updateDash();
            updateInvincible();
            const now = Date.now();
            if (now - lastSpawn > 500) { // Fallback
                spawnAttack();
                lastSpawn = now;
                score++;
            }

            attacks.forEach((attack, index) => {
                // Update logic for each type
                switch (attack.type) {
                    case 'line':
                        attack.progress += attack.speed / 100;
                        if (attack.progress >= 1) {
                            attacks.splice(index, 1);
                            return;
                        }
                        const currX1 = attack.x1 + (attack.x2 - attack.x1) * attack.progress;
                        const currY1 = attack.y1 + (attack.y2 - attack.y1) * attack.progress;
                        const currX2 = attack.x1 + (attack.x2 - attack.x1) * (attack.progress - 0.05);
                        const currY2 = attack.y1 + (attack.y2 - attack.y1) * (attack.progress - 0.05);
                        const dist = distanceToLine(player.x, player.y, currX1, currY1, currX2, currY2);
                        if (dist < player.size / 2 && invincibleTime <= 0 && !isDashing) {
                            invincibleTime = 2000; // 2s invincible on hit
                        }
                        break;
                    case 'circle':
                        attack.radius += attack.speed;
                        if (attack.radius > attack.maxRadius) {
                            attacks.splice(index, 1);
                            return;
                        }
                        const cdist = Math.hypot(player.x - attack.x, player.y - attack.y);
                        if (cdist < attack.radius + player.size / 2 && invincibleTime <= 0 && !isDashing) {
                            invincibleTime = 2000;
                        }
                        break;
                    case 'pulse':
                        attack.radius += attack.speed;
                        if (attack.radius > attack.maxRadius) {
                            attacks.splice(index, 1);
                            return;
                        }
                        const pdist = Math.hypot(player.x - attack.x, player.y - attack.y);
                        if (pdist < attack.radius + player.size / 2 && invincibleTime <= 0 && !isDashing) {
                            invincibleTime = 2000;
                        }
                        break;
                    case 'spiral':
                        attack.radius += attack.speed;
                        attack.angle += 0.1;
                        if (attack.radius > Math.hypot(canvas.width, canvas.height)) {
                            attacks.splice(index, 1);
                            return;
                        }
                        for (let i = 0; i < attack.arms; i++) {
                            const a = attack.angle + (i / attack.arms) * Math.PI * 2;
                            const ex = attack.x + Math.cos(a) * attack.radius;
                            const ey = attack.y + Math.sin(a) * attack.radius;
                            const distS = Math.hypot(player.x - ex, player.y - ey);
                            if (distS < 5 && invincibleTime <= 0 && !isDashing) {
                                invincibleTime = 2000;
                            }
                        }
                        break;
                    case 'wave':
                        attack.progress += attack.speed / canvas.width;
                        if (attack.progress >= 1) {
                            attacks.splice(index, 1);
                            return;
                        }
                        const wx = attack.progress * canvas.width;
                        const wy = attack.y + Math.sin(wx / 50) * attack.amplitude;
                        const wdist = Math.hypot(player.x - wx, player.y - wy);
                        if (wdist < 10 && invincibleTime <= 0 && !isDashing) {
                            invincibleTime = 2000;
                        }
                        break;
                    case 'burst':
                        attack.angle += attack.speed / 50;
                        if (attack.angle > Math.PI * 2) {
                            attacks.splice(index, 1);
                            return;
                        }
                        for (let i = 0; i < attack.rays; i++) {
                            const a = attack.angle + (i / attack.rays) * Math.PI * 2;
                            const ex = attack.x + Math.cos(a) * 200;
                            const ey = attack.y + Math.sin(a) * 200;
                            const bdist = distanceToLine(player.x, player.y, attack.x, attack.y, ex, ey);
                            if (bdist < 5 && invincibleTime <= 0 && !isDashing) {
                                invincibleTime = 2000;
                            }
                        }
                        break;
                    case 'grid':
                        attack.startY += attack.speed;
                        if (attack.startY > canvas.height) {
                            attacks.splice(index, 1);
                            return;
                        }
                        for (let gx = attack.startX; gx < canvas.width; gx += attack.spacing) {
                            const gdist = distanceToLine(player.x, player.y, gx, 0, gx, canvas.height);
                            if (gdist < 5 && invincibleTime <= 0 && !isDashing) {
                                invincibleTime = 2000;
                            }
                        }
                        break;
                    case 'comet':
                        attack.tail.push({x: attack.x, y: attack.y});
                        if (attack.tail.length > 20) attack.tail.shift();
                        attack.x += attack.vx;
                        attack.y += attack.vy;
                        if (attack.x < 0 || attack.x > canvas.width || attack.y < 0 || attack.y > canvas.height) {
                            attacks.splice(index, 1);
                            return;
                        }
                        // Check tail
                        attack.tail.forEach(p => {
                            const tdist = Math.hypot(player.x - p.x, player.y - p.y);
                            if (tdist < 8 && invincibleTime <= 0 && !isDashing) {
                                invincibleTime = 2000;
                            }
                        });
                        // Head
                        const hdist = Math.hypot(player.x - attack.x, player.y - attack.y);
                        if (hdist < player.size / 2 && invincibleTime <= 0 && !isDashing) {
                            invincibleTime = 2000;
                        }
                        break;
                    case 'vortex':
                        attack.radius += attack.speed;
                        attack.angle += 0.2;
                        if (attack.radius > 200) {
                            attacks.splice(index, 1);
                            return;
                        }
                        const points = 12;
                        for (let i = 0; i < points; i++) {
                            const a = attack.angle + (i / points) * Math.PI * 2;
                            const r = attack.radius * (0.5 + 0.5 * Math.sin(a * 3));
                            const ex = attack.x + Math.cos(a) * r;
                            const ey = attack.y + Math.sin(a) * r;
                            const vdist = Math.hypot(player.x - ex, player.y - ey);
                            if (vdist < 6 && invincibleTime <= 0 && !isDashing) {
                                invincibleTime = 2000;
                            }
                        }
                        break;
                }
            });
        }

        function drawPlayer() {
            const skin = skins.find(s => s.name === selectedSkin);
            ctx.fillStyle = skin.color;
            if (skin.shape === 'square') {
                ctx.fillRect(player.x - player.size/2, player.y - player.size/2, player.size, player.size);
            } else if (skin.shape === 'circle') {
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.size/2, 0, Math.PI * 2);
                ctx.fill();
            } else if (skin.shape === 'star') {
                drawStar(player.x, player.y, player.size/2, 5);
            }
            if (invincibleTime > 0) {
                ctx.fillStyle = 'rgba(255,255,255,0.5)';
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawStar(cx, cy, radius, spikes) {
            ctx.beginPath();
            const rot = Math.PI / 2 * 3;
            const step = Math.PI / spikes;
            ctx.moveTo(cx, cy - radius);
            for (let i = 0; i < spikes; i++) {
                const x = cx + Math.cos(rot + i * step) * radius;
                const y = cy + Math.sin(rot + i * step) * radius;
                ctx.lineTo(x, y);
                const x2 = cx + Math.cos(rot + i * step + step / 2) * (radius / 2);
                const y2 = cy + Math.sin(rot + i * step + step / 2) * (radius / 2);
                ctx.lineTo(x2, y2);
            }
            ctx.closePath();
            ctx.fill();
        }

        function drawUI() {
            ctx.fillStyle = '#fff';
            ctx.font = '16px monospace';
            ctx.fillText(`Score: ${score} | Lives: ${lives} | Creds: ${creds}`, 10, 20);
            ctx.fillText(`Dash: ${dashCooldown > 0 ? Math.ceil(dashCooldown/1000) + 's' : 'Ready'}`, 10, 40);
            if (invincibleTime > 0) {
                ctx.fillText(`Invincible: ${Math.ceil(invincibleTime/1000)}s`, 10, 60);
            }

            if (gameState === 'menu') {
                ctx.fillStyle = '#fff';
                ctx.font = '48px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('Rhythm Dodge', canvas.width/2, canvas.height/2 - 50);
                ctx.font = '24px monospace';
                ctx.fillText('WASD/Arrows: Move | Space: Dash', canvas.width/2, canvas.height/2 + 20);
                // Shop button
                ctx.fillText('Shop', canvas.width/2, canvas.height/2 + 100);
                if (mouseX > canvas.width/2 - 50 && mouseX < canvas.width/2 + 50 && mouseY > canvas.height/2 + 70 && mouseY < canvas.height/2 + 100) {
                    ctx.fillStyle = '#ccc';
                    ctx.fillRect(canvas.width/2 - 50, canvas.height/2 + 70, 100, 30);
                    ctx.fillStyle = '#000';
                    ctx.fillText('Shop', canvas.width/2, canvas.height/2 + 95);
                    ctx.fillStyle = '#fff';
                }
                // Play button
                ctx.fillText('Play', canvas.width/2, canvas.height/2 + 150);
                if (mouseX > canvas.width/2 - 50 && mouseX < canvas.width/2 + 50 && mouseY > canvas.height/2 + 120 && mouseY < canvas.height/2 + 150) {
                    ctx.fillStyle = '#ccc';
                    ctx.fillRect(canvas.width/2 - 50, canvas.height/2 + 120, 100, 30);
                    ctx.fillStyle = '#000';
                    ctx.fillText('Play', canvas.width/2, canvas.height/2 + 145);
                    ctx.fillStyle = '#fff';
                }
                ctx.textAlign = 'left';
            } else if (gameState === 'shop') {
                ctx.fillStyle = '#fff';
                ctx.font = '32px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('Shop', canvas.width/2, 100);
                ctx.font = '18px monospace';
                ctx.textAlign = 'left';
                skins.forEach((skin, i) => {
                    const y = 150 + i * 40;
                    ctx.fillText(`${skin.name} (${skin.shape}) ${ownedSkins.includes(skin.name) ? '' : skin.price}c`, 50, y);
                    // Button
                    const btnX = canvas.width - 150;
                    const btnY = y - 20;
                    const text = ownedSkins.includes(skin.name) ? 'Equip' : 'Buy';
                    ctx.fillText(text, btnX, btnY + 15);
                    if (mouseX > btnX - 10 && mouseX < btnX + 50 && mouseY > btnY && mouseY < btnY + 25) {
                        ctx.fillStyle = '#ccc';
                        ctx.fillRect(btnX - 10, btnY, 60, 25);
                        ctx.fillStyle = '#000';
                        ctx.fillText(text, btnX, btnY + 15);
                        ctx.fillStyle = '#fff';
                    }
                });
                // Back
                ctx.textAlign = 'center';
                ctx.fillText('Back', canvas.width/2, canvas.height - 40);
                if (mouseX > canvas.width/2 - 50 && mouseX < canvas.width/2 + 50 && mouseY > canvas.height - 60 && mouseY < canvas.height - 30) {
                    ctx.fillStyle = '#ccc';
                    ctx.fillRect(canvas.width/2 - 50, canvas.height - 60, 100, 30);
                    ctx.fillStyle = '#000';
                    ctx.fillText('Back', canvas.width/2, canvas.height - 45);
                    ctx.fillStyle = '#fff';
                }
                ctx.textAlign = 'left';
            } else if (gameState === 'gameOver') {
                ctx.fillStyle = '#fff';
                ctx.font = '48px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('Game Over', canvas.width/2, canvas.height/2);
                ctx.font = '24px monospace';
                ctx.fillText(`Score: ${score}`, canvas.width/2, canvas.height/2 + 50);
                ctx.fillText(`Creds Earned: ${Math.floor(score / 10) + (score >= 100 ? 50 : 0)}`, canvas.width/2, canvas.height/2 + 80);
                ctx.fillText('Click to Restart', canvas.width/2, canvas.height/2 + 120);
                ctx.textAlign = 'left';
            }
        }

        function drawAttacks() {
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            attacks.forEach(attack => {
                switch (attack.type) {
                    case 'line':
                        const currX1 = attack.x1 + (attack.x2 - attack.x1) * attack.progress;
                        const currY1 = attack.y1 + (attack.y2 - attack.y1) * attack.progress;
                        const currX2 = attack.x1 + (attack.x2 - attack.x1) * (attack.progress - 0.05);
                        const currY2 = attack.y1 + (attack.y2 - attack.y1) * (attack.progress - 0.05);
                        ctx.beginPath();
                        ctx.moveTo(currX1, currY1);
                        ctx.lineTo(currX2, currY2);
                        ctx.stroke();
                        break;
                    case 'circle':
                        ctx.beginPath();
                        ctx.arc(attack.x, attack.y, attack.radius, 0, Math.PI * 2);
                        ctx.stroke();
                        break;
                    case 'pulse':
                        ctx.beginPath();
                        ctx.arc(attack.x, attack.y, attack.radius, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.arc(attack.x, attack.y, attack.radius * 0.6, 0, Math.PI * 2);
                        ctx.stroke();
                        break;
                    case 'spiral':
                        for (let i = 0; i < attack.arms; i++) {
                            const a = attack.angle + (i / attack.arms) * Math.PI * 2;
                            ctx.beginPath();
                            ctx.arc(attack.x, attack.y, attack.radius, a, a + Math.PI * 2 / attack.arms);
                            ctx.stroke();
                        }
                        break;
                    case 'wave':
                        const wx = attack.progress * canvas.width;
                        ctx.beginPath();
                        ctx.moveTo(0, attack.y);
                        for (let i = 0; i < canvas.width; i += 10) {
                            const waveY = attack.y + Math.sin((i + wx) / 50) * attack.amplitude;
                            ctx.lineTo(i, waveY);
                        }
                        ctx.stroke();
                        break;
                    case 'burst':
                        for (let i = 0; i < attack.rays; i++) {
                            const a = attack.angle + (i / attack.rays) * Math.PI * 2;
                            const ex = attack.x + Math.cos(a) * 200;
                            const ey = attack.y + Math.sin(a) * 200;
                            ctx.beginPath();
                            ctx.moveTo(attack.x, attack.y);
                            ctx.lineTo(ex, ey);
                            ctx.stroke();
                        }
                        break;
                    case 'grid':
                        for (let gx = attack.startX; gx < canvas.width; gx += attack.spacing) {
                            ctx.beginPath();
                            ctx.moveTo(gx, 0);
                            ctx.lineTo(gx, canvas.height);
                            ctx.stroke();
                        }
                        break;
                    case 'comet':
                        ctx.beginPath();
                        attack.tail.forEach((p, i) => {
                            ctx.globalAlpha = i / attack.tail.length;
                            ctx.lineTo(p.x, p.y);
                        });
                        ctx.lineTo(attack.x, attack.y);
                        ctx.stroke();
                        ctx.globalAlpha = 1;
                        break;
                    case 'vortex':
                        const points = 12;
                        ctx.beginPath();
                        for (let i = 0; i < points; i++) {
                            const a = attack.angle + (i / points) * Math.PI * 2;
                            const r = attack.radius * (0.5 + 0.5 * Math.sin(a * 3));
                            const ex = attack.x + Math.cos(a) * r;
                            const ey = attack.y + Math.sin(a) * r;
                            if (i === 0) ctx.moveTo(ex, ey);
                            else ctx.lineTo(ex, ey);
                        }
                        ctx.closePath();
                        ctx.stroke();
                        break;
                }
            });
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (gameState === 'playing') {
                drawAttacks();
                drawPlayer();
                drawUI();
            } else {
                drawUI();
            }
        }

        function gameLoop() {
            if (gameState === 'playing') {
                update();
                draw();
                requestAnimationFrame(gameLoop);
            } else {
                draw();
            }
        }

        function gameOver() {
            gameState = 'gameOver';
            if (audioContext) cancelAnimationFrame(rafId);
            earnCreds();
        }

        function distanceToLine(px, py, x1, y1, x2, y2) {
            const A = px - x1; const B = py - y1; const C = x2 - x1; const D = y2 - y1;
            const dot = A * C + B * D; const lenSq = C * C + D * D;
            if (lenSq === 0) return Math.hypot(A, B);
            const param = dot / lenSq; const xx = x1 + Math.max(0, Math.min(1, param)) * C;
            const yy = y1 + Math.max(0, Math.min(1, param)) * D;
            return Math.hypot(px - xx, py - yy);
        }

        // Init
        draw();
    </script>
</body>
</html>
