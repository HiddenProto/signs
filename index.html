<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alternate's Magical Evolution</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #000;
            color: #fff;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 1px solid #fff;
            background-color: #111;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
        }
        #spells {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border: 1px solid #fff;
            width: 150px;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            font-size: 12px;
            opacity: 0.7;
        }
        #levelUp {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border: 1px solid #fff;
            display: none;
            text-align: center;
        }
        button {
            margin: 5px;
            padding: 10px;
            background: #333;
            color: #fff;
            border: 1px solid #fff;
            cursor: pointer;
        }
        button:hover {
            background: #555;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="ui">
        <div>Health: <span id="health">100</span>/100</div>
        <div>Mana: <span id="mana">100</span>/100</div>
        <div>Level: <span id="level">1</span></div>
        <div>XP: <span id="xp">0</span>/<span id="nextLevel">100</span></div>
    </div>
    <div id="spells">
        <h3>Spells</h3>
        <div>Mouse Click: Fireball (CD: <span id="cdFire">0</span>s)</div>
        <div>A: Beam (CD: <span id="cdBeam">0</span>s)</div>
        <div>S: Ice Shard (CD: <span id="cdIce">0</span>s)</div>
        <div>D: Lightning (CD: <span id="cdLightning">0</span>s)</div>
    </div>
    <div id="controls">
        Movement: WASD or Arrow Keys. Aim with mouse.
    </div>
    <div id="levelUp">
        <h2>Level Up! Choose an upgrade:</h2>
        <button onclick="upgrade('fire')">Fireball + Damage</button>
        <button onclick="upgrade('ice')">Ice Shard + Slow</button>
        <button onclick="upgrade('lightning')">Lightning + Chain</button>
        <button onclick="upgrade('beam')">Beam + Pierce</button>
        <p id="upgradeDesc"></p>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const uiHealth = document.getElementById('health');
        const uiMana = document.getElementById('mana');
        const uiLevel = document.getElementById('level');
        const uiXP = document.getElementById('xp');
        const uiNext = document.getElementById('nextLevel');
        const cdFire = document.getElementById('cdFire');
        const cdBeam = document.getElementById('cdBeam');
        const cdIce = document.getElementById('cdIce');
        const cdLightning = document.getElementById('cdLightning');
        const levelUpDiv = document.getElementById('levelUp');

        // Game state
        let gameState = {
            player: {
                x: 400,
                y: 300,
                width: 20,
                height: 20,
                health: 100,
                maxHealth: 100,
                mana: 100,
                maxMana: 100,
                speed: 3,
                level: 1,
                xp: 0,
                xpToNext: 100,
                spells: {
                    fire: { damage: 20, cost: 20, cooldown: 0, maxCd: 500 },
                    beam: { damage: 30, cost: 30, cooldown: 0, maxCd: 1500 },
                    ice: { damage: 15, cost: 15, cooldown: 0, maxCd: 800 },
                    lightning: { damage: 25, cost: 25, cooldown: 0, maxCd: 1000 }
                }
            },
            enemies: [],
            projectiles: [],
            beams: [], // For beam spells
            enemyProjectiles: [],
            particles: [],
            keys: {},
            mouseX: 0,
            mouseY: 0,
            lastTime: 0,
            gameOver: false,
            paused: false
        };

        // Load save
        function loadSave() {
            const saved = localStorage.getItem('alternateSave');
            if (saved) {
                const data = JSON.parse(saved);
                gameState.player = { ...gameState.player, ...data.player };
                generateEnemies(gameState.player.level);
            }
        }

        // Save game
        function saveGame() {
            localStorage.setItem('alternateSave', JSON.stringify(gameState));
        }

        // Generate unique enemies based on level with improved AI
        function generateEnemies(level) {
            gameState.enemies = [];
            const numEnemies = Math.min(1 + Math.floor(level / 2), 5);
            for (let i = 0; i < numEnemies; i++) {
                const enemy = {
                    x: Math.random() * (canvas.width - 40) + 20,
                    y: Math.random() * (canvas.height - 40) + 20,
                    width: 20,
                    height: 20,
                    health: 50 + level * 20,
                    maxHealth: 50 + level * 20,
                    speed: 1 + level * 0.2,
                    attackDamage: 10 + level * 5,
                    color: `hsl(${level * 30}, 70%, 50%)`,
                    type: ['Fire Mage', 'Ice Sorcerer', 'Shadow Warlock', 'Storm Caller', 'Arcane Beast'][level % 5],
                    lastAttack: 0,
                    attackCooldown: 2000 - level * 50,
                    lastSpell: 0,
                    spellCooldown: 3000 - level * 100,
                    aiState: 'chase', // chase, dodge, cast
                    dodgeDir: { x: 0, y: 0 }
                };
                gameState.enemies.push(enemy);
            }
        }

        // Input handling
        window.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            gameState.keys[key] = true;
            if (key === 'r') restart();
            // Spell casting on key press
            if (key === 'a' && !gameState.gameOver && !gameState.paused) castSpell('beam');
            if (key === 's' && !gameState.gameOver && !gameState.paused) castSpell('ice');
            if (key === 'd' && !gameState.gameOver && !gameState.paused) castSpell('lightning');
        });
        window.addEventListener('keyup', (e) => {
            gameState.keys[e.key.toLowerCase()] = false;
        });
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            gameState.mouseX = e.clientX - rect.left;
            gameState.mouseY = e.clientY - rect.top;
        });
        canvas.addEventListener('click', (e) => {
            if (!gameState.gameOver && !gameState.paused) castSpell('fire');
        });

        function castSpell(type) {
            const spell = gameState.player.spells[type];
            if (!spell || gameState.player.mana < spell.cost || spell.cooldown > 0) return;

            const dx = gameState.mouseX - gameState.player.x;
            const dy = gameState.mouseY - gameState.player.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx);

            if (type === 'beam') {
                // Beam: line from player to mouse, instant damage to enemies in line
                gameState.beams.push({
                    startX: gameState.player.x,
                    startY: gameState.player.y,
                    endX: gameState.mouseX,
                    endY: gameState.mouseY,
                    damage: spell.damage,
                    life: 200 // ms duration
                });
                // Damage enemies along the beam
                gameState.enemies.forEach(enemy => {
                    if (lineIntersectsRect(gameState.player.x, gameState.player.y, gameState.mouseX, gameState.mouseY, enemy.x - 10, enemy.y - 10, 20, 20)) {
                        enemy.health -= spell.damage;
                        // Particles
                        for (let p = 0; p < 10; p++) {
                            gameState.particles.push({
                                x: enemy.x,
                                y: enemy.y,
                                vx: (Math.random() - 0.5) * 6,
                                vy: (Math.random() - 0.5) * 6,
                                life: 300,
                                color: 'beam'
                            });
                        }
                        if (enemy.health <= 0) addXP(50 + gameState.player.level * 10);
                    }
                });
            } else {
                // Projectile spells
                const velX = (dx / dist) * 8;
                const velY = (dy / dist) * 8;
                gameState.projectiles.push({
                    x: gameState.player.x,
                    y: gameState.player.y,
                    vx: velX,
                    vy: velY,
                    width: 5,
                    height: 5,
                    damage: spell.damage,
                    type: type,
                    life: 1000
                });
            }

            gameState.player.mana -= spell.cost;
            spell.cooldown = spell.maxCd;
            updateUI();
        }

        // Helper: Check if line intersects rect
        function lineIntersectsRect(x1, y1, x2, y2, rx, ry, rw, rh) {
            const left = lineSide(x1, y1, x2, y2, rx, ry) * lineSide(x1, y1, x2, y2, rx + rw, ry);
            const right = lineSide(x1, y1, x2, y2, rx, ry + rh) * lineSide(x1, y1, x2, y2, rx + rw, ry + rh);
            const top = lineSide(x1, y1, x2, y2, rx, ry) * lineSide(x1, y1, x2, y2, rx, ry + rh);
            const bottom = lineSide(x1, y1, x2, y2, rx + rw, ry) * lineSide(x1, y1, x2, y2, rx + rw, ry + rh);
            return (left <= 0 && right <= 0 && top <= 0 && bottom <= 0) || (left === 0 || right === 0 || top === 0 || bottom === 0);
        }

        function lineSide(x1, y1, x2, y2, x, y) {
            return (y1 - y2) * (x - x2) + (x2 - x1) * (y - y2);
        }

        function updatePlayer(dt) {
            // Movement: WASD or Arrows
            const up = gameState.keys['w'] || gameState.keys['arrowup'];
            const down = gameState.keys['s'] || gameState.keys['arrowdown'];
            const left = gameState.keys['a'] || gameState.keys['arrowleft'];
            const right = gameState.keys['d'] || gameState.keys['arrowright'];

            if (up && gameState.player.y > 10) gameState.player.y -= gameState.player.speed * dt * 60;
            if (down && gameState.player.y < canvas.height - 30) gameState.player.y += gameState.player.speed * dt * 60;
            if (left && gameState.player.x > 10) gameState.player.x -= gameState.player.speed * dt * 60;
            if (right && gameState.player.x < canvas.width - 30) gameState.player.x += gameState.player.speed * dt * 60;

            // Regen mana
            gameState.player.mana = Math.min(gameState.player.maxMana, gameState.player.mana + dt * 20);
            // Cooldowns
            Object.values(gameState.player.spells).forEach(s => s.cooldown = Math.max(0, s.cooldown - dt * 1000));

            // Keep in bounds
            gameState.player.x = Math.max(10, Math.min(canvas.width - 30, gameState.player.x));
            gameState.player.y = Math.max(10, Math.min(canvas.height - 30, gameState.player.y));
        }

        function updateEnemies(dt) {
            gameState.enemies.forEach((enemy, idx) => {
                const dx = gameState.player.x - enemy.x;
                const dy = gameState.player.y - enemy.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // Improved AI: Chase, occasionally dodge or cast
                if (Date.now() - enemy.lastSpell > enemy.spellCooldown) {
                    enemy.aiState = 'cast';
                    // Enemy casts a projectile towards player
                    const velX = (dx / dist) * 5;
                    const velY = (dy / dist) * 5;
                    gameState.enemyProjectiles.push({
                        x: enemy.x,
                        y: enemy.y,
                        vx: velX,
                        vy: velY,
                        width: 5,
                        height: 5,
                        damage: enemy.attackDamage,
                        life: 1000,
                        color: enemy.color
                    });
                    enemy.lastSpell = Date.now();
                    enemy.aiState = 'chase';
                } else if (Math.random() < 0.01 * (1 + gameState.player.level)) { // Dodge chance increases with level
                    enemy.aiState = 'dodge';
                    enemy.dodgeDir.x = (Math.random() - 0.5) * 2;
                    enemy.dodgeDir.y = (Math.random() - 0.5) * 2;
                } else {
                    enemy.aiState = 'chase';
                }

                if (enemy.aiState === 'chase' && dist > 30) {
                    enemy.x += (dx / dist) * enemy.speed * dt * 60;
                    enemy.y += (dy / dist) * enemy.speed * dt * 60;
                } else if (enemy.aiState === 'dodge') {
                    enemy.x += enemy.dodgeDir.x * enemy.speed * 2 * dt * 60;
                    enemy.y += enemy.dodgeDir.y * enemy.speed * 2 * dt * 60;
                    if (Math.random() < 0.1) enemy.aiState = 'chase'; // Stop dodging
                }

                // Melee attack if close
                if (dist < 30 && Date.now() - enemy.lastAttack > enemy.attackCooldown) {
                    gameState.player.health -= enemy.attackDamage;
                    enemy.lastAttack = Date.now();
                    if (gameState.player.health <= 0) {
                        gameOver();
                    }
                    updateUI();
                }

                // Death
                if (enemy.health <= 0) {
                    gameState.enemies.splice(idx, 1);
                    addXP(50 + gameState.player.level * 10);
                }
            });

            if (gameState.enemies.length === 0) {
                levelUp();
            }
        }

        function updateProjectiles(dt) {
            // Player projectiles
            gameState.projectiles.forEach((proj, idx) => {
                proj.x += proj.vx * dt * 60;
                proj.y += proj.vy * dt * 60;
                proj.life -= dt * 1000;

                // Collision with enemies
                gameState.enemies.forEach(enemy => {
                    if (proj.x > enemy.x - 10 && proj.x < enemy.x + 30 &&
                        proj.y > enemy.y - 10 && proj.y < enemy.y + 30) {
                        enemy.health -= proj.damage;
                        gameState.projectiles.splice(idx, 1);
                        for (let p = 0; p < 5; p++) {
                            gameState.particles.push({
                                x: proj.x,
                                y: proj.y,
                                vx: (Math.random() - 0.5) * 4,
                                vy: (Math.random() - 0.5) * 4,
                                life: 500,
                                color: proj.type
                            });
                        }
                        if (proj.type === 'lightning') {
                            // Chain to nearby enemy
                            gameState.enemies.forEach(other => {
                                if (other !== enemy && Math.sqrt((other.x - enemy.x)**2 + (other.y - enemy.y)**2) < 50) {
                                    other.health -= proj.damage * 0.5;
                                    for (let p = 0; p < 3; p++) {
                                        gameState.particles.push({
                                            x: other.x,
                                            y: other.y,
                                            vx: (Math.random() - 0.5) * 4,
                                            vy: (Math.random() - 0.5) * 4,
                                            life: 500,
                                            color: 'lightning'
                                        });
                                    }
                                }
                            });
                        }
                    }
                });

                if (proj.x < 0 || proj.x > canvas.width || proj.y < 0 || proj.y > canvas.height || proj.life <= 0) {
                    gameState.projectiles.splice(idx, 1);
                }
            });

            // Enemy projectiles
            gameState.enemyProjectiles.forEach((proj, idx) => {
                proj.x += proj.vx * dt * 60;
                proj.y += proj.vy * dt * 60;
                proj.life -= dt * 1000;

                // Collision with player
                if (proj.x > gameState.player.x - 10 && proj.x < gameState.player.x + 30 &&
                    proj.y > gameState.player.y - 10 && proj.y < gameState.player.y + 30) {
                    gameState.player.health -= proj.damage;
                    gameState.enemyProjectiles.splice(idx, 1);
                    if (gameState.player.health <= 0) gameOver();
                    updateUI();
                }

                if (proj.x < 0 || proj.x > canvas.width || proj.y < 0 || proj.y > canvas.height || proj.life <= 0) {
                    gameState.enemyProjectiles.splice(idx, 1);
                }
            });
        }

        function updateBeams(dt) {
            gameState.beams.forEach((beam, idx) => {
                beam.life -= dt * 1000;
                if (beam.life <= 0) {
                    gameState.beams.splice(idx, 1);
                }
            });
        }

        function updateParticles(dt) {
            gameState.particles.forEach((part, idx) => {
                part.x += part.vx * dt * 60;
                part.y += part.vy * dt * 60;
                part.life -= dt * 1000;
                if (part.life <= 0) {
                    gameState.particles.splice(idx, 1);
                }
            });
        }

        function addXP(amount) {
            gameState.player.xp += amount;
            while (gameState.player.xp >= gameState.player.xpToNext) {
                gameState.player.xp -= gameState.player.xpToNext;
                gameState.player.level++;
                gameState.player.xpToNext = Math.floor(gameState.player.xpToNext * 1.5);
                gameState.player.maxHealth += 20;
                gameState.player.health = gameState.player.maxHealth;
                gameState.player.maxMana += 20;
                gameState.player.mana = gameState.player.maxMana;
                gameState.player.speed += 0.2;
                showLevelUp();
            }
            updateUI();
            saveGame();
        }

        function levelUp() {
            addXP(100); // Bonus for clearing wave
            generateEnemies(gameState.player.level);
        }

        function showLevelUp() {
            gameState.paused = true;
            levelUpDiv.style.display = 'block';
            document.getElementById('upgradeDesc').innerHTML = `Level ${gameState.player.level} unlocked! Progression enhanced.`;
        }

        window.upgrade = function(type) {
            const spell = gameState.player.spells[type];
            if (spell) {
                spell.damage += 10;
                spell.cost += 5;
                spell.maxCd = Math.max(200, spell.maxCd - 50);
            }
            levelUpDiv.style.display = 'none';
            gameState.paused = false;
            saveGame();
        };

        function gameOver() {
            gameState.gameOver = true;
            alert('Game Over! Alternate has fallen. Press R to restart.');
            saveGame();
        }

        function restart() {
            gameState = {
                player: {
                    x: 400, y: 300, width: 20, height: 20,
                    health: 100, maxHealth: 100,
                    mana: 100, maxMana: 100,
                    speed: 3,
                    level: 1, xp: 0, xpToNext: 100,
                    spells: {
                        fire: { damage: 20, cost: 20, cooldown: 0, maxCd: 500 },
                        beam: { damage: 30, cost: 30, cooldown: 0, maxCd: 1500 },
                        ice: { damage: 15, cost: 15, cooldown: 0, maxCd: 800 },
                        lightning: { damage: 25, cost: 25, cooldown: 0, maxCd: 1000 }
                    }
                },
                enemies: [],
                projectiles: [],
                beams: [],
                enemyProjectiles: [],
                particles: [],
                keys: {},
                mouseX: 0, mouseY: 0,
                lastTime: 0,
                gameOver: false,
                paused: false
            };
            generateEnemies(1);
            updateUI();
            localStorage.removeItem('alternateSave');
        }

        function updateUI() {
            uiHealth.textContent = Math.floor(gameState.player.health);
            uiMana.textContent = Math.floor(gameState.player.mana);
            uiLevel.textContent = gameState.player.level;
            uiXP.textContent = Math.floor(gameState.player.xp);
            uiNext.textContent = gameState.player.xpToNext;

            // Cooldown displays
            cdFire.textContent = (gameState.player.spells.fire.cooldown / 1000).toFixed(1);
            cdBeam.textContent = (gameState.player.spells.beam.cooldown / 1000).toFixed(1);
            cdIce.textContent = (gameState.player.spells.ice.cooldown / 1000).toFixed(1);
            cdLightning.textContent = (gameState.player.spells.lightning.cooldown / 1000).toFixed(1);
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw player
            ctx.fillStyle = '#00f';
            ctx.fillRect(gameState.player.x - 10, gameState.player.y - 10, 20, 20);
            ctx.fillStyle = '#f0f';
            ctx.fillRect(gameState.player.x - 5, gameState.player.y - 25, 10, 15);

            // Draw enemies
            gameState.enemies.forEach(enemy => {
                ctx.fillStyle = enemy.color;
                ctx.fillRect(enemy.x - 10, enemy.y - 10, 20, 20);
                ctx.fillStyle = '#f00';
                ctx.fillRect(enemy.x - 10, enemy.y - 25, 20, 3);
                ctx.fillStyle = '#0f0';
                ctx.fillRect(enemy.x - 10, enemy.y - 25, (enemy.health / enemy.maxHealth) * 20, 3);
            });

            // Draw player projectiles
            gameState.projectiles.forEach(proj => {
                ctx.fillStyle = proj.type === 'fire' ? '#f00' : proj.type === 'ice' ? '#0ff' : proj.type === 'lightning' ? '#ff0' : '#fff';
                ctx.fillRect(proj.x - 2.5, proj.y - 2.5, 5, 5);
            });

            // Draw enemy projectiles
            gameState.enemyProjectiles.forEach(proj => {
                ctx.fillStyle = proj.color;
                ctx.fillRect(proj.x - 2.5, proj.y - 2.5, 5, 5);
            });

            // Draw beams
            gameState.beams.forEach(beam => {
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(beam.startX, beam.startY);
                ctx.lineTo(beam.endX, beam.endY);
                ctx.stroke();
            });

            // Draw particles
            gameState.particles.forEach(part => {
                ctx.fillStyle = part.color === 'fire' ? '#f80' : part.color === 'ice' ? '#0ff' : part.color === 'lightning' ? '#ff0' : '#fff';
                ctx.globalAlpha = part.life / 500;
                ctx.fillRect(part.x - 2, part.y - 2, 4, 4);
                ctx.globalAlpha = 1;
            });

            // Aim line
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(gameState.player.x, gameState.player.y);
            ctx.lineTo(gameState.mouseX, gameState.mouseY);
            ctx.stroke();

            if (gameState.gameOver || gameState.paused) {
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#fff';
                ctx.font = '30px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(gameState.gameOver ? 'Game Over' : 'Paused', canvas.width / 2, canvas.height / 2);
            }
        }

        function gameLoop(currentTime) {
            const dt = (currentTime - gameState.lastTime) / 1000;
            gameState.lastTime = currentTime;

            if (!gameState.gameOver && !gameState.paused) {
                updatePlayer(dt);
                updateEnemies(dt);
                updateProjectiles(dt);
                updateBeams(dt);
                updateParticles(dt);
                updateUI();
            }

            draw();
            requestAnimationFrame(gameLoop);
        }

        // Init
        loadSave();
        if (gameState.enemies.length === 0) generateEnemies(gameState.player.level);
        updateUI();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
