<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alternate's Magical Evolution</title>
    <style>
        body {
            margin: 0;
            background: black;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 1px solid white;
            background: black;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const CW = 800;
        const CH = 600;
        const CX = 400;
        const CY = 300;

        let gameState = 'menu';
        let player;
        let enemies = [];
        let projectiles = [];
        let particles = [];
        let beams = []; // for lasting beams
        let wave = 1;
        let kills = 0;
        let gameTime = 0;
        let shake = 0;
        let upgrades = []; // for level up

        let keys = {};
        let mouse = { x: CX, y: CY, down: false };

        // Attack definitions
        const ATTACKS = {
            1: { name: 'Magic Shot', unlocked: true, cd: 200, lastUse: 0, mana: 5, damage: 20, type: 'projectile', color: 'orange', size: 5, speed: 5, homing: 0.01, bounces: 0 },
            2: { name: 'Tri-Shot', unlocked: false, cd: 300, lastUse: 0, mana: 10, damage: 15, type: 'spread', count: 3, angle: 0.3, color: 'blue', size: 4, speed: 4 },
            3: { name: 'Beam Shot', unlocked: false, cd: 500, lastUse: 0, mana: 15, damage: 30, type: 'beam', color: 'white', thickness: 2, speed: 10, pierce: true, stun: 1000 },
            4: { name: 'Ice Shard', unlocked: false, cd: 400, lastUse: 0, mana: 12, damage: 18, type: 'projectile', color: 'cyan', size: 6, speed: 4, effect: 'slow', effectDur: 2000, effectVal: 0.5 },
            5: { name: 'Lightning', unlocked: false, cd: 800, lastUse: 0, mana: 20, damage: 25, type: 'lightning', color: 'yellow', size: 3, speed: 8, chains: 0, chainRange: 80, dot: false, dotDur: 0 },
            6: { name: 'Curve Shot', unlocked: false, cd: 350, lastUse: 0, mana: 8, damage: 22, type: 'projectile', color: 'green', size: 5, speed: 4, homing: 0.05 },
            7: { name: 'Shield Breaker', unlocked: false, cd: 600, lastUse: 0, mana: 18, damage: 10, type: 'aoe', radius: 50, color: 'purple', break: 50, pierce: false },
            8: { name: 'Homing Missile', unlocked: false, cd: 700, lastUse: 0, mana: 25, damage: 40, type: 'projectile', color: 'red', size: 8, speed: 3, homing: 0.1, explode: false, explodeRad: 40 },
            9: { name: 'Force Wave', unlocked: false, cd: 500, lastUse: 0, mana: 15, damage: 20, type: 'cone', count: 7, angle: 0.5, color: 'blue', size: 3, speed: 6, knockback: 50 },
            10: { name: 'Penta Shot', unlocked: false, cd: 150, lastUse: 0, mana: 12, damage: 12, type: 'spread', count: 5, angle: 0.4, color: 'lightblue', size: 3, speed: 5 },
            11: { name: 'Recursive Shot', unlocked: false, cd: 900, lastUse: 0, mana: 30, damage: 35, type: 'projectile', color: 'magenta', size: 6, speed: 5, bounces: 3, homing: 0 },
            12: { name: 'Shield Attack', unlocked: false, cd: 400, lastUse: 0, mana: 20, damage: 25, type: 'projectile', color: 'gold', size: 10, speed: 4, ignoreShield: true, reflect: true },
            13: { name: 'Beta Laser', unlocked: false, cd: 1200, lastUse: 0, mana: 50, damage: 60, type: 'beam', color: 'red', thickness: 6, speed: 0, duration: 3000, dot: true, dotDur: 3000, dotDmg: 10 },
            14: { name: 'Super Speed', unlocked: false, cd: 10000, lastUse: 0, mana: 40, damage: 0, type: 'buff', duration: 5000, speedMult: 2, invuln: false }
        };

        class Player {
            constructor() {
                this.reset();
                this.attacks = { ...ATTACKS };
                for (let id in this.attacks) {
                    if (!this.attacks[id].unlocked) this.attacks[id].unlocked = this.unlocks.has(id);
                }
            }
            reset() {
                this.x = CX;
                this.y = CY;
                this.health = 100;
                this.maxHealth = 100;
                this.mana = 100;
                this.maxMana = 100;
                this.manaRegen = 0.33; // ~20/sec at 60fps
                this.speed = 3;
                this.pl = 1;
                this.atk = 20;
                this.def = 10;
                this.level = 1;
                this.xp = 0;
                this.nextLevelXp = 100;
                this.unlocks = new Set(['1']);
                this.selectedAttack = 1;
                this.shielding = false;
                this.shieldStrength = 100;
                this.shieldMax = 100;
                this.shieldYield = 1.0;
                this.shieldRadius = 40;
                this.omniShield = false;
                this.speedBuffEnd = 0;
                this.invulnEnd = 0;
            }
            update(dt) {
                this.mana = Math.min(this.maxMana, this.mana + this.manaRegen * dt);
                if (this.invulnEnd > Date.now()) {} else this.invulnEnd = 0;
                if (this.speedBuffEnd > Date.now()) {
                    this.speed = 3 * 2;
                } else {
                    this.speed = 3;
                }
                if (!this.shielding) {
                    this.shieldStrength = Math.min(this.shieldMax, this.shieldStrength + 0.5 * dt);
                }
                let speed = this.speed * (this.speedBuffEnd > Date.now() ? 2 : 1);
                if (keys['w'] || keys['ArrowUp']) this.y = Math.max(0, this.y - speed);
                if (keys['s'] || keys['ArrowDown']) this.y = Math.min(CH, this.y + speed);
                if (keys['a'] || keys['ArrowLeft']) this.x = Math.max(0, this.x - speed);
                if (keys['d'] || keys['ArrowRight']) this.x = Math.min(CW, this.x + speed);
                if (this.pl === 16 && shake > 0) shake--;
            }
            draw(ctx, t) {
                let ox = 0, oy = 0;
                if (this.pl === 16 && shake > 0) {
                    ox = (Math.random() - 0.5) * 5;
                    oy = (Math.random() - 0.5) * 5;
                }
                ctx.save();
                ctx.translate(ox, oy);
                ctx.strokeStyle = 'blue';
                ctx.lineWidth = 2;
                // head
                ctx.beginPath();
                ctx.arc(this.x, this.y - 40, 8, 0, Math.PI * 2);
                ctx.stroke();
                // hat
                ctx.fillStyle = 'purple';
                ctx.beginPath();
                ctx.moveTo(this.x - 10, this.y - 48);
                ctx.lineTo(this.x + 10, this.y - 48);
                ctx.lineTo(this.x, this.y - 60);
                ctx.closePath();
                ctx.fill();
                // body
                ctx.strokeStyle = 'blue';
                ctx.beginPath();
                ctx.moveTo(this.x, this.y - 32);
                ctx.lineTo(this.x, this.y + 20);
                ctx.stroke();
                // arms sway
                let armSway = Math.sin(t * 0.01) * 10;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y - 20);
                ctx.lineTo(this.x - 15 + armSway, this.y);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(this.x, this.y - 20);
                ctx.lineTo(this.x + 15 - armSway, this.y);
                ctx.stroke();
                // legs
                let legSway = Math.sin(t * 0.01 + Math.PI) * 8;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y + 20);
                ctx.lineTo(this.x - 8 + legSway, this.y + 40);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(this.x, this.y + 20);
                ctx.lineTo(this.x + 8 - legSway, this.y + 40);
                ctx.stroke();
                // shield
                if (this.shielding && this.shieldStrength > 0) {
                    let rad = this.shieldRadius + (this.omniShield ? 20 : 0);
                    ctx.strokeStyle = `rgba(0,255,0,0.5)`;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, rad, 0, Math.PI * 2);
                    ctx.stroke();
                    let pulse = Math.sin(t * 0.02) * 5;
                    ctx.lineWidth = 3 + pulse;
                    ctx.stroke();
                    ctx.lineWidth = 2;
                }
                ctx.restore();
            }
            fire() {
                let id = this.selectedAttack;
                let atk = this.attacks[id];
                if (!atk.unlocked || Date.now() - atk.lastUse < atk.cd || this.mana < atk.mana) return;
                this.mana -= atk.mana;
                atk.lastUse = Date.now();
                let dx = mouse.x - this.x;
                let dy = mouse.y - this.y;
                let dist = Math.sqrt(dx * dx + dy * dy) || 1;
                let dirX = dx / dist;
                let dirY = dy / dist;
                let potency = 1 + this.pl / 16;
                let dmg = atk.damage * potency * this.atk / 20;
                switch (atk.type) {
                    case 'projectile':
                    case 'spread':
                    case 'cone':
                        let count = atk.count || 1;
                        let angleSpan = atk.angle || 0;
                        for (let i = 0; i < count; i++) {
                            let angle = (i - (count - 1) / 2) * angleSpan;
                            let cosA = Math.cos(angle);
                            let sinA = Math.sin(angle);
                            let vx = (cosA * dirX - sinA * dirY) * atk.speed;
                            let vy = (sinA * dirX + cosA * dirY) * atk.speed;
                            projectiles.push({
                                x: this.x, y: this.y, vx, vy, dmg, color: atk.color, size: atk.size || 5,
                                owner: 'player', type: atk.name, homing: atk.homing * this.pl, bounces: atk.bounces,
                                ignoreShield: atk.ignoreShield, reflect: atk.reflect, knockback: atk.knockback,
                                effect: atk.effect, effectDur: atk.effectDur, effectVal: atk.effectVal,
                                explode: atk.explode, explodeRad: atk.explodeRad, chain: atk.chain, chainRange: atk.chainRange,
                                zigZag: atk.type === 'lightning', dot: atk.dot, dotDur: atk.dotDur, dotDmg: atk.dotDmg * potency
                            });
                        }
                        if (atk.type === 'cone') {
                            for (let p of projectiles.slice(-count)) {
                                p.knockback = atk.knockback;
                            }
                        }
                        break;
                    case 'beam':
                        beams.push({
                            startX: this.x, startY: this.y, endX: mouse.x, endY: mouse.y,
                            dmg: dmg * (atk.duration / 1000) / 0.5, // rate
                            color: atk.color, thickness: atk.thickness, duration: atk.duration,
                            startTime: Date.now(), pierce: atk.pierce, stun: atk.stun,
                            dot: atk.dot, dotDur: atk.dotDur, dotDmg: atk.dotDmg * potency
                        });
                        break;
                    case 'aoe':
                        let aoeX = this.x + dirX * 200;
                        let aoeY = this.y + dirY * 200;
                        enemies.forEach(e => {
                            let edx = aoeX - e.x;
                            let edy = aoeY - e.y;
                            if (Math.sqrt(edx*edx + edy*edy) < atk.radius) {
                                let breakAmt = atk.break + this.pl * 10;
                                if (e.shield > 0) e.shield = Math.max(0, e.shield - breakAmt);
                                else e.takeDamage(dmg, this);
                                for (let k = 0; k < 5; k++) {
                                    particles.push(new Particle(e.x, e.y, (Math.random()-0.5)*10, (Math.random()-0.5)*10, atk.color, 2));
                                }
                            }
                        });
                        break;
                    case 'lightning':
                        let target = enemies.reduce((closest, e) => {
                            let d = Math.hypot(e.x - this.x, e.y - this.y);
                            return d < (closest ? Math.hypot(closest.x - this.x, closest.y - this.y) : Infinity) ? e : closest;
                        }, null);
                        if (target) {
                            let bolt = { x: this.x, y: this.y, tx: target.x, ty: target.y, dmg, color: atk.color, chains: atk.chains + (this.pl >= 4 ? 3 : 0), chainRange: atk.chainRange, zigZag: true, dot: this.pl >= 10 };
                            this.drawLightning(bolt);
                            target.takeDamage(dmg, this, { stun: 500, dot: bolt.dot ? { dur: 3000, dmg: 5 } : null });
                            // chain
                            let chained = [target];
                            for (let c = 0; c < bolt.chains; c++) {
                                let next = enemies.find(e => !chained.includes(e) && Math.hypot(e.x - target.x, e.y - target.y) < bolt.chainRange);
                                if (next) {
                                    let cbolt = { x: target.x, y: target.y, tx: next.x, ty: next.y, dmg: dmg * 0.7, color: atk.color };
                                    this.drawLightning(cbolt);
                                    next.takeDamage(cbolt.dmg, this);
                                    chained.push(next);
                                    target = next;
                                } else break;
                            }
                        }
                        break;
                    case 'buff':
                        this.speedBuffEnd = Date.now() + atk.duration;
                        if (this.pl >= 12) this.invulnEnd = Date.now() + atk.duration;
                        break;
                }
                if (this.pl === 16) shake = 10;
            }
            drawLightning(bolt) {
                ctx.strokeStyle = bolt.color;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(bolt.x, bolt.y);
                let steps = 20;
                for (let s = 1; s <= steps; s++) {
                    let px = bolt.x + (bolt.tx - bolt.x) * (s / steps) + (Math.random() - 0.5) * 20;
                    let py = bolt.y + (bolt.ty - bolt.y) * (s / steps) + (Math.random() - 0.5) * 20;
                    ctx.lineTo(px, py);
                }
                ctx.stroke();
            }
            takeDamage(dmg, from = null, opts = {}) {
                if (this.invulnEnd > Date.now()) return;
                let actual = Math.max(1, dmg * this.atk / 20 - this.def * (1 - this.pl * 0.05));
                this.health = Math.max(0, this.health - actual);
                for (let k = 0; k < 10; k++) {
                    particles.push(new Particle(this.x, this.y, (Math.random()-0.5)*5, (Math.random()-0.5)*5, 'red', 3));
                }
                if (opts.stun) { /* player no stun */ }
                if (opts.dot && opts.dot.dur) { /* implement dot timer if needed */ }
            }
        }

        class Enemy {
            constructor(type, pl) {
                this.x = Math.random() * CW;
                this.y = Math.random() * CH;
                this.type = type;
                this.pl = Math.min(pl, 16);
                this.health = 50 + wave * 20;
                this.maxHealth = this.health;
                this.speed = 1 + wave * 0.2;
                this.atk = 10 + wave * 5;
                this.def = 5 + wave * 2;
                this.color = { Fire: 'red', Ice: 'cyan', Shadow: 'gray', Storm: 'yellow', Beast: 'brown' }[type] || 'gray';
                this.shield = this.pl >= 4 ? 50 : 0;
                this.shieldMax = this.shield;
                this.lastAttack = 0;
                this.dodgeChance = 0.02 * this.pl;
                this.stunEnd = 0;
                this.slowMult = 1;
                this.slowEnd = 0;
                this.dotDmg = 0;
                this.dotEnd = 0;
                this.sizeMult = 1;
                if (wave % 5 === 0) {
                    this.health *= 3;
                    this.sizeMult = 1.5;
                    this.color = 'darkred';
                }
                this.attacks = { ...ATTACKS };
                // unlock based on pl
                let unlockedIds = [1];
                if (this.pl >= 2) unlockedIds.push(2,4);
                if (this.pl >= 4) unlockedIds.push(5,7);
                if (this.pl >= 6) unlockedIds.push(3,6,8);
                if (this.pl >= 8) unlockedIds.push(9,10);
                if (this.pl >= 10) unlockedIds.push(11,12);
                if (this.pl >= 12) unlockedIds.push(13);
                if (this.pl >= 14) unlockedIds.push(14);
                unlockedIds.forEach(id => this.attacks[id].unlocked = true);
                this.selectedAttack = unlockedIds[Math.floor(Math.random() * unlockedIds.length)];
            }
            draw(ctx, t) {
                let ox = 0, oy = 0;
                if (player.pl === 16 && shake > 0) {
                    ox = (Math.random() - 0.5) * 3;
                    oy = (Math.random() - 0.5) * 3;
                }
                ctx.save();
                ctx.translate(ox, oy);
                ctx.scale(this.sizeMult, this.sizeMult);
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                // head
                ctx.beginPath();
                ctx.arc(this.x, this.y - 40, 8, 0, Math.PI * 2);
                ctx.stroke();
                if (this.pl >= 8) {
                    // crown
                    ctx.fillStyle = 'gold';
                    ctx.beginPath();
                    ctx.moveTo(this.x - 10, this.y - 48);
                    ctx.lineTo(this.x + 10, this.y - 48);
                    ctx.lineTo(this.x, this.y - 55);
                    ctx.closePath();
                    ctx.fill();
                }
                // body
                ctx.strokeStyle = this.color;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y - 32);
                ctx.lineTo(this.x, this.y + 20);
                ctx.stroke();
                // arms
                let armSway = Math.sin(t * 0.005 + this.x * 0.01) * 10; // unique
                ctx.beginPath();
                ctx.moveTo(this.x, this.y - 20);
                ctx.lineTo(this.x - 15 + armSway, this.y);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(this.x, this.y - 20);
                ctx.lineTo(this.x + 15 - armSway, this.y);
                ctx.stroke();
                // legs
                let legSway = Math.sin(t * 0.005 + this.y * 0.01 + Math.PI) * 8;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y + 20);
                ctx.lineTo(this.x - 8 + legSway, this.y + 40);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(this.x, this.y + 20);
                ctx.lineTo(this.x + 8 - legSway, this.y + 40);
                ctx.stroke();
                // shield
                if (this.shield > 0) {
                    ctx.strokeStyle = `rgba(255,255,255,0.5)`;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 30, 0, Math.PI * 2);
                    ctx.stroke();
                }
                ctx.restore();
            }
            update(dt) {
                if (this.stunEnd > Date.now()) return;
                if (this.slowEnd > Date.now()) this.slowMult = 0.5; else this.slowMult = 1;
                if (this.dotEnd > Date.now()) {
                    this.health -= this.dotDmg / 60 * dt; // per frame
                    if (this.health <= 0) this.die();
                }
                let flee = player.pl === 16 && Math.random() < 0.1;
                let dx = (flee ? this.x - player.x : player.x - this.x);
                let dy = (flee ? this.y - player.y : player.y - this.y);
                let dist = Math.hypot(dx, dy);
                if (dist > 30) {
                    let moveSpeed = this.speed * this.slowMult * (1 - this.dodgeChance);
                    if (Math.random() < this.dodgeChance * dt / 16) {
                        dx = (Math.random() - 0.5) * 100;
                        dy = (Math.random() - 0.5) * 100;
                        dist = Math.hypot(dx, dy) || 1;
                    }
                    this.x += (dx / dist) * moveSpeed;
                    this.y += (dy / dist) * moveSpeed;
                } else {
                    player.takeDamage(this.atk, this);
                }
                if (Date.now() - this.lastAttack > Math.max(2000 - this.pl * 100, 500)) {
                    this.fire();
                    this.lastAttack = Date.now();
                }
                this.x = Math.max(0, Math.min(CW, this.x));
                this.y = Math.max(0, Math.min(CH, this.y));
            }
            fire() {
                let id = this.attacks[this.selectedAttack];
                if (!id.unlocked || Date.now() - id.lastUse < id.cd) return;
                id.lastUse = Date.now();
                let dx = player.x - this.x;
                let dy = player.y - this.y;
                let dist = Math.hypot(dx, dy) || 1;
                let dirX = dx / dist;
                let dirY = dy / dist;
                let potency = 1 + this.pl / 16;
                let dmg = id.damage * potency * this.atk / 10;
                // similar to player fire, but simplified, random attack type
                let proj = {
                    x: this.x, y: this.y,
                    vx: dirX * (id.speed || 5), vy: dirY * (id.speed || 5),
                    dmg, color: id.color || this.color, size: id.size || 5,
                    owner: 'enemy', type: id.name, homing: id.homing || 0,
                    pierce: id.pierce || false, ignoreShield: id.ignoreShield || false
                };
                if (id.type === 'spread') {
                    // simplified single for enemy
                    projectiles.push(proj);
                } else {
                    projectiles.push(proj);
                }
            }
            takeDamage(dmg, from, opts = {}) {
                let actual = Math.max(1, dmg - this.def);
                if (this.shield > 0) {
                    this.shield -= actual * (from && from.attacks[12] ? 2 : 1); // double if shield attack
                    if (this.shield <= 0) this.shield = 0;
                } else {
                    this.health -= actual;
                }
                if (opts.stun) this.stunEnd = Date.now() + opts.stun;
                if (opts.effect === 'slow') {
                    this.slowEnd = Date.now() + opts.effectDur;
                }
                if (opts.dot) {
                    this.dotDmg = opts.dotDmg;
                    this.dotEnd = Date.now() + opts.dotDur;
                }
                if (opts.knockback) {
                    let dx = this.x - from.x;
                    let dy = this.y - from.y;
                    let kdist = Math.hypot(dx, dy) || 1;
                    this.x += (dx / kdist) * opts.knockback;
                    this.y += (dy / kdist) * opts.knockback;
                }
                for (let k = 0; k < 5; k++) {
                    particles.push(new Particle(this.x, this.y, (Math.random()-0.5)*8, (Math.random()-0.5)*8, 'yellow', 2));
                }
                if (this.health <= 0) this.die();
            }
            die() {
                player.xp += 10 * this.pl;
                kills++;
                for (let k = 0; k < 20; k++) {
                    particles.push(new Particle(this.x, this.y, (Math.random()-0.5)*10, (Math.random()-0.5)*10, this.color, 4));
                }
                enemies = enemies.filter(e => e !== this);
            }
        }

        class Particle {
            constructor(x, y, vx, vy, color, size) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.color = color;
                this.size = size;
                this.life = 1.0;
                this.decay = 0.02;
            }
            update(dt) {
                this.x += this.vx * dt / 16;
                this.y += this.vy * dt / 16;
                this.vy += 0.2 * dt / 16; // gravity
                this.life -= this.decay * dt / 16;
            }
            draw(ctx) {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - this.size/2, this.y - this.size/2, this.size, this.size);
                ctx.globalAlpha = 1;
            }
        }

        function updateProjectiles() {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                let p = projectiles[i];
                // homing
                if (p.homing > 0) {
                    let target = p.owner === 'player' ? enemies[0] : player;
                    if (target) {
                        let tdx = target.x - p.x;
                        let tdy = target.y - p.y;
                        let tdist = Math.hypot(tdx, tdy) || 1;
                        p.vx += (tdx / tdist * p.homing);
                        p.y += (tdy / tdist * p.homing);
                        let pspeed = Math.hypot(p.vx, p.vy);
                        p.vx = p.vx / pspeed * (p.speed || 5);
                        p.vy = p.vy / pspeed * (p.speed || 5);
                    }
                }
                // zig zag
                if (p.zigZag) {
                    p.vx += (Math.random() - 0.5) * 2;
                    p.vy += (Math.random() - 0.5) * 2;
                }
                p.x += p.vx;
                p.y += p.vy;
                // draw
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
                // trail
                ctx.globalAlpha = 0.5;
                ctx.beginPath();
                ctx.arc(p.x - p.vx * 0.5, p.y - p.vy * 0.5, p.size * 0.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
                // collisions
                let hit = false;
                if (p.owner === 'player') {
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        let e = enemies[j];
                        let edx = p.x - e.x;
                        let edy = p.y - e.y;
                        if (Math.hypot(edx, edy) < e.sizeMult * 15 + p.size) {
                            let opts = { effect: p.effect, effectDur: p.effectDur, effectVal: p.effectVal, knockback: p.knockback, dot: p.dot ? { dur: p.dotDur, dmg: p.dotDmg } : null, stun: p.type === 'Beam Shot' && player.pl >= 8 ? 1000 : 0 };
                            if (p.ignoreShield || e.shield <= 0) {
                                e.takeDamage(p.dmg, player, opts);
                            } else {
                                e.shield -= p.dmg;
                            }
                            if (p.explode) {
                                enemies.forEach(ee => {
                                    if (ee !== e && Math.hypot(ee.x - e.x, ee.y - e.y) < p.explodeRad) {
                                        ee.takeDamage(p.dmg * 0.5, player);
                                    }
                                });
                            }
                            if (p.bounces > 0) {
                                // bounce logic simple: reverse dir, reduce bounces
                                p.vx = -p.vx;
                                p.vy = -p.vy;
                                p.bounces--;
                            } else if (!p.pierce) {
                                projectiles.splice(i, 1);
                                hit = true;
                                break;
                            }
                        }
                    }
                } else {
                    // enemy proj to player
                    if (player.shielding && player.shieldStrength > 0 && Math.hypot(p.x - player.x, p.y - player.y) < player.shieldRadius) {
                        player.shieldStrength -= p.dmg * player.shieldYield;
                        player.mana -= p.dmg * player.shieldYield;
                        if (player.shieldStrength <= 0) player.shielding = false;
                        for (let k = 0; k < 5; k++) {
                            particles.push(new Particle(p.x, p.y, (Math.random()-0.5)*10, (Math.random()-0.5)*10, 'green', 3));
                        }
                        projectiles.splice(i, 1);
                        continue;
                    }
                    if (p.reflect && player.shielding) {
                        // reflect
                        p.vx = -p.vx;
                        p.vy = -p.vy;
                        p.owner = 'player';
                        continue;
                    }
                    let pdx = p.x - player.x;
                    let pdy = p.y - player.y;
                    if (Math.hypot(pdx, pdy) < 15 + p.size && !player.invulnEnd > Date.now()) {
                        player.takeDamage(p.dmg);
                        projectiles.splice(i, 1);
                        hit = true;
                    }
                }
                // reflect enemy shots with shield attack proj? simplified, ignore for now
                // out of bounds
                if (p.x < 0 || p.x > CW || p.y < 0 || p.y > CH) {
                    if (p.bounces > 0) {
                        // wall bounce
                        if (p.x < 0 || p.x > CW) p.vx = -p.vx;
                        if (p.y < 0 || p.y > CH) p.vy = -p.vy;
                        p.x = Math.max(0, Math.min(CW, p.x));
                        p.y = Math.max(0, Math.min(CH, p.y));
                        p.bounces--;
                    } else {
                        projectiles.splice(i, 1);
                    }
                }
                if (!hit && (p.x < -50 || p.x > CW + 50 || p.y < -50 || p.y > CH + 50)) {
                    projectiles.splice(i, 1);
                }
            }
            // proj-proj collision for reflect
            for (let ii = projectiles.length - 1; ii >= 0; ii--) {
                for (let jj = ii + 1; jj < projectiles.length; jj++) {
                    let p1 = projectiles[ii];
                    let p2 = projectiles[jj];
                    if (p1.owner !== p2.owner && (p1.reflect || p2.reflect)) {
                        let pdx = p1.x - p2.x;
                        let pdy = p1.y - p2.y;
                        if (Math.hypot(pdx, pdy) < p1.size + p2.size) {
                            // reflect the non-reflect one
                            if (p1.reflect) {
                                p2.vx = -p2.vx;
                                p2.vy = -p2.vy;
                                p2.owner = p1.owner;
                            } else {
                                p1.vx = -p1.vx;
                                p1.vy = -p1.vy;
                                p1.owner = p2.owner;
                            }
                        }
                    }
                }
            }
        }

        function updateBeams() {
            for (let i = beams.length - 1; i >= 0; i--) {
                let b = beams[i];
                let elapsed = Date.now() - b.startTime;
                if (elapsed > b.duration) {
                    beams.splice(i, 1);
                    continue;
                }
                // draw
                ctx.strokeStyle = b.color;
                ctx.lineWidth = b.thickness;
                ctx.beginPath();
                ctx.moveTo(b.startX, b.startY);
                ctx.lineTo(b.endX, b.endY);
                ctx.stroke();
                // glow
                ctx.shadowBlur = 10;
                ctx.shadowColor = b.color;
                ctx.stroke();
                ctx.shadowBlur = 0;
                // damage
                let rate = b.dmg / (b.duration / 16); // per frame
                enemies.forEach(e => {
                    // line intersection simple: check if on line
                    let ex = e.x - b.startX;
                    let ey = e.y - b.startY;
                    let len = Math.hypot(b.endX - b.startX, b.endY - b.startY);
                    let proj = (ex * (b.endX - b.startX) + ey * (b.endY - b.startY)) / (len * len);
                    let closestX = b.startX + proj * (b.endX - b.startX);
                    let closestY = b.startY + proj * (b.endY - b.startY);
                    if (Math.hypot(e.x - closestX, e.y - closestY) < 20 && proj >= 0 && proj <= 1) {
                        let opts = { stun: b.stun, dot: b.dot ? { dur: b.dotDur, dmg: b.dotDmg } : null };
                        e.takeDamage(rate, player, opts);
                    }
                });
            }
        }

        function updateParticles(dt) {
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update(dt);
                if (particles[i].life <= 0) particles.splice(i, 1);
            }
        }

        function drawUI() {
            ctx.fillStyle = 'white';
            ctx.font = '16px Arial';
            ctx.fillText(`Health: ${Math.floor(player.health)}/${player.maxHealth}`, 10, 20);
            ctx.fillText(`Mana: ${Math.floor(player.mana)}/${player.maxMana}`, 10, 40);
            ctx.fillText(`PL: ${player.pl}`, 10, 60);
            ctx.fillText(`ATK: ${player.atk} DEF: ${player.def}`, 10, 80);
            ctx.fillText(`Level: ${player.level} XP: ${player.xp}/${player.nextLevelXp}`, 10, 100);
            ctx.fillText(`Wave: ${wave} Kills: ${kills}`, 10, 120);
            // spells
            ctx.fillText('Spells:', 620, 20);
            let sy = 40;
            for (let id in player.attacks) {
                let a = player.attacks[id];
                ctx.fillStyle = id == player.selectedAttack ? 'lime' : (a.unlocked ? 'white' : 'gray');
                let cd = a.cd ? Math.max(0, (a.cd - (Date.now() - a.lastUse)) / 1000) : 0;
                let text = `${id}: ${a.name}${!a.unlocked ? ' [LOCKED]' : ''}${cd > 0 ? ` [${cd.toFixed(1)}s]` : ''}`;
                ctx.fillText(text, 620, sy);
                sy += 20;
                if (sy > 550) break;
            }
            ctx.fillStyle = 'white';
            ctx.fillText('Controls: WASD/Arrows Move, Mouse Aim/Fire, SPACE Shield, , Cycle', 10, 580);
        }

        function drawMenu() {
            ctx.fillStyle = 'white';
            ctx.font = '32px Arial';
            ctx.textAlign = 'center';
            ctx.fillText("Alternate's Magical Evolution", CX, 200);
            ctx.font = '20px Arial';
            ctx.fillText('Press P to Play', CX, 250);
            ctx.fillText('Press A for Attributes', CX, 280);
            ctx.textAlign = 'left';
        }

        function drawAttributes() {
            ctx.fillStyle = 'white';
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Attributes', CX, 50);
            ctx.font = '16px Arial';
            let ay = 80;
            ctx.fillText(`Power Level: ${player.pl}/16`, CX, ay); ay += 25;
            ctx.fillText(`Attack: ${player.atk}`, CX, ay); ay += 25;
            ctx.fillText(`Defense: ${player.def}`, CX, ay); ay += 25;
            ctx.fillText(`Level: ${player.level}`, CX, ay); ay += 25;
            ctx.fillText(`Unlocked Spells: ${Array.from(player.unlocks).length}/14`, CX, ay); ay += 25;
            ctx.fillText('Press ESC to return', CX, CH - 50);
            ctx.textAlign = 'left';
            // list unlocks
            ay = 150;
            ctx.textAlign = 'left';
            for (let id of player.unlocks) {
                ctx.fillText(`${id}: ${player.attacks[id].name}`, 300, ay);
                ay += 20;
            }
            ctx.textAlign = 'left';
        }

        function generateUpgrades() {
            let pool = [];
            // unlocks 70% early
            let unlockPool = [];
            for (let id = 2; id <= 14; id++) {
                if (!player.unlocks.has(id)) unlockPool.push({ type: 'unlock', id, text: `Unlock ${player.attacks[id].name}` });
            }
            if (player.level < 10 && Math.random() < 0.7) {
                for (let i = 0; i < 3; i++) {
                    if (unlockPool.length > 0) {
                        let rand = unlockPool.splice(Math.floor(Math.random() * unlockPool.length), 1)[0];
                        pool.push(rand);
                    }
                }
            } else {
                // mix buffs, stats
                let buffPool = [];
                for (let id in player.attacks) {
                    if (player.unlocks.has(id)) {
                        buffPool.push({ type: 'buff', id, text: `+10 DMG to ${player.attacks[id].name}` });
                        buffPool.push({ type: 'buff', id, text: `-50ms CD to ${player.attacks[id].name}` });
                    }
                }
                let statPool = [
                    { type: 'stat', what: 'atk', val: 2, text: '+2 ATK' },
                    { type: 'stat', what: 'def', val: 2, text: '+2 DEF' },
                    { type: 'stat', what: 'pl', val: 1, text: '+1 PL (if <16)' },
                    { type: 'shield', what: 'yield', val: -0.1, text: 'Shield Yield -0.1' },
                    { type: 'shield', what: 'omni', text: 'Omni Shield (+20 rad)' }
                ];
                // random 3
                while (pool.length < 3) {
                    let choice = Math.random() < 0.4 ? buffPool : (Math.random() < 0.3 ? statPool : unlockPool);
                    if (choice.length === 0) choice = buffPool;
                    let up = choice.splice(Math.floor(Math.random() * choice.length), 1)[0];
                    if (up) pool.push(up);
                }
            }
            upgrades = pool.slice(0, 3); // ensure 3
        }

        function drawLevelUp() {
            ctx.fillStyle = 'white';
            ctx.font = '32px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Level Up!', CX, 150);
            ctx.font = '20px Arial';
            let uy = 200;
            upgrades.forEach((up, idx) => {
                ctx.fillText(`${idx + 1}: ${up.text}`, CX, uy);
                uy += 40;
            });
            ctx.fillText('Press 1-3 to choose', CX, uy + 20);
            ctx.textAlign = 'left';
        }

        function applyUpgrade(up) {
            switch (up.type) {
                case 'unlock':
                    player.unlocks.add(up.id);
                    player.attacks[up.id].unlocked = true;
                    break;
                case 'buff':
                    let a = player.attacks[up.id];
                    if (up.text.includes('DMG')) a.damage += 10;
                    else a.cd = Math.max(50, a.cd - 50);
                    break;
                case 'stat':
                    if (up.what === 'atk') player.atk += up.val;
                    if (up.what === 'def') player.def += up.val;
                    if (up.what === 'pl' && player.pl < 16) player.pl += up.val;
                    break;
                case 'shield':
                    if (up.what === 'yield') player.shieldYield = Math.max(0.1, player.shieldYield + up.val);
                    else {
                        player.omniShield = true;
                        player.shieldRadius += 20;
                    }
                    break;
            }
        }

        function spawnWave() {
            enemies = [];
            let num = Math.min(1 + Math.floor((wave - 1) / 3), 6);
            for (let i = 0; i < num; i++) {
                let type = ['Fire', 'Ice', 'Shadow', 'Storm', 'Beast'][Math.floor(Math.random() * 5)];
                let pl = Math.floor(wave / 2);
                enemies.push(new Enemy(type, pl));
            }
            if (wave % 5 === 0) {
                enemies.push(new Enemy('Boss', player.pl + 1));
            }
        }

        function checkLevelUp() {
            while (player.xp >= player.nextLevelXp) {
                player.xp -= player.nextLevelXp;
                player.nextLevelXp = Math.floor(player.nextLevelXp * 1.5);
                player.level++;
                if (player.level % 4 === 0 && player.pl < 16) player.pl++;
                if (player.pl === 16) player.maxHealth += 50; // god mode bonus
                generateUpgrades();
                gameState = 'levelup';
                return;
            }
        }

        function checkWaveClear() {
            if (enemies.length === 0 && gameState === 'playing') {
                player.xp += 100 * wave; // bonus
                wave++;
                checkLevelUp();
                if (gameState !== 'levelup') spawnWave();
            }
        }

        function loadGame() {
            let save = localStorage.getItem('alternateSave');
            if (save) {
                let data = JSON.parse(save);
                player.health = data.health || 100;
                player.mana = data.mana || 100;
                player.pl = Math.min(data.pl || 1, 16);
                player.atk = data.atk || 20;
                player.def = data.def || 10;
                player.level = data.level || 1;
                player.xp = data.xp || 0;
                player.nextLevelXp = data.nextLevelXp || 100;
                player.unlocks = new Set(data.unlocks || ['1']);
                player.shieldYield = data.shieldYield || 1.0;
                player.omniShield = data.omniShield || false;
                player.shieldRadius = 40 + (player.omniShield ? 20 : 0);
                // reload attacks
                for (let id in player.attacks) {
                    player.attacks[id].unlocked = player.unlocks.has(id);
                }
                wave = data.wave || 1;
                kills = data.kills || 0;
                spawnWave();
                gameState = 'playing';
            }
        }

        function saveGame() {
            let data = {
                health: player.health,
                mana: player.mana,
                pl: player.pl,
                atk: player.atk,
                def: player.def,
                level: player.level,
                xp: player.xp,
                nextLevelXp: player.nextLevelXp,
                unlocks: Array.from(player.unlocks),
                shieldYield: player.shieldYield,
                omniShield: player.omniShield,
                wave: wave,
                kills: kills
            };
            localStorage.setItem('alternateSave', JSON.stringify(data));
        }

        // Events
        document.addEventListener('keydown', e => {
            keys[e.key] = true;
            if (e.key === ' ') {
                e.preventDefault();
                if (gameState === 'playing') player.shielding = true;
            }
            if (e.key === ',') {
                let ids = Object.keys(player.attacks).map(Number).sort((a,b) => a - b).filter(id => player.attacks[id].unlocked);
                let currIdx = ids.indexOf(player.selectedAttack);
                player.selectedAttack = ids[(currIdx + 1) % ids.length] || 1;
            }
            if (e.key >= '1' && e.key <= '9') player.selectedAttack = parseInt(e.key);
            if (e.key.toLowerCase() === 'c') player.selectedAttack = 10;
            if (e.key.toLowerCase() === 'v') player.selectedAttack = 11;
            if (e.key.toLowerCase() === 'b') player.selectedAttack = 12;
            if (e.key.toLowerCase() === 'n') player.selectedAttack = 13;
            if (e.key.toLowerCase() === 'm') player.selectedAttack = 14;
            if (gameState === 'menu') {
                if (e.key.toLowerCase() === 'p') {
                    player = new Player();
                    wave = 1;
                    kills = 0;
                    spawnWave();
                    gameState = 'playing';
                } else if (e.key.toLowerCase() === 'a') {
                    gameState = 'attributes';
                }
            } else if (gameState === 'attributes' && e.key === 'Escape') {
                gameState = 'menu';
            } else if (gameState === 'gameover' && e.key.toLowerCase() === 'r') {
                localStorage.removeItem('alternateSave');
                gameState = 'menu';
            } else if (gameState === 'levelup' && e.key >= '1' && e.key <= '3') {
                let choice = parseInt(e.key) - 1;
                if (upgrades[choice]) {
                    applyUpgrade(upgrades[choice]);
                    checkLevelUp(); // if more levels
                    if (gameState !== 'levelup') {
                        spawnWave();
                    }
                }
            }
        });
        document.addEventListener('keyup', e => {
            keys[e.key] = false;
            if (e.key === ' ') {
                if (gameState === 'playing') player.shielding = false;
            }
        });
        canvas.addEventListener('mousemove', e => {
            let rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
        });
        canvas.addEventListener('mousedown', e => {
            mouse.down = true;
            if (gameState === 'playing') player.fire();
        });
        canvas.addEventListener('mouseup', () => mouse.down = false);

        // Init
        player = new Player();
        loadGame();
        function loop() {
            let dt = 16;
            gameTime += dt;
            ctx.clearRect(0, 0, CW, CH);
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, CW, CH);
            if (gameState === 'menu') {
                drawMenu();
            } else if (gameState === 'attributes') {
                drawAttributes();
            } else if (gameState === 'levelup') {
                drawLevelUp();
            } else if (gameState === 'playing') {
                player.update(dt);
                enemies.forEach(e => e.update(dt));
                updateProjectiles();
                updateBeams();
                updateParticles(dt);
                if (player.health <= 0) {
                    gameState = 'gameover';
                    localStorage.removeItem('alternateSave');
                }
                checkWaveClear();
                player.draw(ctx, gameTime);
                enemies.forEach(e => e.draw(ctx, gameTime));
                particles.forEach(p => p.draw(ctx));
                drawUI();
                // aim line
                ctx.strokeStyle = 'gray';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(player.x, player.y);
                ctx.lineTo(mouse.x, mouse.y);
                ctx.stroke();
            } else if (gameState === 'gameover') {
                ctx.fillStyle = 'white';
                ctx.font = '32px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Game Over', CX, CY);
                ctx.font = '20px Arial';
                ctx.fillText(`Survived ${wave - 1} waves, ${kills} kills`, CX, CY + 40);
                ctx.fillText('Press R to Restart', CX, CY + 80);
                ctx.textAlign = 'left';
            }
            if (gameState === 'playing') saveGame();
            requestAnimationFrame(loop);
        }
        loop();
    </script>
</body>
</html>
