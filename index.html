<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alternate's Magical Evolution</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: black;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 1px solid white;
            background-color: black;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 14px;
        }
        #spellList {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-size: 12px;
            max-height: 400px;
            overflow-y: auto;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            font-size: 12px;
        }
        #menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
            display: none;
        }
        button {
            background: none;
            border: 1px solid white;
            color: white;
            padding: 10px;
            margin: 5px;
            cursor: pointer;
        }
        button:hover {
            background: white;
            color: black;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="ui"></div>
    <div id="spellList"></div>
    <div id="controls">
        Controls: WASD/Arrows - Move | Mouse - Aim/Fire | , - Cycle Attack | SPACE - Shield
    </div>
    <div id="menu">
        <h1>Alternate's Magical Evolution</h1>
        <button onclick="startGame()">Play</button>
        <button onclick="viewAttributes()">Attributes</button>
        <div id="attributes"></div>
    </div>
    <script>
        // Game Constants
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 600;
        const FPS = 60;
        const WAVE_SCALING = { enemies: 1, healthMult: 1, atkMult: 1 };
        const PL_CAP = 16;
        const MAX_ENEMIES = 6;
        const BOSS_EVERY = 5;
        const UPGRADE_POOL_SIZE = 20; // For random selection without repeats

        // Input Handling
        const keys = {};
        const mouse = { x: 0, y: 0, down: false };
        let currentAttackIndex = 0;

        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            if (e.key === ',') cycleAttack();
            if (e.key >= '1' && e.key <= '9') currentAttackIndex = parseInt(e.key) - 1;
            if (e.key.toLowerCase() === 'c') currentAttackIndex = 9;
            if (e.key.toLowerCase() === 'v') currentAttackIndex = 10;
            if (e.key.toLowerCase() === 'b') currentAttackIndex = 11;
            if (e.key.toLowerCase() === 'n') currentAttackIndex = 12;
            if (e.key.toLowerCase() === 'm') currentAttackIndex = 13;
        });
        document.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);
        document.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
        });
        document.addEventListener('mousedown', () => mouse.down = true);
        document.addEventListener('mouseup', () => mouse.down = false);

        // Canvas Setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false; // For pixel art feel, but since lines, optional

        // Particle System Class
        class Particle {
            constructor(x, y, vx, vy, color, life, size = 2, fade = true) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.color = color;
                this.life = life;
                this.maxLife = life;
                this.size = size;
                this.fade = fade;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.1; // Gravity for blood
                this.life--;
                this.vx *= 0.99;
                this.vy *= 0.99;
            }
            draw() {
                ctx.save();
                if (this.fade) {
                    ctx.globalAlpha = this.life / this.maxLife;
                }
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }
        let particles = [];

        // Blood Splatter Function
        function createBloodSplatter(x, y, count = 10, intensity = 1) {
            for (let i = 0; i < count * intensity; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 5 + 2;
                particles.push(new Particle(
                    x, y,
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed,
                    'red',
                    Math.random() * 30 + 20,
                    Math.random() * 3 + 1
                ));
            }
        }

        // Explosion Blood on Death
        function explodeIntoBlood(entity) {
            createBloodSplatter(entity.x, entity.y, 20, 2);
            // More particles for explosion
            for (let i = 0; i < 15; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 10 + 5;
                particles.push(new Particle(
                    entity.x, entity.y,
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed,
                    'darkred',
                    Math.random() * 50 + 30,
                    Math.random() * 4 + 2
                ));
            }
        }

        // Entity Base Class (for Player and Enemies)
        class Entity {
            constructor(x, y, color, hatColor, size = 20) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.hatColor = hatColor;
                this.size = size;
                this.health = 100;
                this.maxHealth = 100;
                this.mana = 100;
                this.maxMana = 100;
                this.speed = 3;
                this.atk = 20;
                this.def = 10;
                this.pl = 1;
                this.angle = 0; // Facing angle
                this.armAngle = 0; // For pointing arm
                this.legAngle = 0; // For walking
                this.shieldActive = false;
                this.shieldStrength = 0;
                this.bloodSplatter = []; // For visual blood on body
                this.dead = false;
            }
            update() {}
            draw() {
                if (this.dead) return;
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                // Draw blood on body
                this.bloodSplatter.forEach(splat => {
                    ctx.fillStyle = 'red';
                    ctx.globalAlpha = splat.alpha;
                    ctx.beginPath();
                    ctx.arc(splat.x, splat.y, splat.size, 0, Math.PI * 2);
                    ctx.fill();
                });

                // Stick figure: head
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(0, -this.size / 2, this.size / 4, 0, Math.PI * 2);
                ctx.fill();

                // Hat
                if (this.hatColor) {
                    ctx.fillStyle = this.hatColor;
                    ctx.beginPath();
                    ctx.moveTo(-this.size / 4, -this.size / 2);
                    ctx.lineTo(this.size / 4, -this.size / 2);
                    ctx.lineTo(0, -this.size);
                    ctx.closePath();
                    ctx.fill();
                }

                // Body
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, -this.size / 4);
                ctx.lineTo(0, this.size / 4);
                ctx.stroke();

                // Arms - animated pointing
                ctx.beginPath();
                ctx.moveTo(0, -this.size / 8);
                ctx.lineTo(Math.cos(this.armAngle) * this.size / 3, Math.sin(this.armAngle) * this.size / 3);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(0, -this.size / 8);
                ctx.lineTo(-Math.cos(this.armAngle + Math.PI) * this.size / 3, Math.sin(this.armAngle + Math.PI) * this.size / 3);
                ctx.stroke();

                // Legs - walking animation
                ctx.beginPath();
                ctx.moveTo(0, this.size / 4);
                ctx.lineTo(Math.cos(this.legAngle) * this.size / 3, this.size / 4 + Math.sin(this.legAngle) * this.size / 3);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(0, this.size / 4);
                ctx.lineTo(-Math.cos(this.legAngle) * this.size / 3, this.size / 4 - Math.sin(this.legAngle) * this.size / 3);
                ctx.stroke();

                // Shield bubble
                if (this.shieldActive && this.shieldStrength > 0) {
                    ctx.strokeStyle = 'green';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, 40 + (this.pl * 1), 0, Math.PI * 2);
                    ctx.stroke();
                    // Pulse animation
                    const pulse = Math.sin(Date.now() / 200) * 2;
                    ctx.lineWidth = 2 + pulse;
                }

                ctx.restore();
            }
            takeDamage(dmg, ignoreDef = false) {
                let actualDmg = dmg - (ignoreDef ? 0 : this.def);
                actualDmg = Math.max(1, actualDmg);
                actualDmg *= (1 - this.pl / 100); // PL reduces incoming dmg slightly
                this.health -= actualDmg;
                // Add blood splatter
                this.bloodSplatter.push({
                    x: Math.random() * 10 - 5,
                    y: Math.random() * 10 - 5,
                    size: Math.random() * 3 + 1,
                    alpha: 1
                });
                // Fade blood over time
                this.bloodSplatter = this.bloodSplatter.filter(s => {
                    s.alpha -= 0.01;
                    return s.alpha > 0;
                });
                if (this.health <= 0) {
                    this.die();
                }
            }
            die() {
                this.dead = true;
                explodeIntoBlood(this);
            }
            regen() {
                this.health = Math.min(this.maxHealth, this.health + 0.1);
                this.mana = Math.min(this.maxMana, this.mana + 0.2);
            }
            updateAim(targetX, targetY) {
                const dx = targetX - this.x;
                const dy = targetY - this.y;
                this.angle = Math.atan2(dy, dx);
                this.armAngle = this.angle;
            }
            updateWalkAnim(speed) {
                this.legAngle = Math.sin(Date.now() / 100) * (speed / 5);
            }
        }

        // Player Class
        class Player extends Entity {
            constructor() {
                super(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2, 'lightblue', 'purple');
                this.health = 100;
                this.maxHealth = 100;
                this.mana = 100;
                this.maxMana = 100;
                this.speed = 3;
                this.atk = 20;
                this.def = 10;
                this.pl = 1;
                this.level = 1;
                this.xp = 0;
                this.xpToNext = 100;
                this.shieldYield = 1.0;
                this.shieldOmni = false;
                this.ringsActive = false;
                this.rings = []; // For Precharged Rings
                this.unlockedAttacks = [0]; // Start with Magic Shot (index 0)
                this.attackCooldowns = {}; // Per attack
                this.selectedAttack = 0;
                this.shielding = false;
                this.shieldTimer = 0;
            }
            update() {
                // Movement
                let dx = 0, dy = 0;
                if (keys['w'] || keys['arrowup']) dy -= this.speed;
                if (keys['s'] || keys['arrowdown']) dy += this.speed;
                if (keys['a'] || keys['arrowleft']) dx -= this.speed;
                if (keys['d'] || keys['arrowright']) dx += this.speed;
                this.x += dx;
                this.y += dy;
                this.x = Math.max(this.size, Math.min(CANVAS_WIDTH - this.size, this.x));
                this.y = Math.max(this.size, Math.min(CANVAS_HEIGHT - this.size, this.y));

                if (dx !== 0 || dy !== 0) {
                    this.updateWalkAnim(Math.sqrt(dx*dx + dy*dy));
                }

                // Aim
                this.updateAim(mouse.x, mouse.y);

                // Shield
                this.shielding = keys[' '];
                if (this.shielding && this.mana > 0) {
                    this.shieldActive = true;
                    this.shieldStrength = Math.min(100, this.shieldStrength + 1);
                    this.mana -= 0.5; // Base drain
                } else {
                    this.shieldActive = false;
                    this.shieldStrength = Math.max(0, this.shieldStrength - 2);
                }

                // Regen
                this.regen();

                // Update rings
                if (this.ringsActive) {
                    this.updateRings();
                }

                // Fire if mouse down and cooldown ok
                if (mouse.down && this.canFire()) {
                    this.fire();
                }

                // Update cooldowns
                Object.keys(this.attackCooldowns).forEach(key => {
                    this.attackCooldowns[key] = Math.max(0, this.attackCooldowns[key] - 1000 / FPS);
                });

                // Check collisions with enemies for rings ram
                if (this.ringsActive && this.rings.length > 0) {
                    game.enemies.forEach(enemy => {
                        if (!enemy.dead && this.distanceTo(enemy) < this.size + enemy.size) {
                            this.explodeRingsOnRam(enemy);
                        }
                    });
                }
            }
            distanceTo(other) {
                const dx = this.x - other.x;
                const dy = this.y - other.y;
                return Math.sqrt(dx*dx + dy*dy);
            }
            canFire() {
                const attack = attacks[this.selectedAttack];
                if (!this.unlockedAttacks.includes(this.selectedAttack)) return false;
                return this.attackCooldowns[this.selectedAttack] <= 0 && this.mana >= attack.manaCost;
            }
            fire() {
                const attack = attacks[this.selectedAttack];
                if (!this.canFire()) return;

                this.mana -= attack.manaCost;
                this.attackCooldowns[this.selectedAttack] = attack.cooldown;

                // Enhanced damage if rings active and default attack
                let dmgMultiplier = 1;
                if (this.ringsActive && this.selectedAttack === 0) {
                    dmgMultiplier = 3; // Way more damage
                }

                // Create projectile or effect
                let proj;
                const targetX = mouse.x;
                const targetY = mouse.y;
                switch (this.selectedAttack) {
                    case 0: // Magic Shot
                        proj = new Projectile(this.x, this.y, targetX, targetY, 'orange', this.atk * (1 + this.pl / 16) * dmgMultiplier, this.pl, this);
                        game.projectiles.push(proj);
                        if (this.ringsActive) {
                            this.rings.forEach(ring => {
                                // Fire enhanced from ring positions? But for simplicity, just multiplier above
                            });
                            this.rings = []; // Unload fast? Or keep until ram
                        }
                        break;
                    case 1: // Tri-Shot
                        for (let i = -1; i <= 1; i++) {
                            const angle = this.angle + i * 0.5;
                            proj = new Projectile(this.x, this.y, this.x + Math.cos(angle) * 100, this.y + Math.sin(angle) * 100, 'blue', this.atk * (1 + this.pl / 16), this.pl, this);
                            game.projectiles.push(proj);
                        }
                        break;
                    case 2: // Beam Shot
                        // Instant line beam
                        game.enemies.forEach(enemy => {
                            if (!enemy.dead && this.lineOfSight(enemy.x, enemy.y, targetX, targetY)) {
                                let dmg = this.atk * (1 + this.pl / 16) * 5; // High dmg
                                if (this.pl >= 8) enemy.stun(60); // Stun frames
                                enemy.takeDamage(dmg);
                                // Visual line
                                ctx.strokeStyle = 'white';
                                ctx.lineWidth = 3;
                                ctx.beginPath();
                                ctx.moveTo(this.x, this.y);
                                ctx.lineTo(enemy.x, enemy.y);
                                ctx.stroke();
                            }
                        });
                        break;
                    case 3: // Ice Shard
                        proj = new Projectile(this.x, this.y, targetX, targetY, 'cyan', this.atk * (1 + this.pl / 16), this.pl, this, { slow: 0.5, duration: 120 });
                        game.projectiles.push(proj);
                        break;
                    case 4: // Lightning
                        // Find nearest enemy
                        let nearest = null;
                        let minDist = Infinity;
                        game.enemies.forEach(e => {
                            if (!e.dead) {
                                const dist = this.distanceTo(e);
                                if (dist < minDist) {
                                    minDist = dist;
                                    nearest = e;
                                }
                            }
                        });
                        if (nearest) {
                            let current = nearest;
                            let chainCount = 3 + Math.floor(this.pl / 4);
                            for (let i = 0; i < chainCount; i++) {
                                current.takeDamage(this.atk * (1 + this.pl / 16) * 1.5);
                                if (this.pl >= 10) current.applyDoT(this.atk * 0.1, 180); // DoT
                                // Visual zig-zag
                                drawLightning(this.x, this.y, current.x, current.y);
                                // Find next chain target
                                let next = null;
                                let nextDist = Infinity;
                                game.enemies.forEach(e => {
                                    if (e !== current && !e.dead && this.distanceTo(e) < 100) {
                                        const dist = this.distanceTo(e);
                                        if (dist < nextDist) {
                                            nextDist = dist;
                                            next = e;
                                        }
                                    }
                                });
                                if (next) current = next;
                                else break;
                            }
                        }
                        break;
                    case 5: // Curve Shot
                        proj = new Projectile(this.x, this.y, targetX, targetY, 'green', this.atk * (1 + this.pl / 16), this.pl, this, { homing: true, curve: true });
                        game.projectiles.push(proj);
                        break;
                    case 6: // Shield Breaker
                        // AoE pulse at cursor
                        const pulseX = targetX;
                        const pulseY = targetY;
                        game.enemies.forEach(enemy => {
                            if (!enemy.dead && this.distanceToPos(pulseX, pulseY, enemy.x, enemy.y) < 50 + this.pl * 5) {
                                let shieldDmg = 50 + this.pl * 10;
                                enemy.shieldStrength -= shieldDmg;
                                enemy.takeDamage(this.atk * (1 + this.pl / 16) * 0.5);
                            }
                        });
                        // Visual pulse
                        ctx.fillStyle = 'purple';
                        ctx.beginPath();
                        ctx.arc(pulseX, pulseY, 50 + this.pl * 5, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    case 7: // Homing Missile
                        proj = new Projectile(this.x, this.y, targetX, targetY, 'red', this.atk * (1 + this.pl / 16) * 2, this.pl, this, { homing: true, explode: true, radius: 30 + this.pl * 5 });
                        game.projectiles.push(proj);
                        break;
                    case 8: // Force Wave
                        // Cone from player to cursor
                        const waveAngle = this.angle;
                        const waveLength = 200;
                        game.enemies.forEach(enemy => {
                            const enemyAngle = Math.atan2(enemy.y - this.y, enemy.x - this.x);
                            if (Math.abs(enemyAngle - waveAngle) < 0.5 && this.distanceTo(enemy) < waveLength) {
                                enemy.takeDamage(this.atk * (1 + this.pl / 16));
                                // Knockback
                                const kb = 10;
                                enemy.x += Math.cos(enemyAngle) * kb;
                                enemy.y += Math.sin(enemyAngle) * kb;
                            }
                        });
                        // Visual cone
                        ctx.fillStyle = 'blue';
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y);
                        ctx.lineTo(this.x + Math.cos(waveAngle - 0.5) * waveLength, this.y + Math.sin(waveAngle - 0.5) * waveLength);
                        ctx.lineTo(this.x + Math.cos(waveAngle + 0.5) * waveLength, this.y + Math.sin(waveAngle + 0.5) * waveLength);
                        ctx.closePath();
                        ctx.fill();
                        break;
                    case 9: // Penta Shot
                        for (let i = -2; i <= 2; i++) {
                            const angle = this.angle + i * 0.3;
                            proj = new Projectile(this.x, this.y, this.x + Math.cos(angle) * 100, this.y + Math.sin(angle) * 100, 'blue', this.atk * (1 + this.pl / 16), this.pl, this);
                            game.projectiles.push(proj);
                        }
                        break;
                    case 10: // Recursive Shot
                        proj = new Projectile(this.x, this.y, targetX, targetY, 'yellow', this.atk * (1 + this.pl / 16), this.pl, this, { bounces: 3 + this.pl });
                        game.projectiles.push(proj);
                        break;
                    case 11: // Shield Attack
                        proj = new Projectile(this.x, this.y, targetX, targetY, 'gold', this.atk * (1 + this.pl / 16), this.pl, this, { ignoreShield: true, reflect: true });
                        game.projectiles.push(proj);
                        break;
                    case 12: // Beta Laser
                        // Thick beam
                        game.enemies.forEach(enemy => {
                            if (!enemy.dead) {
                                let dmg = this.atk * (1 + this.pl / 16) * 10;
                                enemy.takeDamage(dmg);
                                if (this.pl >= 10) enemy.applyDoT(dmg * 0.3, 180); // Burn DoT
                                // Visual thick line
                                ctx.strokeStyle = 'red';
                                ctx.lineWidth = 5;
                                ctx.beginPath();
                                ctx.moveTo(this.x, this.y);
                                ctx.lineTo(enemy.x, enemy.y);
                                ctx.stroke();
                            }
                        });
                        break;
                    case 13: // Super Speed
                        this.speed *= 2;
                        setTimeout(() => {
                            this.speed /= 2;
                            if (this.pl >= 12) {
                                // Invuln frames, say 120 frames
                                this.invulnTimer = 120;
                            }
                        }, 5000);
                        // Dodge trails - add particles
                        for (let i = 0; i < 10; i++) {
                            particles.push(new Particle(this.x, this.y, Math.random() * 4 - 2, Math.random() * 4 - 2, 'white', 30));
                        }
                        break;
                    case 14: // Precharged Rings
                        this.activateRings();
                        break;
                }
            }
            lineOfSight(ex, ey, tx, ty) {
                // Simple check if enemy is near line to target
                return Math.abs((tx - this.x) * (ey - this.y) - (ty - this.y) * (ex - this.x)) < 20;
            }
            distanceToPos(px, py, ex, ey) {
                const dx = px - ex;
                const dy = py - ey;
                return Math.sqrt(dx*dx + dy*dy);
            }
            activateRings() {
                this.ringsActive = true;
                this.rings = [];
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    this.rings.push({
                        x: this.x + Math.cos(angle) * 50,
                        y: this.y + Math.sin(angle) * 50,
                        angle: angle,
                        life: 300 // 5 seconds at 60fps
                    });
                }
            }
            updateRings() {
                this.rings.forEach(ring => {
                    ring.life--;
                    ring.x = this.x + Math.cos(ring.angle) * 50;
                    ring.y = this.y + Math.sin(ring.angle) * 50;
                    ring.angle += 0.05; // Rotate
                    // Draw rings
                    ctx.fillStyle = 'blue';
                    ctx.beginPath();
                    ctx.arc(ring.x, ring.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                });
                this.rings = this.rings.filter(r => r.life > 0);
                if (this.rings.length === 0) this.ringsActive = false;
            }
            explodeRingsOnRam(enemy) {
                this.rings.forEach(ring => {
                    const dist = this.distanceToPos(ring.x, ring.y, enemy.x, enemy.y);
                    if (dist < 30) {
                        // Explode
                        createBloodSplatter(enemy.x, enemy.y, 5);
                        enemy.takeDamage(50); // Hurt enemy
                        this.takeDamage(20); // Hurt self
                    }
                });
                this.rings = [];
                this.ringsActive = false;
            }
            cycleAttack() {
                let start = currentAttackIndex;
                do {
                    currentAttackIndex = (currentAttackIndex + 1) % attacks.length;
                } while (!this.unlockedAttacks.includes(currentAttackIndex) && currentAttackIndex !== start);
                this.selectedAttack = currentAttackIndex;
            }
            gainXP(amount) {
                this.xp += amount;
                if (this.xp >= this.xpToNext) {
                    this.levelUp();
                }
            }
            levelUp() {
                this.level++;
                this.xp -= this.xpToNext;
                this.xpToNext += 50;
                this.maxHealth += 10;
                this.maxMana += 10;
                this.health = this.maxHealth;
                this.mana = this.maxMana;
                // Rare PL up
                if (this.level % (3 + Math.random() * 3) === 0 && this.pl < PL_CAP) {
                    this.pl++;
                }
                // Show upgrade menu
                showUpgradeMenu();
            }
        }

        // Projectile Class
        class Projectile {
            constructor(x, y, tx, ty, color, damage, pl, owner, effects = {}) {
                this.x = x;
                this.y = y;
                this.vx = (tx - x) / 30; // Speed
                this.vy = (ty - y) / 30;
                this.color = color;
                this.damage = damage;
                this.pl = pl;
                this.owner = owner;
                this.size = 5;
                this.life = 300; // Max frames
                this.effects = effects; // slow, homing, etc.
                this.bouncesLeft = effects.bounces || 0;
                this.trail = []; // For trails
                this.reflecting = false;
            }
            update() {
                // Homing
                if (this.effects.homing) {
                    let target = null;
                    let minDist = Infinity;
                    if (this.owner instanceof Player) {
                        game.enemies.forEach(e => {
                            if (!e.dead) {
                                const dist = Math.hypot(e.x - this.x, e.y - this.y);
                                if (dist < minDist) {
                                    minDist = dist;
                                    target = e;
                                }
                            }
                        });
                    } else {
                        // Enemy projectiles target player
                        const dist = Math.hypot(game.player.x - this.x, game.player.y - this.y);
                        if (dist < 100) target = game.player;
                    }
                    if (target) {
                        const angle = Math.atan2(target.y - this.y, target.x - this.x);
                        this.vx += Math.cos(angle) * 0.1;
                        this.vy += Math.sin(angle) * 0.1;
                    }
                }

                // Curve for curve shot
                if (this.effects.curve) {
                    this.vx += Math.sin(Date.now() / 100) * 0.05;
                    this.vy += Math.cos(Date.now() / 100) * 0.05;
                }

                this.x += this.vx;
                this.y += this.vy;

                // Bounce
                if (this.bouncesLeft > 0) {
                    if (this.x < 0 || this.x > CANVAS_WIDTH) {
                        this.vx *= -1;
                        this.bouncesLeft--;
                    }
                    if (this.y < 0 || this.y > CANVAS_HEIGHT) {
                        this.vy *= -1;
                        this.bouncesLeft--;
                    }
                }

                // Trail
                this.trail.push({x: this.x, y: this.y});
                if (this.trail.length > 10) this.trail.shift();

                this.life--;

                // Collisions
                if (this.owner instanceof Player) {
                    // Player proj vs enemies
                    game.enemies.forEach((enemy, idx) => {
                        if (!enemy.dead && Math.hypot(enemy.x - this.x, enemy.y - this.y) < this.size + enemy.size) {
                            this.hit(enemy);
                            game.projectiles.splice(game.projectiles.indexOf(this), 1);
                        }
                    });
                } else {
                    // Enemy proj vs player
                    if (!game.player.dead && Math.hypot(game.player.x - this.x, game.player.y - this.y) < this.size + game.player.size) {
                        this.hit(game.player);
                        game.projectiles.splice(game.projectiles.indexOf(this), 1);
                    }
                    // Projectile vs projectile collision
                    game.projectiles.forEach(other => {
                        if (other !== this && other.owner !== this.owner && Math.hypot(other.x - this.x, other.y - this.y) < this.size * 2) {
                            // Collide, create particles
                            for (let i = 0; i < 5; i++) {
                                particles.push(new Particle(this.x, this.y, Math.random()*4-2, Math.random()*4-2, this.color, 20));
                            }
                            game.projectiles.splice(game.projectiles.indexOf(this), 1);
                            game.projectiles.splice(game.projectiles.indexOf(other), 1);
                        }
                    });
                }

                // Wall bounce for recursive
                if (this.bouncesLeft > 0 && (this.x < 0 || this.x > CANVAS_WIDTH || this.y < 0 || this.y > CANVAS_HEIGHT)) {
                    // Already handled above
                }

                // Reflect if shield attack
                if (this.effects.reflect && game.player.shieldActive) {
                    // Chance to reflect enemy shots
                    if (Math.random() < 0.5) {
                        this.owner = game.player;
                        this.vx *= -1;
                        this.vy *= -1;
                        this.reflecting = true;
                    }
                }
            }
            hit(target) {
                let dmg = this.damage;
                if (target.shieldActive && target.shieldStrength > 0 && !this.effects.ignoreShield) {
                    target.shieldStrength -= dmg * game.player.shieldYield;
                    dmg *= 0.5; // Reduced if shielded
                    // Sparks
                    for (let i = 0; i < 5; i++) {
                        particles.push(new Particle(target.x, target.y, Math.random()*6-3, Math.random()*6-3, 'yellow', 20));
                    }
                }
                if (this.effects.slow) {
                    target.slowTimer = this.effects.duration;
                    target.speed *= (1 - this.effects.slow);
                }
                target.takeDamage(dmg, this.effects.ignoreDef);
                createBloodSplatter(target.x, target.y, 5);

                // Explode if homing missile
                if (this.effects.explode) {
                    game.enemies.forEach(e => {
                        if (!e.dead && Math.hypot(e.x - this.x, this.y - this.y) < this.effects.radius) {
                            e.takeDamage(dmg * 0.5);
                        }
                    });
                }
            }
            draw() {
                // Trail
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                this.trail.forEach((p, i) => {
                    ctx.globalAlpha = i / this.trail.length;
                    if (i === 0) ctx.moveTo(p.x, p.y);
                    else ctx.lineTo(p.x, p.y);
                });
                ctx.stroke();
                ctx.globalAlpha = 1;

                // Proj
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Enemy Class
        class Enemy extends Entity {
            constructor(x, y, type, level) {
                super(x, y, type.color, type.hatColor, 20 + level * 2);
                this.type = type;
                this.level = level;
                this.health = 50 + level * 20;
                this.maxHealth = this.health;
                this.speed = 1 + level * 0.2;
                this.atk = 10 + level * 5;
                this.def = 5 + level * 2;
                this.pl = Math.floor(level / 2);
                this.stunTimer = 0;
                this.slowTimer = 0;
                this.dotTimer = 0;
                this.dotDmg = 0;
                this.lastAttack = 0;
                this.aiComplexity = this.pl;
                this.dodgeChance = 0.02 * this.pl;
                this.selectedAttack = 0;
                this.shieldActive = this.pl >= 4;
            }
            update() {
                if (this.stunTimer > 0) {
                    this.stunTimer--;
                    return;
                }
                if (this.slowTimer > 0) {
                    this.slowTimer--;
                    this.speed *= 1.1; // Recover
                }
                if (this.dotTimer > 0) {
                    this.dotTimer--;
                    this.takeDamage(this.dotDmg);
                }

                // AI
                const distToPlayer = Math.hypot(game.player.x - this.x, game.player.y - this.y);
                if (distToPlayer > 30) {
                    // Chase
                    const angle = Math.atan2(game.player.y - this.y, game.player.x - this.x);
                    this.x += Math.cos(angle) * this.speed;
                    this.y += Math.sin(angle) * this.speed;
                    this.updateWalkAnim(this.speed);
                } else {
                    // Melee
                    game.player.takeDamage(this.atk);
                    createBloodSplatter(game.player.x, game.player.y, 3);
                }

                // Dodge
                if (Math.random() < this.dodgeChance) {
                    const dodgeAngle = Math.atan2(Math.random() - 0.5, Math.random() - 0.5);
                    this.x += Math.cos(dodgeAngle) * 20;
                    this.y += Math.sin(dodgeAngle) * 20;
                }

                // Ranged attack
                if (Date.now() - this.lastAttack > (3000 - this.pl * 100) && distToPlayer > 50) {
                    this.attack();
                    this.lastAttack = Date.now();
                }

                // Aim at player
                this.updateAim(game.player.x, game.player.y);

                this.regen();
            }
            attack() {
                // Select attack based on PL
                this.selectedAttack = Math.min(Math.floor(Math.random() * (1 + this.pl / 4)), attacks.length - 1);
                if (this.selectedAttack === 0 || (this.pl >= 4 && Math.random() < 0.5)) { // Basic or advanced
                    const proj = new Projectile(this.x, this.y, game.player.x, game.player.y, this.type.color, this.atk * (1 + this.pl / 16), this.pl, this);
                    game.projectiles.push(proj);
                } else if (this.selectedAttack === 2 && this.pl >= 5) {
                    // Beam
                    let dmg = this.atk * (1 + this.pl / 16) * 3;
                    game.player.takeDamage(dmg);
                } else if (this.selectedAttack === 4 && this.pl >= 8) {
                    // Lightning chain
                    // Similar to player lightning, chain to player and dummies
                    game.player.takeDamage(this.atk * 1.5);
                } // Add more as PL increases, up to full kit at 16

                // For god PL, predict moves
                if (this.pl >= 12) {
                    // Aim ahead
                    const predictX = game.player.x + game.player.speed * Math.cos(game.player.angle) * 10;
                    const predictY = game.player.y + game.player.speed * Math.sin(game.player.angle) * 10;
                    // Use predict in proj
                }
            }
            stun(frames) {
                this.stunTimer = frames;
            }
            applyDoT(dmg, frames) {
                this.dotDmg = dmg / frames;
                this.dotTimer = frames;
            }
            draw() {
                super.draw();
                // Health bar
                ctx.fillStyle = 'red';
                ctx.fillRect(this.x - 20, this.y - 30, 40, 5);
                ctx.fillStyle = 'green';
                ctx.fillRect(this.x - 20, this.y - 30, 40 * (this.health / this.maxHealth), 5);
            }
        }

        // Attacks Definition
        const attacks = [
            { name: 'Magic Shot', manaCost: 5, cooldown: 200 }, // Fast
            { name: 'Tri-Shot', manaCost: 8, cooldown: 300 },
            { name: 'Beam Shot', manaCost: 15, cooldown: 1000 },
            { name: 'Ice Shard', manaCost: 10, cooldown: 400 },
            { name: 'Lightning', manaCost: 20, cooldown: 800 },
            { name: 'Curve Shot', manaCost: 12, cooldown: 500 },
            { name: 'Shield Breaker', manaCost: 18, cooldown: 600 },
            { name: 'Homing Missile', manaCost: 25, cooldown: 1000 },
            { name: 'Force Wave', manaCost: 15, cooldown: 700 },
            { name: 'Penta Shot', manaCost: 12, cooldown: 400 },
            { name: 'Recursive Shot', manaCost: 22, cooldown: 900 },
            { name: 'Shield Attack', manaCost: 16, cooldown: 500 },
            { name: 'Beta Laser', manaCost: 40, cooldown: 2000 },
            { name: 'Super Speed', manaCost: 30, cooldown: 10000 },
            { name: 'Precharged Rings', manaCost: 25, cooldown: 5000 }
        ];

        // Enemy Types
        const enemyTypes = [
            { name: 'Fire', color: 'red', hatColor: 'orange' },
            { name: 'Ice', color: 'cyan', hatColor: 'blue' },
            { name: 'Shadow', color: 'black', hatColor: 'gray' },
            { name: 'Storm', color: 'yellow', hatColor: 'white' },
            { name: 'Beast', color: 'brown', hatColor: 'green' }
        ];

        // Game Object
        let game = {
            player: new Player(),
            enemies: [],
            projectiles: [],
            wave: 1,
            state: 'menu', // menu, playing, upgrade, gameover
            lastWaveTime: 0,
            upgradePool: [],
            usedUpgrades: []
        };

        // Utility Functions
        function drawLightning(sx, sy, tx, ty) {
            ctx.strokeStyle = 'yellow';
            ctx.lineWidth = 3;
            ctx.beginPath();
            let x = sx, y = sy;
            ctx.moveTo(x, y);
            while (Math.hypot(x - tx, y - ty) > 10) {
                x += (tx - x) / 10 + (Math.random() - 0.5) * 20;
                y += (ty - y) / 10 + (Math.random() - 0.5) * 20;
                ctx.lineTo(x, y);
            }
            ctx.lineTo(tx, ty);
            ctx.stroke();
        }

        function spawnWave() {
            game.enemies = [];
            const numEnemies = Math.min(1 + Math.floor(game.wave / 3), MAX_ENEMIES);
            const isBoss = game.wave % BOSS_EVERY === 0;
            if (isBoss) {
                const boss = new Enemy(Math.random() * CANVAS_WIDTH, Math.random() * CANVAS_HEIGHT, enemyTypes[Math.floor(Math.random() * enemyTypes.length)], game.player.level + 1);
                boss.size *= 1.5;
                boss.health *= 2;
                boss.color = 'darkred';
                game.enemies.push(boss);
            } else {
                for (let i = 0; i < numEnemies; i++) {
                    const type = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
                    const enemy = new Enemy(Math.random() * CANVAS_WIDTH, Math.random() * CANVAS_HEIGHT, type, game.player.level);
                    game.enemies.push(enemy);
                }
            }
        }

        function checkWaveClear() {
            const aliveEnemies = game.enemies.filter(e => !e.dead);
            if (aliveEnemies.length === 0) {
                game.player.gainXP(100 + game.wave * 10); // Wave bonus
                game.wave++;
                spawnWave();
            }
        }

        function generateUpgrades() {
            const upgradeTypes = [
                // Unlocks
                () => ({ type: 'unlock', attack: Math.floor(Math.random() * attacks.length), name: `Unlock ${attacks[attackIdx].name}` }),
                // Buffs
                () => ({ type: 'buff', target: 'atk', value: 5, name: '+5 ATK' }),
                () => ({ type: 'buff', target: 'def', value: 2, name: '+2 DEF' }),
                () => ({ type: 'buff', target: 'cooldown', attack: currentAttack, value: -50, name: '-50ms CD for ' + attacks[currentAttack].name }),
                // Stats rare
                () => ({ type: 'stat', target: 'pl', value: 1, name: '+1 PL' }),
                () => ({ type: 'shield', target: 'yield', value: -0.1, name: 'Better Shield Yield' }),
                () => ({ type: 'shield', target: 'omni', name: 'Omni Shield Regen' })
            ];
            game.upgradePool = [];
            while (game.upgradePool.length < 3) {
                const randType = upgradeTypes[Math.floor(Math.random() * upgradeTypes.length)];
                const upgrade = randType();
                if (!game.usedUpgrades.includes(upgrade.name)) { // No repeats in session
                    game.upgradePool.push(upgrade);
                }
            }
        }

        function applyUpgrade(upgrade) {
            switch (upgrade.type) {
                case 'unlock':
                    if (!game.player.unlockedAttacks.includes(upgrade.attack)) {
                        game.player.unlockedAttacks.push(upgrade.attack);
                    }
                    break;
                case 'buff':
                    if (upgrade.target === 'atk') game.player.atk += upgrade.value;
                    if (upgrade.target === 'def') game.player.def += upgrade.value;
                    if (upgrade.target === 'cooldown') {
                        // Reduce CD for specific attack
                        attacks[upgrade.attack].cooldown = Math.max(50, attacks[upgrade.attack].cooldown + upgrade.value);
                    }
                    break;
                case 'stat':
                    if (upgrade.target === 'pl' && game.player.pl < PL_CAP) game.player.pl += upgrade.value;
                    break;
                case 'shield':
                    if (upgrade.target === 'yield') game.player.shieldYield = Math.max(0.1, game.player.shieldYield + upgrade.value);
                    if (upgrade.target === 'omni') game.player.shieldOmni = true;
                    break;
            }
            game.usedUpgrades.push(upgrade.name);
        }

        function showUpgradeMenu() {
            game.state = 'upgrade';
            generateUpgrades();
            // For simplicity, auto pick one random? Or pause for input, but since no UI, auto apply one and continue
            // To keep simple, apply random one
            const chosen = game.upgradePool[Math.floor(Math.random() * 3)];
            applyUpgrade(chosen);
            console.log('Upgrade applied:', chosen.name);
            game.state = 'playing';
        }

        // UI Rendering
        function drawUI() {
            ctx.fillStyle = 'white';
            ctx.font = '16px Arial';
            ctx.fillText(`Health: ${Math.floor(game.player.health)}/${game.player.maxHealth}`, 10, 20);
            ctx.fillText(`Mana: ${Math.floor(game.player.mana)}/${game.player.maxMana}`, 10, 40);
            ctx.fillText(`PL: ${game.player.pl}`, 10, 60);
            ctx.fillText(`ATK: ${game.player.atk} DEF: ${game.player.def}`, 10, 80);
            ctx.fillText(`Level: ${game.player.level} XP: ${game.player.xp}/${game.player.xpToNext}`, 10, 100);
            ctx.fillText(`Wave: ${game.wave}`, 10, 120);

            // Spell list
            const spellDiv = document.getElementById('spellList');
            spellDiv.innerHTML = '<h3>Spells</h3>';
            attacks.forEach((atk, idx) => {
                const unlocked = game.player.unlockedAttacks.includes(idx);
                const selected = idx === game.player.selectedAttack;
                const cd = game.player.attackCooldowns[idx] || 0;
                let text = `${idx + 1 || atk.name[0].toUpperCase()}: ${atk.name}`;
                if (!unlocked) text += ' [LOCKED]';
                if (cd > 0) text += ` [CD: ${Math.ceil(cd / 60)}s]`;
                if (selected) text = `<strong style="color: green;">${text}</strong>`;
                if (idx >= 9) text = `<em>${text}</em>`; // Italic specials
                spellDiv.innerHTML += `<div>${text}</div>`;
            });

            // God mode effects
            if (game.player.pl === PL_CAP) {
                // Screen shake
                ctx.save();
                ctx.translate(Math.random() * 4 - 2, Math.random() * 4 - 2);
                // Enemy flee
                game.enemies.forEach(e => {
                    if (Math.random() < 0.1) { // Flee chance
                        const fleeAngle = Math.atan2(this.y - game.player.y, this.x - game.player.x);
                        e.x += Math.cos(fleeAngle) * e.speed * 2;
                        e.y += Math.sin(fleeAngle) * e.speed * 2;
                    }
                });
            }
        }

        function drawMenu() {
            const menu = document.getElementById('menu');
            menu.style.display = 'block';
            if (game.state === 'attributes') {
                document.getElementById('attributes').innerHTML = `
                    <p>Level: ${game.player.level}</p>
                    <p>PL: ${game.player.pl}</p>
                    <p>ATK: ${game.player.atk} DEF: ${game.player.def}</p>
                    <p>Unlocked Spells: ${game.player.unlockedAttacks.map(i => attacks[i].name).join(', ')}</p>
                `;
            }
        }

        function startGame() {
            game.state = 'playing';
            document.getElementById('menu').style.display = 'none';
            game.player = new Player(); // Reset
            game.wave = 1;
            spawnWave();
            loadSave();
        }

        function viewAttributes() {
            game.state = 'attributes';
        }

        // Save/Load
        function saveGame() {
            const saveData = {
                level: game.player.level,
                pl: game.player.pl,
                atk: game.player.atk,
                def: game.player.def,
                unlockedAttacks: game.player.unlockedAttacks,
                xp: game.player.xp,
                xpToNext: game.player.xpToNext
            };
            localStorage.setItem('alternateSave', JSON.stringify(saveData));
        }

        function loadSave() {
            const saved = localStorage.getItem('alternateSave');
            if (saved) {
                const data = JSON.parse(saved);
                game.player.level = data.level || 1;
                game.player.pl = Math.min(data.pl || 1, PL_CAP);
                game.player.atk = data.atk || 20;
                game.player.def = data.def || 10;
                game.player.unlockedAttacks = data.unlockedAttacks || [0];
                game.player.xp = data.xp || 0;
                game.player.xpToNext = data.xpToNext || 100;
                // Recalc max etc.
                game.player.maxHealth = 100 + (game.player.level - 1) * 10;
                game.player.maxMana = 100 + (game.player.level - 1) * 10;
            }
        }

        // Game Loop
        function gameLoop() {
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            if (game.state === 'menu' || game.state === 'attributes') {
                drawMenu();
            } else if (game.state === 'playing') {
                // Update
                game.player.update();

                game.enemies.forEach(e => e.update());
                game.enemies = game.enemies.filter(e => !e.dead);

                game.projectiles.forEach(p => p.update());
                game.projectiles = game.projectiles.filter(p => p.life > 0);

                particles.forEach(p => p.update());
                particles = particles.filter(p => p.life > 0);

                // Check wave
                checkWaveClear();

                // Game over
                if (game.player.health <= 0) {
                    explodeIntoBlood(game.player);
                    game.state = 'gameover';
                    localStorage.removeItem('alternateSave'); // Wipe on death
                }

                // Auto save
                saveGame();

                // Draw
                game.player.draw();
                game.enemies.forEach(e => e.draw());
                game.projectiles.forEach(p => p.draw());
                particles.forEach(p => p.draw());

                drawUI();

                // God PL screen shake restore
                if (game.player.pl < PL_CAP) ctx.restore();
            } else if (game.state === 'gameover') {
                ctx.fillStyle = 'white';
                ctx.font = '32px Arial';
                ctx.fillText('Game Over', CANVAS_WIDTH / 2 - 100, CANVAS_HEIGHT / 2);
                ctx.font = '16px Arial';
                ctx.fillText('Refresh to restart', CANVAS_WIDTH / 2 - 80, CANVAS_HEIGHT / 2 + 30);
            }

            if (game.state === 'playing') {
                // Sound placeholders
                console.log('Pew pew'); // Placeholder
            }

            requestAnimationFrame(gameLoop);
        }

        // Init
        loadSave();
        gameLoop();

        // Global functions for buttons
        window.startGame = startGame;
        window.viewAttributes = viewAttributes;
    </script>
</body>
</html>
