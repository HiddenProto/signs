<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alternate's Magical Evolution</title>
    <style>
        body { margin: 0; padding: 0; background: black; color: white; font-family: monospace; }
        canvas { display: block; margin: 0 auto; border: 1px solid white; }
        #ui { position: absolute; top: 10px; left: 10px; z-index: 10; }
        #right-ui { position: absolute; top: 10px; right: 10px; z-index: 10; }
        #bottom-ui { position: absolute; bottom: 10px; left: 10px; width: 780px; z-index: 10; }
        #menu { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; z-index: 20; }
        button { background: #333; color: white; border: 1px solid white; padding: 10px; margin: 5px; cursor: pointer; }
        button:hover { background: #555; }
        .hidden { display: none; }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="ui">
        <div>Health: <span id="health">100</span>/100</div>
        <div>Mana: <span id="mana">100</span>/100</div>
        <div>PL: <span id="pl">1</span></div>
        <div>ATK: <span id="atk">1</span> DEF: <span id="def">1</span></div>
        <div>Level: <span id="level">1</span> XP: <span id="xp">0</span></div>
    </div>
    <div id="right-ui">
        <div id="spellList"></div>
    </div>
    <div id="bottom-ui">
        <div>Controls: WASD/Arrows Move | Mouse Aim & Click Fire | , Cycle Attack | SPACE Hold Shield</div>
    </div>
    <div id="menu">
        <h1>Alternate's Magical Evolution</h1>
        <button onclick="startGame()">Play</button>
        <button onclick="viewAttributes()">Attributes</button>
        <div id="attributes" class="hidden"></div>
    </div>
    <div id="levelup" class="hidden">
        <h2>Level Up! Choose Upgrade:</h2>
        <div id="upgrades"></div>
    </div>
    <div id="gameover" class="hidden">
        <h2>Game Over!</h2>
        <button onclick="restartGame()">Restart</button>
    </div>

    <script>
        // Game Constants
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 600;
        const FPS = 60;
        const PLAYER_SIZE = 20;
        const ENEMY_SIZE = 20;
        const PROJECTILE_SPEED = 8;
        const MAX_WAVES = Infinity; // Endless
        const WAVE_ENEMIES = { base: 1, increment: 1, every: 3, max: 6 };
        const BOSS_EVERY = 5;
        const PL_CAP = 16;
        const MANA_REGEN = 20 / FPS; // Approx 20/sec
        const HEALTH_REGEN = 1 / FPS; // Slow regen
        const SHIELD_RADIUS = 40;
        const SHIELD_YIELD = 1.0; // Initial, upgrades reduce
        const SHIELD_DRAIN_MULTIPLIER = 1.0; // Mana drain per absorbed dmg
        const SHIELD_REGEN_RATE = 5 / FPS; // Base regen
        const SHIELD_FAST_REGEN = 10 / FPS; // If depleted
        const SHIELD_MAX_DUR = 100;
        const BLOOD_PARTICLES = 20; // On death
        const EXPLOSION_PARTICLES = 50; // More blood

        // Input Handling
        const keys = {};
        const mouse = { x: 0, y: 0, down: false };
        document.addEventListener('keydown', (e) => { keys[e.key.toLowerCase()] = true; if (e.key === ',') cycleAttack(); });
        document.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });
        document.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
        });
        document.addEventListener('mousedown', () => { mouse.down = true; });
        document.addEventListener('mouseup', () => { mouse.down = false; });

        // Canvas Setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false; // For pixel art feel

        // Game State
        let gameState = 'menu'; // menu, playing, levelup, gameover
        let player;
        let enemies = [];
        let projectiles = [];
        let particles = [];
        let wave = 0;
        let level = 1;
        let xp = 0;
        let xpToNext = 100;
        let abilities = [];
        let currentAbilityIndex = 0;
        let shieldActive = false;
        let shieldDurability = SHIELD_MAX_DUR;
        let lastTime = 0;
        let saveData = {};

        // Load Saves
        function loadSave() {
            const saved = localStorage.getItem('alternateSave');
            if (saved) {
                saveData = JSON.parse(saved);
                level = saveData.level || 1;
                xp = saveData.xp || 0;
                xpToNext = saveData.xpToNext || 100;
                player.pl = saveData.pl || 1;
                player.atk = saveData.atk || 1;
                player.def = saveData.def || 1;
                // Restore unlocked abilities
                abilities = initializeAbilities();
                saveData.unlocked.forEach(id => {
                    const ab = abilities.find(a => a.id === id);
                    if (ab) ab.unlocked = true;
                });
                updateUI();
            }
        }

        // Save Game
        function saveGame() {
            saveData = {
                level,
                xp,
                xpToNext,
                pl: player.pl,
                atk: player.atk,
                def: player.def,
                unlocked: abilities.filter(a => a.unlocked).map(a => a.id)
            };
            localStorage.setItem('alternateSave', JSON.stringify(saveData));
        }

        // Initialize Abilities
        function initializeAbilities() {
            return [
                { id: 1, name: 'Magic Shot', key: '1', unlocked: true, cd: 200, manaCost: 5, effect: magicShotEffect, animation: basicOrbAnim },
                { id: 2, name: 'Tri-Shot', key: '2', unlocked: false, cd: 300, manaCost: 10, effect: triShotEffect, animation: spreadAnim },
                { id: 3, name: 'Beam Shot', key: '3', unlocked: false, cd: 800, manaCost: 20, effect: beamShotEffect, animation: laserAnim },
                { id: 4, name: 'Ice Shard', key: '4', unlocked: false, cd: 400, manaCost: 8, effect: iceShardEffect, animation: triangleAnim },
                { id: 5, name: 'Lightning', key: '5', unlocked: false, cd: 600, manaCost: 15, effect: lightningEffect, animation: zigZagAnim },
                { id: 6, name: 'Curve Shot', key: '6', unlocked: false, cd: 350, manaCost: 12, effect: curveShotEffect, animation: arcAnim },
                { id: 7, name: 'Shield Breaker', key: '7', unlocked: false, cd: 1000, manaCost: 25, effect: shieldBreakerEffect, animation: empAnim },
                { id: 8, name: 'Homing Missile', key: '8', unlocked: false, cd: 500, manaCost: 18, effect: homingMissileEffect, animation: rocketAnim },
                { id: 9, name: 'Force Wave', key: '9', unlocked: false, cd: 700, manaCost: 22, effect: forceWaveEffect, animation: shockwaveAnim },
                { id: 10, name: 'Penta Shot', key: 'c', unlocked: false, cd: 150, manaCost: 15, effect: pentaShotEffect, animation: spreadAnim },
                { id: 11, name: 'Recursive Shot', key: 'v', unlocked: false, cd: 900, manaCost: 30, effect: recursiveShotEffect, animation: bounceAnim },
                { id: 12, name: 'Shield Attack', key: 'b', unlocked: false, cd: 1200, manaCost: 35, effect: shieldAttackEffect, animation: reflectAnim },
                { id: 13, name: 'Beta Laser', key: 'n', unlocked: false, cd: 1500, manaCost: 50, effect: betaLaserEffect, animation: thickLaserAnim },
                { id: 14, name: 'Super Speed', key: 'm', unlocked: false, cd: 3000, manaCost: 40, effect: superSpeedEffect, animation: speedTrailAnim },
                { id: 15, name: 'Precharged Rings', key: 'q', unlocked: false, cd: 5000, manaCost: 60, effect: prechargedRingsEffect, animation: ringAnim }
            ];
        }

        // Player Class
        class Player {
            constructor() {
                this.x = CANVAS_WIDTH / 2;
                this.y = CANVAS_HEIGHT / 2;
                this.health = 100;
                this.maxHealth = 100;
                this.mana = 100;
                this.maxMana = 100;
                this.speed = 3;
                this.pl = 1;
                this.atk = 1;
                this.def = 1;
                this.size = PLAYER_SIZE;
                this.color = 'blue';
                this.ringsActive = false;
                this.ringBalls = []; // For precharged rings
                this.superSpeed = false;
                this.speedTimer = 0;
                this.invulnFrames = 0;
                this.lastAttack = 0;
            }

            update(dt) {
                // Movement
                let dx = 0, dy = 0;
                if (keys['w'] || keys['arrowup']) dy -= this.speed;
                if (keys['s'] || keys['arrowdown']) dy += this.speed;
                if (keys['a'] || keys['arrowleft']) dx -= this.speed;
                if (keys['d'] || keys['arrowright']) dx += this.speed;
                if (this.superSpeed) {
                    dx *= 2;
                    dy *= 2;
                }
                this.x = Math.max(this.size / 2, Math.min(CANVAS_WIDTH - this.size / 2, this.x + dx * dt));
                this.y = Math.max(this.size / 2, Math.min(CANVAS_HEIGHT - this.size / 2, this.y + dy * dt));

                // Regen
                this.health = Math.min(this.maxHealth, this.health + HEALTH_REGEN * dt);
                this.mana = Math.min(this.maxMana, this.mana + MANA_REGEN * dt);

                // Shield
                shieldActive = keys[' '];
                if (shieldActive) {
                    // Drain or regen based on dur
                    if (shieldDurability > 0) {
                        // Active, but no drain unless hit
                    } else {
                        shieldDurability = Math.min(SHIELD_MAX_DUR, shieldDurability + SHIELD_FAST_REGEN * dt);
                    }
                } else {
                    shieldDurability = Math.min(SHIELD_MAX_DUR, shieldDurability + SHIELD_REGEN_RATE * dt);
                }

                // Super Speed Timer
                if (this.speedTimer > 0) {
                    this.speedTimer -= dt;
                    if (this.speedTimer <= 0) {
                        this.superSpeed = false;
                        if (this.pl >= 12) this.invulnFrames = 0;
                    }
                }

                // Invuln Frames
                if (this.invulnFrames > 0) this.invulnFrames -= dt;

                // Fire Attack
                if (mouse.down && Date.now() - this.lastAttack > abilities[currentAbilityIndex].cd) {
                    const ab = abilities[currentAbilityIndex];
                    if (this.mana >= ab.manaCost && ab.unlocked) {
                        ab.effect(this, mouse);
                        this.mana -= ab.manaCost;
                        this.lastAttack = Date.now();
                        // If rings active, enhance default shot
                        if (this.ringsActive && ab.id === 1) {
                            // Unload rings
                            this.ringBalls.forEach(ball => {
                                createExplosion(ball.x, ball.y, 'red', 10, 20);
                                enemies.forEach(enemy => {
                                    const dist = Math.hypot(enemy.x - ball.x, enemy.y - ball.y);
                                    if (dist < 50) {
                                        const dmg = this.atk * 3; // Way more damage
                                        enemy.takeDamage(dmg, this);
                                    }
                                });
                            });
                            this.ringsActive = false;
                            this.ringBalls = [];
                        }
                    }
                }

                // Ram with rings
                if (this.ringsActive && this.ringBalls.length > 0) {
                    enemies.forEach(enemy => {
                        const dist = Math.hypot(this.x - enemy.x, this.y - enemy.y);
                        if (dist < this.size + ENEMY_SIZE) {
                            // Explode rings, hurt enemy and self
                            this.ringBalls.forEach(ball => {
                                createExplosion(ball.x, ball.y, 'red', 15, 30);
                                const selfDmg = this.atk * 0.5; // Hurt self
                                this.health -= selfDmg;
                                const enemyDmg = this.atk * 2;
                                enemy.takeDamage(enemyDmg, this);
                            });
                            this.ringsActive = false;
                            this.ringBalls = [];
                        }
                    });
                }
            }

            takeDamage(dmg, source) {
                if (this.invulnFrames > 0) return;
                let finalDmg = Math.max(1, dmg - this.def);
                finalDmg *= (1 - (this.pl / 16) * 0.05); // PL reduces dmg taken? Wait, prompt PL boosts atk ignore def
                // Actually, PL ignores 5% def per? But simplify
                if (shieldActive && shieldDurability > 0) {
                    const absorbed = Math.min(finalDmg, shieldDurability);
                    shieldDurability -= absorbed;
                    this.mana -= absorbed * SHIELD_DRAIN_MULTIPLIER;
                    createParticles(source.x, source.y, 'green', 5); // Sparks
                    if (source.reflectable) {
                        // Reflect back
                        const reflectProj = new Projectile(source.x, source.y, this.x, this.y, source.dmg, source.color, true);
                        reflectProj.reflectable = true;
                        projectiles.push(reflectProj);
                    }
                    finalDmg -= absorbed;
                }
                this.health -= finalDmg;
                createBlood(this.x, this.y, finalDmg * 2); // Blood splatter
                if (this.health <= 0) {
                    gameOver();
                }
            }

            draw() {
                // Player square
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - this.size / 2, this.y - this.size / 2, this.size, this.size);
                // Aim line
                ctx.strokeStyle = 'gray';
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(mouse.x, mouse.y);
                ctx.stroke();

                // Shield
                if (shieldActive) {
                    ctx.strokeStyle = `rgba(0,255,0,${Math.min(1, shieldDurability / SHIELD_MAX_DUR)})`;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, SHIELD_RADIUS, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Rings
                if (this.ringsActive) {
                    this.ringBalls.forEach(ball => {
                        ctx.fillStyle = 'purple';
                        ctx.beginPath();
                        ctx.arc(ball.x, ball.y, 5, 0, Math.PI * 2);
                        ctx.fill();
                    });
                }

                // Speed trails
                if (this.superSpeed) {
                    createTrail(this.x, this.y, 'yellow', 10);
                }
            }
        }

        // Enemy Class
        class Enemy {
            constructor(x, y, type, pl) {
                this.x = x;
                this.y = y;
                this.type = type || 'basic'; // fire, ice, shadow, storm, beast
                this.pl = pl || 1;
                this.health = 50 + level * 20;
                this.maxHealth = this.health;
                this.speed = 1 + level * 0.2;
                this.atk = 10 + level * 5;
                this.def = 1; // Start 1
                this.size = ENEMY_SIZE;
                this.color = { basic: 'gray', fire: 'red', ice: 'cyan', shadow: 'purple', storm: 'yellow', beast: 'green' }[this.type] || 'gray';
                this.shieldDur = 0; // At PL4+
                if (this.pl >= 4) this.shieldDur = 50 + this.pl * 10;
                this.shieldMaxDur = this.shieldDur;
                this.lastAttack = 0;
                this.attackCd = 3000 - this.pl * 100; // Faster with PL
                this.dodgeChance = 0.02 * this.pl;
                this.aiComplexity = Math.min(1, this.pl / 16); // 0-1
                this.currentAbility = 0; // Cycle through abilities based on PL
                this.abilities = this.getAbilitiesForPL();
                this.slowed = 0; // For ice
                this.burn = 0; // For beta
                this.reflectable = false;
                this.lastDodge = 0;
            }

            getAbilitiesForPL() {
                // Enemies use multiple, based on PL
                let abs = [0]; // 0 = basic shot
                if (this.pl >= 2) abs.push(1); // Tri
                if (this.pl >= 3) abs.push(2); // Beam
                if (this.pl >= 4) abs.push(3); // Ice
                if (this.pl >= 5) abs.push(4); // Lightning
                if (this.pl >= 6) abs.push(5); // Curve
                if (this.pl >= 7) abs.push(6); // Breaker
                if (this.pl >= 8) abs.push(7); // Homing
                if (this.pl >= 9) abs.push(8); // Wave
                if (this.pl >= 10) abs.push(9); // Penta
                if (this.pl >= 11) abs.push(10); // Recursive
                if (this.pl >= 12) abs.push(11); // Shield atk
                if (this.pl >= 13) abs.push(12); // Beta
                if (this.pl >= 14) abs.push(13); // Speed
                if (this.pl >= 15) abs.push(14); // Rings
                return abs.map(id => ({...abilities.find(a => a.id === id), effect: enemyEffectWrapper(a.effect)}));
            }

            update(dt) {
                // DoT
                if (this.burn > 0) {
                    this.health -= this.atk * 0.1 * dt / 1000; // Per sec
                    this.burn -= dt;
                    createParticles(this.x, this.y, 'orange', 1);
                }
                if (this.slowed > 0) {
                    this.slowed -= dt;
                }

                // Regen shield if not active
                if (this.shieldDur < this.shieldMaxDur) {
                    this.shieldDur = Math.min(this.shieldMaxDur, this.shieldDur + SHIELD_REGEN_RATE * dt * this.pl);
                }

                // AI
                const distToPlayer = Math.hypot(player.x - this.x, player.y - this.y);
                let moveX = 0, moveY = 0;

                // Chase/Predict
                if (distToPlayer > 30) {
                    const targetX = player.x + (Math.random() - 0.5) * 20 * this.aiComplexity; // Predict
                    const targetY = player.y + (Math.random() - 0.5) * 20 * this.aiComplexity;
                    const dx = (targetX - this.x) / distToPlayer;
                    const dy = (targetY - this.y) / distToPlayer;
                    moveX = dx * this.speed * (this.slowed > 0 ? 0.5 : 1);
                    moveY = dy * this.speed * (this.slowed > 0 ? 0.5 : 1);
                } else {
                    // Melee
                    const angle = Math.atan2(player.y - this.y, player.x - this.x);
                    moveX = Math.cos(angle) * this.speed * 1.5;
                    moveY = Math.sin(angle) * this.speed * 1.5;
                    // Attack melee
                    if (Date.now() - this.lastAttack > 500) {
                        player.takeDamage(this.atk, this);
                        this.lastAttack = Date.now();
                    }
                }

                // Dodge
                if (Date.now() - this.lastDodge > 1000 / this.pl && Math.random() < this.dodgeChance) {
                    const dodgeAngle = Math.random() * Math.PI * 2;
                    moveX += Math.cos(dodgeAngle) * this.speed * 2;
                    moveY += Math.sin(dodgeAngle) * this.speed * 2;
                    this.lastDodge = Date.now();
                }

                this.x += moveX * dt / 16; // Normalize to 60fps
                this.y += moveY * dt / 16;
                this.x = Math.max(this.size / 2, Math.min(CANVAS_WIDTH - this.size / 2, this.x));
                this.y = Math.max(this.size / 2, Math.min(CANVAS_HEIGHT - this.size / 2, this.y));

                // Ranged Attack
                if (Date.now() - this.lastAttack > this.attackCd && distToPlayer > 30) {
                    const ab = this.abilities[this.currentAbility % this.abilities.length];
                    ab.effect(this, {x: player.x, y: player.y});
                    this.lastAttack = Date.now();
                    this.currentAbility++;
                }

                // Flee at PL16 player
                if (player.pl >= PL_CAP && Math.random() < 0.1) {
                    const fleeAngle = Math.atan2(this.y - player.y, this.x - player.x);
                    moveX = Math.cos(fleeAngle) * this.speed;
                    moveY = Math.sin(fleeAngle) * this.speed;
                    this.x += moveX * dt / 16;
                    this.y += moveY * dt / 16;
                }
            }

            takeDamage(dmg, source) {
                let finalDmg = Math.max(1, dmg - this.def);
                finalDmg *= (1 + source.pl / 16); // PL boosts
                if (this.shieldDur > 0) {
                    const absorbed = Math.min(finalDmg, this.shieldDur);
                    this.shieldDur -= absorbed;
                    finalDmg -= absorbed;
                    if (source.id === 7) { // Shield breaker
                        this.shieldDur = 0; // Break
                    }
                }
                this.health -= finalDmg;
                createBlood(this.x, this.y, finalDmg * 3);
                if (this.health <= 0) {
                    createExplosion(this.x, this.y, this.color, EXPLOSION_PARTICLES, 5); // More blood
                    xp += 10 + level * 5;
                    enemies.splice(enemies.indexOf(this), 1);
                    if (enemies.length === 0) {
                        waveComplete();
                    }
                }
            }

            draw() {
                // Enemy square
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - this.size / 2, this.y - this.size / 2, this.size, this.size);
                // Health bar
                const barWidth = 20;
                const barHeight = 4;
                ctx.fillStyle = 'red';
                ctx.fillRect(this.x - barWidth / 2, this.y - this.size / 2 - 6, barWidth, barHeight);
                ctx.fillStyle = 'green';
                ctx.fillRect(this.x - barWidth / 2, this.y - this.size / 2 - 6, (this.health / this.maxHealth) * barWidth, barHeight);

                // Shield
                if (this.shieldDur > 0) {
                    ctx.strokeStyle = `rgba(255,255,255,${Math.min(1, this.shieldDur / this.shieldMaxDur)})`;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, SHIELD_RADIUS - 10, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Slow effect
                if (this.slowed > 0) {
                    ctx.strokeStyle = 'rgba(0,255,255,0.5)';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 30, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Burn
                if (this.burn > 0) {
                    ctx.fillStyle = 'orange';
                    ctx.beginPath();
                    ctx.arc(this.x + Math.random() * 10 - 5, this.y + Math.random() * 10 - 5, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        // Projectile Class
        class Projectile {
            constructor(x, y, tx, ty, dmg, color, reflectable = false) {
                this.x = x;
                this.y = y;
                this.vx = (tx - x) / Math.hypot(tx - x, ty - y) * PROJECTILE_SPEED;
                this.vy = (ty - y) / Math.hypot(tx - x, ty - y) * PROJECTILE_SPEED;
                this.dmg = dmg;
                this.color = color;
                this.size = 4;
                this.reflectable = reflectable;
                this.bounces = 0;
                this.maxBounces = 0;
                this.splashRadius = 0;
                this.chainTargets = 0;
                this.slowAmount = 0;
                this.burnTime = 0;
                this.pierce = false;
                this.homing = 0;
                this.curve = 0;
            }

            update(dt) {
                this.x += this.vx * dt / 16;
                this.y += this.vy * dt / 16;

                // Homing
                if (this.homing > 0) {
                    let closestEnemy = null;
                    let minDist = Infinity;
                    enemies.forEach(e => {
                        const dist = Math.hypot(e.x - this.x, e.y - this.y);
                        if (dist < minDist) {
                            minDist = dist;
                            closestEnemy = e;
                        }
                    });
                    if (closestEnemy && minDist < 100) {
                        const angle = Math.atan2(closestEnemy.y - this.y, closestEnemy.x - this.x);
                        this.vx = Math.cos(angle) * PROJECTILE_SPEED;
                        this.vy = Math.sin(angle) * PROJECTILE_SPEED;
                    }
                }

                // Curve
                if (this.curve > 0) {
                    this.vy += Math.sin(Date.now() / 100) * 0.1; // Simple arc
                }

                // Walls bounce for recursive
                if (this.maxBounces > this.bounces) {
                    if (this.x < 0 || this.x > CANVAS_WIDTH) {
                        this.vx *= -1;
                        this.bounces++;
                    }
                    if (this.y < 0 || this.y > CANVAS_HEIGHT) {
                        this.vy *= -1;
                        this.bounces++;
                    }
                }

                // Collisions
                // Player shield reflect
                const playerDist = Math.hypot(player.x - this.x, player.y - this.y);
                if (playerDist < SHIELD_RADIUS && shieldActive && shieldDurability > 0 && this.reflectable) {
                    // Reflect
                    const angle = Math.atan2(player.y - this.y, player.x - this.x);
                    this.vx = Math.cos(angle + Math.PI) * PROJECTILE_SPEED * -1;
                    this.vy = Math.sin(angle + Math.PI) * PROJECTILE_SPEED * -1;
                    shieldDurability -= this.dmg;
                    player.mana -= this.dmg * SHIELD_DRAIN_MULTIPLIER;
                    projectiles.splice(projectiles.indexOf(this), 1);
                    const reflect = new Projectile(player.x, player.y, this.x, this.y, this.dmg, this.color, true);
                    reflect.reflectable = true;
                    projectiles.push(reflect);
                    return;
                }

                // Hit enemies
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    const dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                    if (dist < enemy.size / 2 + this.size) {
                        enemy.takeDamage(this.dmg, player);
                        if (this.splashRadius > 0) {
                            // Splash
                            enemies.forEach(e => {
                                const splashDist = Math.hypot(e.x - this.x, e.y - this.y);
                                if (splashDist < this.splashRadius) {
                                    e.takeDamage(this.dmg * 0.5, player);
                                }
                            });
                        }
                        if (this.chainTargets > 0) {
                            // Chain lightning
                            let chained = [enemy];
                            for (let c = 0; c < this.chainTargets; c++) {
                                let nextTarget = null;
                                let minDist = Infinity;
                                enemies.forEach(e => {
                                    if (!chained.includes(e)) {
                                        const edist = Math.hypot(e.x - chained[chained.length - 1].x, e.y - chained[chained.length - 1].y);
                                        if (edist < minDist && edist < 50 + player.pl * 5) {
                                            minDist = edist;
                                            nextTarget = e;
                                        }
                                    }
                                });
                                if (nextTarget) {
                                    chained.push(nextTarget);
                                    nextTarget.takeDamage(this.dmg * 0.8, player);
                                    // Draw lightning zig zag
                                    drawLightning(chained[chained.length - 2].x, chained[chained.length - 2].y, nextTarget.x, nextTarget.y);
                                } else break;
                            }
                        }
                        if (this.slowAmount > 0) {
                            enemy.slowed = 2000; // 2s
                        }
                        if (this.burnTime > 0) {
                            enemy.burn = this.burnTime;
                        }
                        if (!this.pierce) {
                            projectiles.splice(projectiles.indexOf(this), 1);
                            break;
                        }
                    }
                }

                // Hit player
                if (playerDist < player.size / 2 + this.size && player.invulnFrames <= 0) {
                    player.takeDamage(this.dmg, {x: this.x, y: this.y, reflectable: false});
                    if (!this.pierce) projectiles.splice(projectiles.indexOf(this), 1);
                }

                // Other projectiles collision
                for (let i = projectiles.length - 1; i >= 0; i--) {
                    const other = projectiles[i];
                    if (other !== this && Math.hypot(other.x - this.x, other.y - this.y) < this.size + other.size) {
                        // Collide, explode
                        createExplosion((this.x + other.x)/2, (this.y + other.y)/2, 'white', 10, 3);
                        projectiles.splice(projectiles.indexOf(this), 1);
                        projectiles.splice(i, 1);
                        break;
                    }
                }

                // Out of bounds
                if (this.x < -50 || this.x > CANVAS_WIDTH + 50 || this.y < -50 || this.y > CANVAS_HEIGHT + 50) {
                    projectiles.splice(projectiles.indexOf(this), 1);
                }
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                // Trail
                ctx.fillStyle = this.color + '80';
                ctx.beginPath();
                ctx.arc(this.x - this.vx * 2, this.y - this.vy * 2, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Particle Class
        class Particle {
            constructor(x, y, vx, vy, life, color, size = 2) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.life = life;
                this.maxLife = life;
                this.color = color;
                this.size = size;
            }

            update(dt) {
                this.x += this.vx * dt / 16;
                this.y += this.vy * dt / 16;
                this.vy += 0.1 * dt / 16; // Gravity
                this.life -= dt;
                return this.life > 0;
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.globalAlpha = this.life / this.maxLife;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        // Effects and Animations
        function magicShotEffect(caster, target) {
            const proj = new Projectile(caster.x, caster.y, target.x, target.y, caster.atk, 'orange');
            proj.homing = caster.pl * 0.1; // Slight at high PL
            projectiles.push(proj);
        }

        function triShotEffect(caster, target) {
            const angle = Math.atan2(target.y - caster.y, target.x - caster.x);
            for (let i = -1; i <= 1; i++) {
                const a = angle + i * 0.5;
                const proj = new Projectile(caster.x, caster.y, caster.x + Math.cos(a) * 100, caster.y + Math.sin(a) * 100, caster.atk, 'blue');
                projectiles.push(proj);
            }
        }

        function beamShotEffect(caster, target) {
            const proj = new Projectile(caster.x, caster.y, target.x, target.y, caster.atk * 5, 'white', true);
            proj.pierce = true;
            proj.size = 2;
            projectiles.push(proj);
            // Stun at PL8+
            if (caster.pl >= 8) {
                // Apply stun to hit enemies, but since pierce, on collision
                proj.stun = 1000;
            }
            // Draw beam animation
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(caster.x, caster.y);
            ctx.lineTo(target.x, target.y);
            ctx.stroke();
        }

        function iceShardEffect(caster, target) {
            const proj = new Projectile(caster.x, caster.y, target.x, target.y, caster.atk, 'cyan');
            proj.slowAmount = 0.5;
            proj.shape = 'triangle'; // For anim
            projectiles.push(proj);
        }

        function lightningEffect(caster, target) {
            // Direct hit first
            const dist = Math.hypot(target.x - caster.x, target.y - caster.y);
            const proj = new Projectile(caster.x, caster.y, target.x, target.y, caster.atk * 2, 'yellow');
            proj.chainTargets = 3 + caster.pl / 4; // Chains
            if (caster.pl >= 10) proj.dot = true;
            projectiles.push(proj);
            // Draw lightning
            drawLightning(caster.x, caster.y, target.x, target.y);
        }

        function drawLightning(sx, sy, ex, ey, segments = 10) {
            ctx.strokeStyle = 'yellow';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(sx, sy);
            let x = sx, y = sy;
            for (let i = 0; i < segments; i++) {
                x += (ex - sx) / segments + (Math.random() - 0.5) * 20;
                y += (ey - sy) / segments + (Math.random() - 0.5) * 20;
                ctx.lineTo(x, y);
            }
            ctx.lineTo(ex, ey);
            ctx.stroke();
        }

        function curveShotEffect(caster, target) {
            const proj = new Projectile(caster.x, caster.y, target.x, target.y, caster.atk, 'green');
            proj.curve = 1;
            projectiles.push(proj);
        }

        function shieldBreakerEffect(caster, target) {
            // Big white EMP ball around player
            const radius = 100 + caster.pl * 10;
            enemies.forEach(enemy => {
                const dist = Math.hypot(enemy.x - caster.x, enemy.y - caster.y);
                if (dist < radius) {
                    let dmg = 20 + caster.atk;
                    enemy.shieldDur -= 50 + caster.pl * 10; // Break shields
                    enemy.takeDamage(dmg, caster);
                }
            });
            // Animation: white circle pulse
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.beginPath();
            ctx.arc(caster.x, caster.y, radius, 0, Math.PI * 2);
            ctx.fill();
        }

        function homingMissileEffect(caster, target) {
            const proj = new Projectile(caster.x, caster.y, target.x, target.y, caster.atk * 1.5, 'red');
            proj.homing = 1;
            if (caster.pl >= 6) proj.splashRadius = 30;
            projectiles.push(proj);
        }

        function forceWaveEffect(caster, target) {
            const angle = Math.atan2(target.y - caster.y, target.x - caster.x);
            for (let i = 0; i < 10; i++) {
                const a = angle + (i - 5) * 0.3;
                const proj = new Projectile(caster.x, caster.y, caster.x + Math.cos(a) * 200, caster.y + Math.sin(a) * 200, caster.atk * 0.8, 'blue');
                proj.knockback = true;
                projectiles.push(proj);
            }
        }

        function pentaShotEffect(caster, target) {
            const angle = Math.atan2(target.y - caster.y, target.x - caster.x);
            for (let i = -2; i <= 2; i++) {
                const a = angle + i * 0.4;
                const proj = new Projectile(caster.x, caster.y, caster.x + Math.cos(a) * 100, caster.y + Math.sin(a) * 100, caster.atk, 'blue');
                projectiles.push(proj);
            }
        }

        function recursiveShotEffect(caster, target) {
            const proj = new Projectile(caster.x, caster.y, target.x, target.y, caster.atk, 'purple');
            proj.maxBounces = 3 + caster.pl;
            projectiles.push(proj);
        }

        function shieldAttackEffect(caster, target) {
            const proj = new Projectile(caster.x, caster.y, target.x, target.y, caster.atk * 2, 'green');
            proj.ignoreShield = true;
            proj.reflectable = true; // Can reflect enemy shots? Wait, it's shield proj
            projectiles.push(proj);
        }

        function betaLaserEffect(caster, target) {
            const proj = new Projectile(caster.x, caster.y, target.x, target.y, caster.atk * 3, 'red');
            proj.pierce = true;
            proj.size = 6;
            proj.burnTime = 3000; // 3s
            projectiles.push(proj);
        }

        function superSpeedEffect(caster, target) {
            caster.superSpeed = true;
            caster.speedTimer = 5000; // 5s
            if (caster.pl >= 12) caster.invulnFrames = 5000;
        }

        function prechargedRingsEffect(caster, target) {
            caster.ringsActive = true;
            caster.ringBalls = [];
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                caster.ringBalls.push({
                    x: caster.x + Math.cos(angle) * 50,
                    y: caster.y + Math.sin(angle) * 50
                });
            }
        }

        function enemyEffectWrapper(effect) {
            return (caster, target) => {
                effect(caster, target);
                // Enemy version, perhaps adjust
            };
        }

        // Utility Functions
        function createBlood(x, y, count) {
            for (let i = 0; i < count; i++) {
                particles.push(new Particle(x, y, (Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10 - 2, 1000, 'red', 1 + Math.random() * 3));
            }
        }

        function createExplosion(x, y, color, count, speed) {
            for (let i = 0; i < count; i++) {
                const angle = (i / count) * Math.PI * 2;
                const vx = Math.cos(angle) * speed;
                const vy = Math.sin(angle) * speed;
                particles.push(new Particle(x, y, vx, vy, 800, color));
            }
        }

        function createParticles(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                particles.push(new Particle(x, y, (Math.random() - 0.5) * 4, (Math.random() - 0.5) * 4, 500, color));
            }
        }

        function createTrail(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                particles.push(new Particle(x, y, (Math.random() - 0.5) * 2, (Math.random() - 0.5) * 2, 300, color, 1));
            }
        }

        // Animation Helpers (simple, since squares)
        function basicOrbAnim() { /* glow */ }
        function spreadAnim() { /* fan */ }
        function laserAnim() { /* line glow */ }
        function triangleAnim() { /* triangle draw */ ctx.fillStyle = 'cyan'; /* etc */ }
        function zigZagAnim() { /* lightning draw */ }
        function arcAnim() { /* curve line */ }
        function empAnim() { /* pulse circle */ }
        function rocketAnim() { /* trail */ }
        function shockwaveAnim() { /* expanding circle */ }
        function bounceAnim() { /* bounce effect */ }
        function reflectAnim() { /* mirror */ }
        function thickLaserAnim() { /* thick line */ }
        function speedTrailAnim() { /* streaks */ }
        function ringAnim() { /* circles */ }

        // Game Flow
        function startGame() {
            gameState = 'playing';
            document.getElementById('menu').classList.add('hidden');
            player = new Player();
            loadSave();
            wave = 0;
            nextWave();
            updateUI();
        }

        function viewAttributes() {
            const attrs = document.getElementById('attributes');
            attrs.innerHTML = `
                <p>Level: ${level} | PL: ${player.pl} | ATK: ${player.atk} | DEF: ${player.def}</p>
                <p>Health: ${player.health}/${player.maxHealth} | Mana: ${player.mana}/${player.maxMana}</p>
                <button onclick="document.getElementById('attributes').classList.add('hidden')">Close</button>
            `;
            attrs.classList.remove('hidden');
        }

        function nextWave() {
            wave++;
            const numEnemies = Math.min(WAVE_ENEMIES.base + Math.floor((wave - 1) / WAVE_ENEMIES.every) * WAVE_ENEMIES.increment, WAVE_ENEMIES.max);
            enemies = [];
            const types = ['basic', 'fire', 'ice', 'shadow', 'storm', 'beast'];
            const pl = Math.floor(level / 2);
            for (let i = 0; i < numEnemies; i++) {
                const side = Math.random() * 2 * Math.PI;
                const dist = Math.max(CANVAS_WIDTH, CANVAS_HEIGHT) / 2 + 50;
                const x = CANVAS_WIDTH / 2 + Math.cos(side) * dist;
                const y = CANVAS_HEIGHT / 2 + Math.sin(side) * dist;
                const type = types[Math.floor(Math.random() * types.length)];
                enemies.push(new Enemy(x, y, type, pl));
            }
            if (wave % BOSS_EVERY === 0) {
                // Boss
                const boss = new Enemy(CANVAS_WIDTH / 2, 100, 'boss', level);
                boss.size = 30;
                boss.health *= 1.5;
                boss.maxHealth = boss.health;
                boss.atk *= 1.5;
                boss.color = 'darkred';
                enemies.push(boss);
            }
            if (player.pl >= PL_CAP) {
                // Screen shake
                canvas.style.transform = `translate(${Math.random()*10-5}px, ${Math.random()*10-5}px)`;
                setTimeout(() => canvas.style.transform = '', 100);
            }
        }

        function waveComplete() {
            level++;
            xp += 50 * wave; // Wave bonus
            xpToNext = level * 100;
            if (xp >= xpToNext) {
                // PL up rarely
                if (level % 3 === 0 && player.pl < PL_CAP) {
                    player.pl++;
                }
                // Rare stat up
                if (level % 10 === 0) {
                    if (Math.random() < 0.5) player.atk += Math.floor(Math.random() * 3) + 2;
                    else player.def += Math.floor(Math.random() * 3) + 2;
                }
                xp = 0;
                showLevelUp();
            } else {
                nextWave();
            }
            saveGame();
            updateUI();
        }

        function showLevelUp() {
            gameState = 'levelup';
            const upgrades = generateUpgrades();
            const upDiv = document.getElementById('upgrades');
            upDiv.innerHTML = '';
            upgrades.forEach((upgrade, i) => {
                const btn = document.createElement('button');
                btn.innerText = upgrade.name;
                btn.onclick = () => applyUpgrade(upgrade);
                upDiv.appendChild(btn);
            });
            document.getElementById('levelup').classList.remove('hidden');
        }

        function generateUpgrades() {
            const pool = [
                // Unlocks 70% early
                ...abilities.filter(a => !a.unlocked).map(a => ({ type: 'unlock', name: `Unlock ${a.name}`, id: a.id })),
                // Buffs
                { type: 'buff', name: 'ATK +10', value: 10 },
                { type: 'buff', name: 'CD -50ms', value: -50 },
                { type: 'buff', name: 'Mana Cost -5', value: -5 },
                // Stats rare
                ...(level < 10 ? [] : [{ type: 'stat', name: 'ATK +2', stat: 'atk', value: 2 }]),
                ...(level < 10 ? [] : [{ type: 'stat', name: 'DEF +2', stat: 'def', value: 2 }]),
                ...(level < 20 ? [] : [{ type: 'stat', name: 'PL +1', stat: 'pl', value: 1 }]),
                // Shield
                { type: 'shield', name: 'Shield Yield -0.1', value: -0.1 },
                { type: 'shield', name: 'Shield Regen +2', value: 2 }
            ];
            // Shuffle and pick 3 unique
            for (let i = pool.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [pool[i], pool[j]] = [pool[j], pool[i]];
            }
            return pool.slice(0, 3);
        }

        function applyUpgrade(upgrade) {
            if (upgrade.type === 'unlock') {
                const ab = abilities.find(a => a.id === upgrade.id);
                ab.unlocked = true;
            } else if (upgrade.type === 'buff') {
                // Apply to current? Or random unlocked
                const ab = abilities.find(a => a.unlocked && Math.random() < 0.3) || abilities[currentAbilityIndex];
                if (upgrade.name.includes('ATK')) ab.dmgMod = (ab.dmgMod || 0) + 10;
                if (upgrade.name.includes('CD')) ab.cd += upgrade.value;
                if (upgrade.name.includes('Mana')) ab.manaCost += upgrade.value;
            } else if (upgrade.type === 'stat') {
                if (upgrade.stat === 'atk') player.atk += upgrade.value;
                if (upgrade.stat === 'def') player.def += upgrade.value;
                if (upgrade.stat === 'pl') player.pl = Math.min(PL_CAP, player.pl + upgrade.value);
            } else if (upgrade.type === 'shield') {
                if (upgrade.name.includes('Yield')) SHIELD_DRAIN_MULTIPLIER += upgrade.value;
                if (upgrade.name.includes('Regen')) SHIELD_REGEN_RATE += upgrade.value / FPS;
            }
            document.getElementById('levelup').classList.add('hidden');
            gameState = 'playing';
            nextWave();
            saveGame();
        }

        function cycleAttack() {
            currentAbilityIndex = (currentAbilityIndex + 1) % abilities.length;
            updateSpellList();
        }

        function gameOver() {
            gameState = 'gameover';
            document.getElementById('gameover').classList.remove('hidden');
            localStorage.removeItem('alternateSave'); // Wipe
        }

        function restartGame() {
            localStorage.removeItem('alternateSave');
            document.getElementById('gameover').classList.add('hidden');
            startGame();
        }

        // UI Updates
        function updateUI() {
            document.getElementById('health').textContent = Math.floor(player.health);
            document.getElementById('mana').textContent = Math.floor(player.mana);
            document.getElementById('pl').textContent = player.pl;
            document.getElementById('atk').textContent = player.atk;
            document.getElementById('def').textContent = player.def;
            document.getElementById('level').textContent = level;
            document.getElementById('xp').textContent = xp;
            updateSpellList();
        }

        function updateSpellList() {
            const list = document.getElementById('spellList');
            list.innerHTML = abilities.map((ab, i) => {
                const selected = i === currentAbilityIndex ? ' style="color: lime;"' : '';
                const locked = !ab.unlocked ? ' [LOCKED]' : '';
                const cd = ab.cd ? ` CD:${ab.cd}ms` : '';
                return `<div${selected}>${ab.name}${locked}${cd}</div>`;
            }).join('');
        }

        // Main Loop
        function gameLoop(time) {
            const dt = time - lastTime;
            lastTime = time;

            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            if (gameState === 'playing') {
                player.update(dt);

                enemies.forEach(e => e.update(dt));
                projectiles.forEach(p => p.update(dt));
                particles = particles.filter(p => p.update(dt));

                // God mode shake
                if (player.pl === PL_CAP && Math.random() < 0.1) {
                    ctx.save();
                    ctx.translate(Math.random() * 5 - 2.5, Math.random() * 5 - 2.5);
                }

                player.draw();
                enemies.forEach(e => e.draw());
                projectiles.forEach(p => p.draw());
                particles.forEach(p => p.draw());

                if (player.pl === PL_CAP) ctx.restore();

                // Check win? Endless, no
            }

            updateUI();
            requestAnimationFrame(gameLoop);
        }

        // Init
        abilities = initializeAbilities();
        updateSpellList();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
