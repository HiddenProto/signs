<!DOCTYPE html>
<html>
<head>
  <title>Alternate's Magical Evolution</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; }
    #gameCanvas { display: block; margin: auto; background: black; cursor: crosshair; }
    #ui {
      position: absolute; top: 10px; left: 10px; color: #fff; font-family: Arial, sans-serif; font-size: 14px;
    }
    #spellList {
      position: absolute; top: 10px; right: 10px; width: 200px; color: #fff; font-family: Arial, sans-serif; font-size: 14px;
      background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px; height: 300px; overflow-y: auto;
    }
    #controls {
      position: absolute; bottom: 10px; left: 10px; color: #fff; font-family: Arial, sans-serif; font-size: 12px;
    }
    button { padding: 10px 20px; font-size: 16px; margin: 5px; }
  </style>
</head>
<body>
<div id="ui"></div>
<div id="spellList"></div>
<div id="controls">Move: WASD/Arrows, Aim: Mouse, Fire: Click, Spell: Q/E, Shield: SPACE</div>
<canvas id="gameCanvas" width="800" height="600"></canvas>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let keysDown = {};
let mouse = { x: 0, y: 0, down: false };

// Game state
let game = {
  state: 'menu', // 'menu', 'play', 'levelup', 'gameover'
  level: 1,
  xp: 0,
  nextLevelXP: 100,
  wave: 1,
  enemies: [],
  particles: [],
  spells: [],
  upgrades: [],
  lockInput: false
};

// Player (Alternate) object
class Player {
  constructor() {
    this.x = canvas.width/2;
    this.y = canvas.height/2;
    this.radius = 15;
    this.color = 'blue';
    this.hatColor = 'purple';
    this.health = 100;
    this.maxHealth = 100;
    this.mana = 100;
    this.maxMana = 100;
    this.speed = 3;
    this.PL = 1; // power level
    this.ATK = 20;
    this.DEF = 10;
    this.ATKXP = 0;
    this.DEFXP = 0;
    this.spellUpgrades = {};
    this.shield = {
      active: false,
      yield: 1.0, // damage to mana ratio
      radius: 40,
      strength: 100,
      maxStrength: 100
    };
    this.spells = {};
    this.spellOrder = [];
    this.selectedSpellIndex = 0;
    this.canMove = true;
  }
  
  move() {
    if (!this.canMove) return;
    let mv = {x:0, y:0};
    if (keysDown['ArrowUp']||keysDown['w']) mv.y -= 1;
    if (keysDown['ArrowDown']||keysDown['s']) mv.y += 1;
    if (keysDown['ArrowLeft']||keysDown['a']) mv.x -= 1;
    if (keysDown['ArrowRight']||keysDown['d']) mv.x += 1;
    // normalize
    let len = Math.hypot(mv.x, mv.y);
    if (len > 0) { mv.x /= len; mv.y /= len; }
    this.x += mv.x * this.speed;
    this.y += mv.y * this.speed;
    // bound
    this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x));
    this.y = Math.max(this.radius, Math.min(canvas.height - this.radius, this.y));
  }
  
  update() {
    // regen health and mana
    this.health = Math.min(this.maxHealth, this.health + 0.05);
    this.mana = Math.min(this.maxMana, this.mana + 0.2);
    // handle shield
    if (keysDown[' ']) {
      if (this.mana > 0 && this.shield.strength > 0) {
        this.shield.active = true;
      }
    } else {
      this.shield.active = false;
    }
    // Other updates ...
  }
  
  draw() {
    // draw player as stickman with colored hat
    ctx.save();
    ctx.translate(this.x, this.y);
    // draw body
    ctx.strokeStyle = this.color;
    ctx.lineWidth = 3;
    ctx.beginPath();
    // head
    ctx.arc(0, -this.radius, 5, 0, Math.PI * 2);
    ctx.stroke();
    // body line
    ctx.beginPath();
    ctx.moveTo(0, -this.radius + 5);
    ctx.lineTo(0, this.radius);
    ctx.stroke();
    // arms
    ctx.beginPath();
    ctx.moveTo(0, -this.radius + 10);
    ctx.lineTo(-10, 0);
    ctx.moveTo(0, -this.radius + 10);
    ctx.lineTo(10, 0);
    ctx.stroke();
    // legs
    ctx.beginPath();
    ctx.moveTo(0, this.radius);
    ctx.lineTo(-7, this.radius + 15);
    ctx.moveTo(0, this.radius);
    ctx.lineTo(7, this.radius + 15);
    ctx.stroke();
    // hat
    ctx.fillStyle = this.hatColor;
    ctx.beginPath();
    ctx.moveTo(0, -this.radius - 5);
    ctx.lineTo(-10, -this.radius + 5);
    ctx.lineTo(10, -this.radius + 5);
    ctx.fill();
    // shield bubble
    if (this.shield.active) {
      ctx.beginPath();
      ctx.strokeStyle = 'rgba(0,255,255,0.5)';
      ctx.arc(0, 0, this.shield.radius, 0, 2*Math.PI);
      ctx.stroke();
    }
    ctx.restore();
  }
  
  shoot() {
    // Fire selected spell if available
    let spellName = this.spellOrder[this.selectedSpellIndex];
    let spell = this.spells[spellName];
    if (spell && !spell.locked) {
      spell.cast();
    }
  }
}

let player = new Player();
game.spells = {}; // store global references to spells

// Spell base class
class Spell {
  constructor(name, cd, cost, unlockAt = 1) {
    this.name = name;
    this.cooldown = cd;
    this.maxCooldown = cd;
    this.manaCost = cost;
    this.unlocked = false;
    this.locked = true;
    this.unlockAt = unlockAt;
  }
  cast() {
    if (this.locked) return;
    if (this.cooldown > 0) return;
    if (player.mana < this.manaCost) return;
    // subtract mana
    player.mana -= this.manaCost;
    this.cooldown = this.maxCooldown;
    this.fire();
  }
  fire() {
    // to implement in subclass
  }
  update() {
    if (this.cooldown > 0) {
      this.cooldown -= 1;
    }
  }
}

// Specific spells
class MagicShot extends Spell {
  constructor() {
    super('Magic Shot', 30, 5);
    this.unlockAt = 1;
    this.locked = false;
    this.unlocked = true;
  }
  fire() {
    // Basic orange orb
    let angle = Math.atan2(mouse.y - player.y, mouse.x - player.x);
    let speed = 5 + player.PL * 0.2;
    let vx = Math.cos(angle) * speed;
    let vy = Math.sin(angle) * speed;
    game.particles.push(new Projectile(player.x, player.y, vx, vy, 5, 'orange', player.ATK * (1 + player.PL/16)));
  }
}

class TriShot extends Spell {
  constructor() {
    super('Tri-Shot', 60, 10);
    this.unlockAt = 2;
  }
  fire() {
    for (let offset of [-0.2, 0, 0.2]) {
      let angle = Math.atan2(mouse.y - player.y, mouse.x - player.x) + offset;
      let speed = 5;
      let vx = Math.cos(angle) * speed;
      let vy = Math.sin(angle) * speed;
      game.particles.push(new Projectile(player.x, player.y, vx, vy, 5, 'lightblue', player.ATK * (1 + player.PL/16)));
    }
  }
}

class ForceWave extends Spell {
  constructor() {
    super('Force Wave', 120, 20);
    this.unlockAt = 3;
  }
  fire() {
    // create shockwave
    game.particles.push(new Shockwave(player.x, player.y, player.PL));
  }
}

// Projectile class
class Projectile {
  constructor(x, y, vx, vy, radius, color, damage) {
    this.x = x;
    this.y = y;
    this.vx = vx;
    this.vy = vy;
    this.radius = radius;
    this.color = color;
    this.damage = damage;
    this.fromEnemy = false;
    this.alive = true;
  }
  update() {
    this.x += this.vx;
    this.y += this.vy;
    // remove if out of bounds
    if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
      this.alive = false;
    }
  }
  draw() {
    ctx.beginPath();
    ctx.fillStyle = this.color;
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
    ctx.fill();
  }
}

// Shockwave for ForceWave
class Shockwave {
  constructor(x, y, PL) {
    this.x = x;
    this.y = y;
    this.radius = 10;
    this.maxRadius = 150;
    this.speed = 10;
    this.color = 'cyan';
    this.damage = player.ATK * (1 + PL/16) * 2;
    this.alive = true;
  }
  update() {
    if (this.radius < this.maxRadius) {
      this.radius += this.speed;
    } else {
      this.alive = false;
    }
  }
  draw() {
    ctx.beginPath();
    ctx.strokeStyle = this.color;
    ctx.lineWidth = 4;
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
    ctx.stroke();
  }
}

// Enemy class
class Enemy {
  constructor(x, y, PL, isBoss=false) {
    this.x = x;
    this.y = y;
    this.radius = isBoss ? 30 : 15;
    this.color = isBoss ? 'red' : 'gray';
    this.PL = PL;
    this.health = 50 + game.level*20;
    this.speed = 1 + game.level * 0.2;
    this.ATK = 10 + game.level * 5;
    this.DEF = 5 + game.level * 2;
    this.isBoss = isBoss;
    this.alive = true;
    this.cooldown = 0;
    this.dodgeChance = Math.min(0.02 * this.PL, 0.3);
  }
  update() {
    // Basic AI
    if (!this.alive) return;
    let dx = player.x - this.x;
    let dy = player.y - this.y;
    let dist = Math.hypot(dx, dy);
    // Dodge or move
    if (Math.random() < this.dodgeChance) {
      // random dodge move
      this.x += (Math.random() - 0.5) * 50;
      this.y += (Math.random() - 0.5) * 50;
    } else {
      // chase player if far
      if (dist > 30) {
        this.x += (dx/dist) * this.speed;
        this.y += (dy/dist) * this.speed;
      } else {
        // melee attack (not implemented)
      }
    }
    // Cast spells
    if (this.cooldown <= 0) {
      // simple default: shoot basic projectile
      let angle = Math.atan2(dy, dx);
      let vx = Math.cos(angle) * 4;
      let vy = Math.sin(angle) * 4;
      let proj = new Projectile(this.x, this.y, vx, vy, 5, 'red', this.ATK);
      proj.fromEnemy = true;
      game.particles.push(proj);
      this.cooldown = 100 - this.PL*2;
    } else {
      this.cooldown--;
    }
    // Boundaries
    this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x));
    this.y = Math.max(this.radius, Math.min(canvas.height - this.radius, this.y));
    if (this.health <= 0) this.alive = false;
  }
  draw() {
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.beginPath();
    ctx.strokeStyle = this.color;
    ctx.lineWidth = 3;
    // simple stick
    ctx.moveTo(0, -this.radius);
    ctx.lineTo(0, this.radius);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(0, -this.radius, 5, 0, Math.PI*2);
    ctx.stroke();
    // arms
    ctx.beginPath();
    ctx.moveTo(0, -this.radius+10);
    ctx.lineTo(-10, 0);
    ctx.moveTo(0, -this.radius+10);
    ctx.lineTo(10, 0);
    ctx.stroke();
    // legs
    ctx.beginPath();
    ctx.moveTo(0, this.radius);
    ctx.lineTo(-7, this.radius + 15);
    ctx.moveTo(0, this.radius);
    ctx.lineTo(7, this.radius + 15);
    ctx.stroke();
    ctx.restore();
  }
}

// Initialize spells and selection
function initSpells() {
  player.spells['Magic Shot'] = new MagicShot();
  player.spells['Tri-Shot'] = new TriShot();
  player.spells['Force Wave'] = new ForceWave();
  player.spellOrder = ['Magic Shot', 'Tri-Shot', 'Force Wave'];
  for (let name in player.spells) {
    let spell = player.spells[name];
    if (spell.unlockAt <= player.PL) {
      spell.locked = false;
      spell.unlocked = true;
    }
  }
}
initSpells();

// Mouse and keyboard events
canvas.addEventListener('mousemove', function(evt) {
  let rect = canvas.getBoundingClientRect();
  mouse.x = evt.clientX - rect.left;
  mouse.y = evt.clientY - rect.top;
});
canvas.addEventListener('mousedown', function(evt) {
  mouse.down = true;
  player.shoot();
});
canvas.addEventListener('mouseup', function(evt) {
  mouse.down = false;
});
window.addEventListener('keydown', function(evt) {
  keysDown[evt.key] = true;
  // cycle spells
  if (evt.key === 'q') {
    player.selectedSpellIndex = (player.selectedSpellIndex - 1 + player.spellOrder.length) % player.spellOrder.length;
  }
  if (evt.key === 'e') {
    player.selectedSpellIndex = (player.selectedSpellIndex + 1) % player.spellOrder.length;
  }
});
window.addEventListener('keyup', function(evt) {
  keysDown[evt.key] = false;
});

// Game loop functions
function update() {
  if (game.state === 'play') {
    player.move();
    player.update();
    for (let spellName in player.spells) {
      player.spells[spellName].update();
    }
    // Update particles
    for (let p of game.particles) {
      p.update();
      // Check collision with player if fromEnemy projectile
      if (p.fromEnemy) {
        let dx = p.x - player.x;
        let dy = p.y - player.y;
        if (Math.hypot(dx, dy) < p.radius + player.radius) {
          let damage = p.damage - player.DEF * (1 - player.PL/100);
          player.health -= Math.max(1, damage);
          p.alive = false;
        }
      }
    }
    game.particles = game.particles.filter(p => p.alive);
    // Update enemies
    for (let e of game.enemies) {
      e.update();
    }
    game.enemies = game.enemies.filter(e => e.alive);
    // Collisions (projectile - enemy)
    for (let p of game.particles) {
      if (!p.fromEnemy) {
        for (let e of game.enemies) {
          let dx = p.x - e.x;
          let dy = p.y - e.y;
          if (Math.hypot(dx, dy) < p.radius + e.radius) {
            let damage = p.damage - e.DEF * (1 - player.PL/100);
            e.health -= Math.max(1, damage);
            p.alive = false;
            if (e.health <= 0) {
              e.alive = false;
              game.xp += 20;
            }
          }
        }
      }
    }
    // Spawn new wave if enemies cleared
    if (game.enemies.length === 0) {
      game.wave++;
      spawnWave();
    }
  }
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (game.state === 'play') {
    player.draw();
    for (let p of game.particles) {
      p.draw();
    }
    for (let e of game.enemies) {
      e.draw();
    }
    // UI
    document.getElementById('ui').innerHTML = 'HP: ' + Math.floor(player.health) + ' / ' + player.maxHealth + '<br>'
      + 'Mana: ' + Math.floor(player.mana) + ' / ' + player.maxMana + '<br>'
      + 'PL: ' + player.PL + '<br>'
      + 'ATK: ' + player.ATK + '<br>'
      + 'DEF: ' + player.DEF + '<br>'
      + 'Wave: ' + game.wave + '<br>'
      + 'XP: ' + game.xp + ' / ' + game.nextLevelXP;
    // Spell list
    let spellListHtml = '<ul style="list-style: none; padding: 0; margin: 0;">';
    player.spellOrder.forEach((name, index) => {
      let spell = player.spells[name];
      let color = index === player.selectedSpellIndex ? 'yellow' : 'white';
      let status = spell.unlocked ? '' : '(LOCKED)';
      spellListHtml += '<li style="color:' + color + '">' + name + ' ' + status + '</li>';
    });
    spellListHtml += '</ul>';
    document.getElementById('spellList').innerHTML = spellListHtml;
  }
}

function spawnWave() {
  let count = Math.min(6, Math.floor(game.wave / 3) + 1);
  for (let i = 0; i < count; i++) {
    let angle = Math.random() * Math.PI*2;
    let dist = 200;
    let ex = player.x + Math.cos(angle)*dist;
    let ey = player.y + Math.sin(angle)*dist;
    let newEnemy = new Enemy(ex, ey, Math.floor(game.wave/2));
    game.enemies.push(newEnemy);
  }
}

function gameLoop() {
  update();
  draw();
  requestAnimationFrame(gameLoop);
}

game.state = 'play';
gameLoop();
</script>
</body>
</html>
