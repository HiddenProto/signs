<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alternate's Magical Evolution</title>
    <style>
        body {
            background-color: #111;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
        }
        canvas {
            border: 2px solid #333;
            background-color: black;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
            cursor: crosshair;
        }
        #ui-container {
            position: absolute;
            width: 800px;
            height: 600px;
            pointer-events: none; /* Allows mouse events to pass through to canvas */
        }
        #info-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 14px;
            text-shadow: 1px 1px 2px black;
        }
       .spell-list {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #ddd;
            width: 200px;
            max-height: 580px;
            overflow-y: auto;
            border: 1px solid #333;
            padding: 5px;
            background-color: rgba(0, 0, 0, 0.5);
        }
       .spell-item {
            padding: 3px 0;
            cursor: pointer;
            border-bottom: 1px dashed #222;
        }
       .spell-locked { color: gray; }
       .spell-selected { color: limegreen; font-weight: bold; }
       .spell-special { font-style: italic; color: #ff8800; }
       .spell-cd { color: #888; }
        #upgrade-menu {
            position: absolute;
            width: 400px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 5px solid #00f;
            color: white;
            text-align: center;
            display: none; /* Managed by JS */
        }
       .upgrade-card {
            background: #222;
            margin: 10px 0;
            padding: 10px;
            border: 1px solid #555;
            cursor: pointer;
            transition: background 0.1s;
            pointer-events: auto; /* Re-enable pointer events for the menu */
        }
       .upgrade-card:hover { background: #444; }
       .bar-hp { background: #f00; height: 8px; width: 100%; }
       .bar-mana { background: #00f; height: 8px; width: 100%; }

    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    
    <div id="ui-container">
        <div id="info-panel">
            <span id="game-state-text"></span><br>
            Level: <span id="stat-level">1</span> (XP: <span id="stat-xp">0</span>/100)<br>
            PL: <span id="stat-pl">1.0</span> (ATK: <span id="stat-atk">20</span> | DEF: <span id="stat-def">10</span>)<br>
            <div style="margin-top: 5px;">
                HP: <span id="stat-hp-text">100/100</span><br><div id="hp-bar-fill" class="bar-hp"></div>
                Mana: <span id="stat-mana-text">100/100</span><br><div id="mana-bar-fill" class="bar-mana"></div>
            </div>
            <div style="margin-top: 10px;">
                Controls:<br>
                WASD/Arrows: Move<br>
                Mouse: Aim/Fire (Hold for Charge)<br>
                SPACE: Shield (Charge + SPACE: Shield Projectile)<br>
                ,: Cycle Attacks
            </div>
        </div>

        <div class="spell-list" id="spell-list-ui">
            <div style="font-size: 16px; margin-bottom: 5px; color: white;">Abilities (Scroll)</div>
        </div>

        <div id="upgrade-menu" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);">
            <h2>LEVEL UP! Choose an Evolution:</h2>
            <div id="upgrade-choices">
                </div>
        </div>
    </div>

    <script>
        // Set up the canvas and context
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const W = canvas.width;
        const H = canvas.height;

        // --- GLOBAL CONSTANTS AND CONFIG ---
        const PLAYER_SIZE = 20;
        const ENEMY_SIZE = 18;
        const MAX_WAVE_ENEMIES = 6;
        const SHAKE_DURATION = 0.5; // seconds
        const PL16_FLEE_CHANCE = 0.20;

        // --- Core Utility Classes (Vector Math) ---

        /**
         * @class Vector2D
         * Represents a 2D vector for position, velocity, and physics calculations.
         */
        class Vector2D {
            constructor(x = 0, y = 0) {
                this.x = x;
                this.y = y;
            }

            add(v) { return new Vector2D(this.x + v.x, this.y + v.y); }
            subtract(v) { return new Vector2D(this.x - v.x, this.y - v.y); }
            scale(s) { return new Vector2D(this.x * s, this.y * s); }
            magnitude() { return Math.sqrt(this.x * this.x + this.y * this.y); }
            normalize() {
                const mag = this.magnitude();
                return mag > 0? this.scale(1 / mag) : new Vector2D(0, 0);
            }
            dot(v) { return this.x * v.x + this.y * v.y; }
            copy() { return new Vector2D(this.x, this.y); }

            /**
             * Calculates the reflection vector. (r = a - 2 * (a. n) * n) [1]
             * @param {Vector2D} normal - The normalized surface normal vector at the point of impact.
             * @returns {Vector2D} The reflected velocity vector.
             */
            reflect(normal) {
                const dot = this.dot(normal);
                return this.subtract(normal.scale(2 * dot));
            }
        }

        // --- Particle & Visual Effects Manager ---

        const particles =;

        class Particle {
            constructor(x, y, color, size, velocity, life = 1.0) {
                this.position = new Vector2D(x, y);
                this.color = color;
                this.size = size;
                this.velocity = velocity;
                this.life = life; // Time to live (in seconds)
                this.maxLife = life;
            }

            update(deltaTime) {
                this.position = this.position.add(this.velocity.scale(deltaTime));
                this.life -= deltaTime;
            }

            draw(ctx) {
                const alpha = this.life / this.maxLife;
                ctx.save();
                ctx.globalAlpha = alpha;
                
                // Use built-in glow for magical effects [2, 3]
                ctx.shadowColor = this.color;
                ctx.shadowBlur = this.size / 2;

                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        function createExplosion(x, y, color, count, power = 1) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = (Math.random() * 50 + 50) * power;
                const velocity = new Vector2D(Math.cos(angle) * speed, Math.sin(angle) * speed);
                const size = Math.random() * 2 * power + 1;
                const life = Math.random() * 0.5 + 0.3;
                particles.push(new Particle(x, y, color, size, velocity, life));
            }
        }

        function createTrail(x, y, color, power = 1) {
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 10;
            const velocity = new Vector2D(Math.cos(angle) * speed, Math.sin(angle) * speed);
            const size = Math.random() * 0.5 * power + 0.5;
            const life = Math.random() * 0.1 + 0.1;
            particles.push(new Particle(x, y, color, size, velocity, life));
        }

        // --- Projectile Class ---

        class Projectile {
            constructor(x, y, angle, speed, radius, damage, color, casterPL, specialType = 'MagicShot', isEnemy = false, isBeam = false) {
                this.position = new Vector2D(x, y);
                this.velocity = new Vector2D(Math.cos(angle) * speed, Math.sin(angle) * speed);
                this.angle = angle;
                this.speed = speed;
                this.radius = radius;
                this.damage = damage;
                this.color = color;
                this.casterPL = casterPL;
                this.isEnemy = isEnemy;
                this.specialType = specialType;
                this.isBeam = isBeam;
                this.lifetime = 5; // s
                this.active = true;
                this.isChargedShot = false;
            }

            getDamage(targetDef) {
                const effectiveDmg = (this.damage * (1 + this.casterPL / 16)) - (targetDef * (1 + this.casterPL * 0.05));
                return Math.max(1, effectiveDmg);
            }

            update(deltaTime) {
                if (!this.active) return;
                this.position = this.position.add(this.velocity.scale(deltaTime));
                this.lifetime -= deltaTime;
                if (this.lifetime <= 0) this.active = false;
                
                // Trail particle effect
                if (this.specialType!== 'BeamShot') {
                    createTrail(this.position.x, this.position.y, this.color, this.radius / 5);
                }

                // Homing (PL6+ only for MagicShot, and basic homing for Homing Missile)
                if (this.specialType === 'HomingMissile' |

| (this.specialType === 'MagicShot' && this.casterPL >= 6)) {
                    this.home(Game.player);
                }
            }

            home(target) {
                const targetPos = target.position;
                const direction = targetPos.subtract(this.position).normalize();
                
                // Small turn rate adjustment
                const turnRate = 0.5 * this.casterPL * 0.01;
                
                // Current velocity direction
                const currentDir = this.velocity.normalize();
                
                // Interpolate
                let newDir = currentDir.scale(1 - turnRate).add(direction.scale(turnRate)).normalize();
                
                this.velocity = newDir.scale(this.speed);
                this.angle = Math.atan2(newDir.y, newDir.x);
            }

            draw(ctx) {
                if (!this.active) return;
                ctx.save();
                
                // Magical glow effect [2, 3]
                ctx.shadowColor = this.color;
                ctx.shadowBlur = this.radius * 2;
                ctx.fillStyle = this.color;
                
                if (this.isBeam) {
                    // Draw Beam as a long rectangle
                    ctx.translate(this.position.x, this.position.y);
                    ctx.rotate(this.angle);
                    ctx.fillRect(0, -this.radius / 2, 800, this.radius); // Draw a long, thin rectangle
                } else {
                    // Draw Orb
                    ctx.beginPath();
                    ctx.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }
        }
        
        // --- Player Class (Alternate) ---

        class Player {
            constructor() {
                this.position = new Vector2D(W / 2, H / 2);
                this.velocity = new Vector2D(0, 0);
                this.size = PLAYER_SIZE;
                this.angle = 0; // Rotation angle for the barrel arm

                // Stats
                this.maxHp = 100;
                this.currentHp = 100;
                this.maxMana = 100;
                this.currentMana = 100;
                this.speed = 300; // Pixels per second
                this.pl = 1; // Power Level (PL 1-16)
                this.atk = 20;
                this.def = 10;
                this.level = 1;
                this.xp = 0;
                this.xpToNextLevel = 100;

                // Shield
                this.shieldActive = false;
                this.shieldStrength = 100;
                this.maxShieldStrength = 100;
                this.shieldOmni = 40; // Base omni radius
                this.shieldManaCostYield = 1.0; // Mana cost multiplier (upgradeable to 0.5)

                // Attack State
                this.unlockedAbilities =;
                this.currentAttack = 'MagicShot';
                this.abilityCooldowns = {}; // Tracks time remaining on cooldown
                this.attackQueue =; // For multi-attacks

                // Charge Mechanic
                this.isCharging = false;
                this.chargeTime = 0;
                this.chargeMax = 3.0;
                this.chargeRadius = 0;
            }

            update(deltaTime, input) {
                // --- Stat Regen ---
                if (!input.isMouseDown &&!this.shieldActive && Game.state === 'WAVE_FIGHT') {
                    // HP Regen (off-combat)
                    if (Game.enemies.length === 0) {
                        this.currentHp = Math.min(this.maxHp, this.currentHp + 5 * deltaTime);
                    }
                    // Mana Regen (fast)
                    this.currentMana = Math.min(this.maxMana, this.currentMana + 20 * deltaTime);
                    // Shield Regen (off-hold)
                    if (!input.isHoldingSpace) {
                        this.shieldStrength = Math.min(this.maxShieldStrength, this.shieldStrength + 50 * deltaTime);
                    }
                }
                
                // --- Movement ---
                this.velocity.x = 0;
                this.velocity.y = 0;
                let effectiveSpeed = this.speed * (this.pl >= 12? 2.0 : 1.0); // Super Speed buff PL12+
                
                if (input.keys.includes('w') |

| input.keys.includes('ArrowUp')) this.velocity.y = -1;
                if (input.keys.includes('s') |

| input.keys.includes('ArrowDown')) this.velocity.y = 1;
                if (input.keys.includes('a') |

| input.keys.includes('ArrowLeft')) this.velocity.x = -1;
                if (input.keys.includes('d') |

| input.keys.includes('ArrowRight')) this.velocity.x = 1;
                
                if (this.velocity.magnitude() > 0) {
                    this.velocity = this.velocity.normalize().scale(effectiveSpeed * deltaTime);
                }
                this.position = this.position.add(this.velocity);

                // Boundary checking
                this.position.x = Math.max(this.size, Math.min(W - this.size, this.position.x));
                this.position.y = Math.max(this.size, Math.min(H - this.size, this.position.y));

                // --- Aiming ---
                this.angle = Math.atan2(input.mousePos.y - this.position.y, input.mousePos.x - this.position.x);

                // --- Cooldowns ---
                for (const ability in this.abilityCooldowns) {
                    this.abilityCooldowns[ability] -= deltaTime;
                    if (this.abilityCooldowns[ability] <= 0) {
                        delete this.abilityCooldowns[ability];
                    }
                }

                // --- Shield & Charge Management ---
                this.shieldActive = input.isHoldingSpace && this.currentMana > 0;
                
                if (input.isHoldingSpace && this.shieldActive) {
                    // Shield strength degradation is handled in collision
                } else {
                    this.shieldActive = false;
                }

                if (input.isHoldingMouse &&!this.shieldActive && Game.state === 'WAVE_FIGHT') {
                    this.isCharging = true;
                    this.chargeTime = Math.min(this.chargeMax, this.chargeTime + deltaTime);
                    this.chargeRadius = 5 + (this.chargeTime / this.chargeMax) * 30; // Max 35
                    this.currentMana = Math.max(0, this.currentMana - (20 * deltaTime)); // Mana cost/sec
                } else if (this.isCharging) {
                    // Mouse released (Fire Charged Shot or standard shot if failed charge)
                    this.isCharging = false;
                    this.fireChargedShot();
                } else {
                    this.chargeTime = 0;
                    this.chargeRadius = 0;
                }

                // --- Special Charge + Shield Projectile (SPACE pressed while charging) ---
                if (input.isHoldingMouse && input.isHoldingSpace && this.chargeTime > this.chargeMax * 0.5) {
                    Game.shootShieldProj = true; // Flag for mouseUp to handle
                } else {
                    Game.shootShieldProj = false;
                }
            }
            
            // Apply damage, including the high-PL resistance factor
            takeDamage(damage) {
                const incomingDmg = damage;
                const effectiveDef = this.def * (1 + this.pl * 0.05); // PL resist factor
                const mitigatedDmg = incomingDmg - effectiveDef;
                
                const finalDmg = Math.max(1, mitigatedDmg);
                this.currentHp = Math.max(0, this.currentHp - finalDmg);

                if (this.currentHp <= 0) {
                    Game.gameOver();
                }
            }

            // Called when a projectile hits the player's shield
            absorbProjectile(projectile, impactPos, normal) {
                if (!this.shieldActive) return false;
                
                let absorption = 1.0;
                
                // Overpower: High PL attack 75% overpower vs charging player
                if (this.isCharging) {
                    // If hit while charging, enemy attack is 75% overpower
                    const overpoweredDmg = projectile.getDamage(0) * 0.75;
                    this.takeDamage(overpoweredDmg);
                    createExplosion(impactPos.x, impactPos.y, projectile.color, 10, 1.5);
                    projectile.active = false;
                    return true;
                }
                
                // Degradation and Reflection
                
                // Shield strength degrades based on projectile damage + PL factor
                const shieldDegrade = projectile.getDamage(0) * (0.5 + this.pl * 0.01);
                this.shieldStrength -= shieldDegrade;

                // Mana drains based on absorbed damage * yield
                const manaCost = shieldDegrade * this.shieldManaCostYield;
                this.currentMana = Math.max(0, this.currentMana - manaCost);
                
                if (this.shieldStrength <= 0 |

| this.currentMana <= 0) {
                    // Shield breaks/exhausted
                    this.shieldActive = false;
                    createExplosion(this.position.x, this.position.y, '#00FFFF', 20, 2);
                }

                // Reflection
                if (projectile.isBeam) {
                    // Beams are not reflected by standard shields (absorbed/destroyed)
                    projectile.active = false;
                    return true;
                }
                
                // Calculate reflected velocity [1]
                const reflectedVelocity = projectile.velocity.reflect(normal);
                
                // Create a new projectile
                const newProj = new Projectile(
                    projectile.position.x, projectile.position.y,
                    Math.atan2(reflectedVelocity.y, reflectedVelocity.x),
                    projectile.speed * 0.8, // Slight speed decay
                    projectile.radius,
                    projectile.damage * 0.8, // Reflected damage penalty
                    projectile.color,
                    this.pl, // Player PL for reflection
                    projectile.specialType,
                    false // It is now a player-fired projectile
                );
                
                Game.projectiles.push(newProj);
                createExplosion(impactPos.x, impactPos.y, projectile.color, 5, 0.5);
                projectile.active = false; // Destroy incoming projectile
                return true;
            }

            // Handles regular click and charged shot release
            fire(targetPos) {
                if (Game.state!== 'WAVE_FIGHT') return;

                const attackData = ABILITIES[this.currentAttack];
                if (!attackData |

| this.abilityCooldowns[this.currentAttack] > 0) {
                    console.log(`Attack ${this.currentAttack} on cooldown or locked.`);
                    return;
                }

                if (this.currentMana < attackData.cost) {
                    console.log("Not enough mana.");
                    return;
                }
                
                this.currentMana -= attackData.cost;
                this.abilityCooldowns[this.currentAttack] = attackData.cd;

                const angle = this.angle;
                const speed = attackData.speed;
                const damage = this.atk * attackData.dmgMult;
                const radius = attackData.radius;
                const color = attackData.color;
                
                // Core firing logic (creates a base projectile)
                const createBaseProjectile = (a = angle) => {
                    const velocity = new Vector2D(Math.cos(a) * speed, Math.sin(a) * speed);
                    const startPos = this.position.add(velocity.normalize().scale(this.size + radius + 5));
                    
                    Game.projectiles.push(new Projectile(
                        startPos.x, startPos.y,
                        a, speed, radius, damage, color, this.pl, this.currentAttack, false, attackData.isBeam
                    ));
                    createTrail(startPos.x, startPos.y, color, radius / 5);
                };

                switch (this.currentAttack) {
                    case 'MagicShot':
                    case 'BeamShot':
                        createBaseProjectile();
                        break;
                    case 'TriShot':
                        const spread = (this.pl >= 8? Math.PI / 10 : Math.PI / 6);
                        createBaseProjectile(angle - spread);
                        createBaseProjectile(angle);
                        createBaseProjectile(angle + spread);
                        break;
                    //... (implement other attacks like PentaShot, RecursiveShot, CurveShot)
                    default:
                        createBaseProjectile();
                }
            }

            fireChargedShot() {
                if (this.chargeTime < 0.1) {
                    // Not enough charge for special effect, fire standard shot if mouse was down
                    return;
                }

                // Only Magic Shot supports charging
                const attackData = ABILITIES;
                
                this.abilityCooldowns = attackData.cd * 2; // Longer CD for charged shot

                const chargeRatio = this.chargeTime / this.chargeMax;
                const speed = attackData.speed * (1 + chargeRatio * 0.5);
                const damage = this.atk * attackData.dmgMult * (1 + chargeRatio * 2.0); // Dmg * Charge Level
                const radius = attackData.radius * (1 + chargeRatio * 1.5);
                const color = '#FF4500'; // Massive orange orb
                
                const velocity = new Vector2D(Math.cos(this.angle) * speed, Math.sin(this.angle) * speed);
                const startPos = this.position.add(velocity.normalize().scale(this.size + radius + 5));
                
                const chargedProj = new Projectile(
                    startPos.x, startPos.y,
                    this.angle, speed, radius, damage, color, this.pl, 'MagicShot', false
                );
                chargedProj.isChargedShot = true;
                
                Game.projectiles.push(chargedProj);
                createExplosion(startPos.x, startPos.y, color, 30, chargeRatio * 3);
                
                this.chargeTime = 0; // Reset charge
                this.chargeRadius = 0;
                console.log("Charged Magic Shot fired.");
            }
            
            // Called from GameManager mouseup event if flag is set
            fireShieldProjectile() {
                // Shield Attack (Curved Line Proj - special unlock)
                const attack = 'ShieldAttack';
                const attackData = ABILITIES[attack];
                
                if (!this.unlockedAbilities.includes(attack) |

| this.currentMana < attackData.cost) {
                    return;
                }
                
                this.currentMana -= attackData.cost;
                this.abilityCooldowns[attack] = attackData.cd;

                const angle = this.angle;
                const speed = attackData.speed;
                const damage = this.atk * attackData.dmgMult;
                const radius = 5; // A line, but still needs a small radius
                const color = attackData.color;
                
                const velocity = new Vector2D(Math.cos(angle) * speed, Math.sin(angle) * speed);
                const startPos = this.position.add(velocity.normalize().scale(this.size + radius + 5));
                
                const shieldProj = new Projectile(
                    startPos.x, startPos.y,
                    angle, speed, radius, damage * 0.8, // 20% weaker strength
                    color, this.pl, attack, false
                );
                // Flag it as a special reflection projectile (for enemy interaction)
                shieldProj.isReflectingShield = true; 
                
                Game.projectiles.push(shieldProj);
                createExplosion(startPos.x, startPos.y, color, 10, 1);
                console.log("Shield Projectile fired (20% weaker).");
            }
            
            cycleAttack() {
                let currentIndex = this.unlockedAbilities.indexOf(this.currentAttack);
                let nextIndex = (currentIndex + 1) % this.unlockedAbilities.length;
                this.currentAttack = this.unlockedAbilities[nextIndex];
                console.log(`Switched to: ${this.currentAttack}`);
            }

            draw(ctx) {
                ctx.save();
                
                // Screen shake PL16 effect
                if (this.pl >= 16 && Game.isShaking) {
                    ctx.translate(Math.random() * 5 - 2.5, Math.random() * 5 - 2.5);
                }

                // 1. Charge Aura (Growing Orb)
                if (this.isCharging) {
                    ctx.beginPath();
                    ctx.arc(this.position.x, this.position.y, this.chargeRadius + 5, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 255, 0, ${this.chargeTime / this.chargeMax * 0.3})`;
                    ctx.fill();
                    
                    // Inner aura
                    ctx.shadowColor = '#FFFF00';
                    ctx.shadowBlur = this.chargeRadius / 2;
                    ctx.beginPath();
                    ctx.arc(this.position.x, this.position.y, this.chargeRadius, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 255, 0, ${this.chargeTime / this.chargeMax * 0.8})`;
                    ctx.fill();
                }
                
                // Reset Shadows for non-special drawing
                ctx.shadowBlur = 0; 
                
                // 2. Shield (Green/Blue bubble)
                if (this.shieldActive) {
                    const shieldColor = this.currentMana > 0? '#00FF88' : '#8888FF';
                    const radius = this.size + this.shieldOmni;
                    ctx.strokeStyle = shieldColor;
                    ctx.lineWidth = 3;
                    
                    // Pulse animation
                    const pulse = Math.sin(Date.now() / 100) * 2;
                    
                    ctx.shadowColor = shieldColor;
                    ctx.shadowBlur = 10;
                    ctx.globalAlpha = 0.5 + Math.min(0.5, this.shieldStrength / this.maxShieldStrength) * 0.5;

                    ctx.beginPath();
                    ctx.arc(this.position.x, this.position.y, radius + pulse, 0, Math.PI * 2);
                    ctx.stroke();
                }

                ctx.globalAlpha = 1.0;
                ctx.shadowBlur = 0; 

                // 3. Body (Blue tinted square)
                const bodyX = this.position.x - this.size / 2;
                const bodyY = this.position.y - this.size / 2;
                
                // Idle bob animation (slight sway/breathing)
                const bob = Math.sin(Date.now() / 500) * 1;
                
                ctx.fillStyle = '#1E90FF'; // Blue
                ctx.fillRect(bodyX, bodyY + bob, this.size, this.size);
                
                // 4. Hat (Purple square)
                ctx.fillStyle = '#8A2BE2'; // Purple
                ctx.fillRect(bodyX, bodyY - 5 + bob, this.size, 5);

                // 5. Barrel Arm (Aiming)
                ctx.translate(this.position.x, this.position.y);
                ctx.rotate(this.angle);

                // Barrel (Thin line/rectangle pointing forward)
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 5;
                ctx.lineCap = 'round';
                
                // Casting effect (barrel thrust + trail)
                const thrust = (this.abilityCooldowns[this.currentAttack] > ABILITIES[this.currentAttack].cd - 0.1)? 10 : 0;

                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(this.size / 2 + 10 + thrust, 0);
                ctx.stroke();

                ctx.restore();
            }
        }
        
        // --- Enemy Class ---
        
        class Enemy {
            constructor(x, y, level, type = 'FireMagician') {
                this.position = new Vector2D(x, y);
                this.velocity = new Vector2D(0, 0);
                this.size = ENEMY_SIZE;
                this.angle = 0;
                this.isBoss = level % 5 === 0 && level > 0;
                this.type = type;

                // Stats
                this.level = level;
                this.pl = Math.floor(level / 2) + (this.isBoss? 1 : 0); // PL=level/2 (boss=player+1)
                this.maxHp = (50 + level * 20) * (1 + this.pl * 0.1);
                this.currentHp = this.maxHp;
                this.speed = (100 + level * 20) * (this.isBoss? 1.5 : 1.0); // Pixels per second
                this.atk = (10 + level * 5) * (this.isBoss? 1.5 : 1.0);
                this.def = (5 + level * 2) * (this.isBoss? 1.5 : 1.0);
                
                this.baseColor = ENEMY_CONFIG[type].color;
                this.attackCD = 3.0;
                this.attackTimer = Math.random() * this.attackCD;
                this.isDodging = false;
                
                if (this.isBoss) {
                    this.size *= 1.5;
                }
            }

            takeDamage(damage) {
                const effectiveDmg = Math.max(1, damage - this.def);
                this.currentHp = Math.max(0, this.currentHp - effectiveDmg);
                
                if (this.currentHp <= 0) {
                    this.active = false;
                    createExplosion(this.position.x, this.position.y, this.baseColor, 20, 2);
                    Game.player.xp += (50 + this.level * 10);
                }
            }
            
            // Tier 3 AI (PL12+): Uses basic linear predictive aiming [4]
            predictiveAim(target, projectileSpeed) {
                const targetPos = target.position;
                const myPos = this.position;
                
                const distance = targetPos.subtract(myPos).magnitude();
                const timeToHit = distance / projectileSpeed; // Simple ETI (1st degree estimate)

                // Project target's future position
                const predictedX = targetPos.x + target.velocity.x * timeToHit;
                const predictedY = targetPos.y + target.velocity.y * timeToHit;
                
                return Math.atan2(predictedY - myPos.y, predictedX - myPos.x);
            }

            update(deltaTime) {
                if (!this.active) return;
                
                const target = Game.player;
                const distanceVector = target.position.subtract(this.position);
                const distance = distanceVector.magnitude();
                const targetDir = distanceVector.normalize();
                
                // PL16 God mode effect: 20% chance to flee [5]
                if (target.pl >= 16 && Math.random() < PL16_FLEE_CHANCE * deltaTime) { 
                    this.velocity = targetDir.scale(-this.speed * deltaTime); // Flee
                    this.position = this.position.add(this.velocity);
                    return;
                }

                // AI Logic (Chase/Range) [6]
                const engagementRange = 400;
                const meleeRange = 50;

                if (distance > engagementRange) {
                    // Chase
                    this.velocity = targetDir.scale(this.speed * deltaTime);
                } else if (distance < meleeRange && this.pl < 8) {
                    // Melee
                    this.velocity = targetDir.scale(this.speed * deltaTime);
                } else {
                    // Maintain range / Idle
                    this.velocity = new Vector2D(0, 0);
                }

                this.position = this.position.add(this.velocity);
                this.angle = Math.atan2(distanceVector.y, distanceVector.x);

                // Boundary checking (same as player)
                this.position.x = Math.max(this.size, Math.min(W - this.size, this.position.x));
                this.position.y = Math.max(this.size, Math.min(H - this.size, this.position.y));

                // Attack Logic
                this.attackTimer -= deltaTime;
                if (this.attackTimer <= 0) {
                    this.fireAttack(target);
                    this.attackCD = Math.max(1.0, 3.0 - this.pl * 0.15); // Faster CD with PL
                    this.attackTimer = this.attackCD * (1 + Math.random() * 0.5); // Randomize slightly
                }
            }

            fireAttack(target) {
                // Enemy's ability is determined by its PL and type
                const attackType = this.pl >= 12? 'BeamShot' : (this.pl >= 4? 'TriShot' : 'MagicShot');
                const attackData = ABILITIES;
                
                const damage = this.atk * attackData.dmgMult;
                const radius = attackData.radius;
                const speed = attackData.speed * 0.8; // Enemies are slightly slower
                const color = this.baseColor;

                let angle = this.angle;
                
                // PL8+ AI uses predictive aiming for non-AOE attacks [4]
                if (this.pl >= 8) {
                    angle = this.predictiveAim(target, speed);
                }

                const velocity = new Vector2D(Math.cos(angle) * speed, Math.sin(angle) * speed);
                const startPos = this.position.add(velocity.normalize().scale(this.size + radius + 5));

                Game.projectiles.push(new Projectile(
                    startPos.x, startPos.y,
                    angle, speed, radius, damage, color, this.pl, attackType, true, attackData.isBeam
                ));
                console.log(`Enemy PL${this.pl} fired ${attackType}`);
            }

            draw(ctx) {
                ctx.save();
                
                // HP Bar (Above body)
                const hpRatio = this.currentHp / this.maxHp;
                ctx.fillStyle = hpRatio > 0.5? 'lime' : (hpRatio > 0.2? 'yellow' : 'red');
                ctx.fillRect(this.position.x - this.size / 2, this.position.y - this.size / 2 - 10, this.size * hpRatio, 3);
                
                // 1. Body (Color by type)
                const bodyX = this.position.x - this.size / 2;
                const bodyY = this.position.y - this.size / 2;
                
                ctx.fillStyle = this.baseColor;
                ctx.fillRect(bodyX, bodyY, this.size, this.size);
                
                // 2. Barrel Arm (Aiming)
                ctx.translate(this.position.x, this.position.y);
                ctx.rotate(this.angle);

                // Barrel 
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(this.size / 2 + 5, 0);
                ctx.stroke();

                // 3. Boss identifier
                if (this.isBoss) {
                    ctx.fillStyle = 'red';
                    ctx.font = '10px Arial';
                    ctx.fillText("BOSS", -15, -15);
                }

                ctx.restore();
            }
        }
        
        // --- Input Handler ---

        class InputHandler {
            constructor() {
                this.keys =;
                this.mousePos = new Vector2D(W / 2, H / 2);
                this.isMouseDown = false;
                this.isHoldingMouse = false;
                this.isHoldingSpace = false;

                window.addEventListener('keydown', (e) => this.handleKey(e, true));
                window.addEventListener('keyup', (e) => this.handleKey(e, false));
                canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
            }

            handleKey(e, isDown) {
                const key = e.key.toLowerCase();
                if (isDown &&!this.keys.includes(key)) {
                    this.keys.push(key);
                    
                    if (key === ',') Game.player.cycleAttack();
                    if (key === ' ') this.isHoldingSpace = true;
                } else if (!isDown) {
                    this.keys = this.keys.filter(k => k!== key);
                    
                    if (key === ' ') this.isHoldingSpace = false;
                }
            }

            handleMouseMove(e) {
                const rect = canvas.getBoundingClientRect();
                this.mousePos.x = e.clientX - rect.left;
                this.mousePos.y = e.clientY - rect.top;
            }
            
            handleMouseDown(e) {
                if (e.button === 0) { // Left click
                    this.isMouseDown = true;
                    this.isHoldingMouse = true;
                }
            }
            
            handleMouseUp(e) {
                if (e.button === 0) { // Left click
                    this.isMouseDown = false;
                    
                    // If released while charging AND shield proj flag was set
                    if (Game.shootShieldProj) {
                        Game.player.fireShieldProjectile();
                    } else if (Game.player.isCharging) {
                        // Charged shot handled internally in Player.update
                    } else {
                        // Regular shot (only if not charging)
                        Game.player.fire(this.mousePos);
                    }
                    this.isHoldingMouse = false;
                }
            }
        }
        
        // --- Game Data (Abilities & Enemies) ---

        const ABILITIES = {
            // Name: { dmgMult, cd(s), cost(mana), speed, radius, color, isBeam, isSpecial, key}
            'MagicShot':      { dmgMult: 1.0, cd: 0.2, cost: 5, speed: 400, radius: 8, color: '#FFA500', isBeam: false, isSpecial: false, key: '1' },
            'TriShot':        { dmgMult: 0.6, cd: 0.8, cost: 15, speed: 350, radius: 7, color: '#00BFFF', isBeam: false, isSpecial: false, key: '2' },
            'BeamShot':       { dmgMult: 3.0, cd: 2.5, cost: 30, speed: 800, radius: 4, color: '#FFFFFF', isBeam: true, isSpecial: true, key: '3' },
            'IceShard':       { dmgMult: 1.2, cd: 1.5, cost: 20, speed: 380, radius: 10, color: '#00FFFF', isBeam: false, isSpecial: true, key: '4' },
            'Lightning':      { dmgMult: 2.5, cd: 3.0, cost: 40, speed: 0, radius: 5, color: '#FFFF00', isBeam: false, isSpecial: true, key: '5' },
            'CurveShot':      { dmgMult: 1.5, cd: 2.0, cost: 25, speed: 300, radius: 8, color: '#008000', isBeam: false, isSpecial: true, key: '6' },
            'ShieldBreaker':  { dmgMult: 0.5, cd: 3.5, cost: 50, speed: 0, radius: 50, color: '#8A2BE2', isBeam: false, isSpecial: true, key: '7' },
            'HomingMissile':  { dmgMult: 2.0, cd: 4.0, cost: 60, speed: 250, radius: 12, color: '#FF0000', isBeam: false, isSpecial: true, key: '8' },
            'ForceWave':      { dmgMult: 1.0, cd: 1.5, cost: 20, speed: 450, radius: 15, color: '#1E90FF', isBeam: false, isSpecial: true, key: '9' },
            'PentaShot':      { dmgMult: 0.4, cd: 1.2, cost: 35, speed: 300, radius: 6, color: '#FFD700', isBeam: false, isSpecial: true, key: 'C' },
            'RecursiveShot':  { dmgMult: 1.8, cd: 4.5, cost: 70, speed: 200, radius: 10, color: '#00FF00', isBeam: false, isSpecial: true, key: 'V' },
            'ShieldAttack':   { dmgMult: 1.0, cd: 3.0, cost: 50, speed: 400, radius: 5, color: '#9932CC', isBeam: false, isSpecial: true, key: 'B' },
            'BetaLaser':      { dmgMult: 5.0, cd: 8.0, cost: 100, speed: 1000, radius: 8, color: '#FF0000', isBeam: true, isSpecial: true, key: 'N' },
            'SuperSpeed':     { dmgMult: 0.0, cd: 15.0, cost: 50, speed: 0, radius: 0, color: '', isBeam: false, isSpecial: true, key: 'M' },
        };
        
        const UPGRADES =;
        
        const ENEMY_CONFIG = {
            'FireMagician': { color: '#FF4500' }, // Red/Orange
            'IceMagician': { color: '#00BFFF' },   // Blue
            'ShadowMagician': { color: '#4B0082' }, // Dark Purple
            'StormMagician': { color: '#FFD700' }, // Yellow
        };
        
        // Fisher-Yates (Durstenfeld) Shuffle implementation [7]
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }
        
        // --- Game Manager ---
        
        const Game = {
            state: 'TITLE',
            input: null,
            player: null,
            enemies:,
            projectiles:,
            particles: particles,
            wave: 0,
            
            // Screen Shake
            isShaking: false,
            shakeTimer: 0,
            
            // Charge Mechanic Flag
            shootShieldProj: false,

            init() {
                this.input = new InputHandler();
                this.loadSave();
                this.startGame();
                requestAnimationFrame(this.gameLoop.bind(this));
            },
            
            startGame() {
                this.player = new Player();
                this.player.unlockedAbilities =; // Reset abilities
                this.enemies =;
                this.projectiles =;
                this.wave = 0;
                this.state = 'TITLE';
                this.updateUI();
                document.getElementById('game-state-text').innerText = "Click to Start!";
            },

            loadSave() {
                const saveData = localStorage.getItem('ALT_EVO_SAVE');
                if (saveData) {
                    // console.log("Save data loaded.");
                    // In a full implementation, player stats and unlocks would be applied here
                }
            },
            
            saveGame() {
                const saveData = {
                    maxPL: this.player.pl,
                    maxLevel: this.player.level,
                };
                localStorage.setItem('ALT_EVO_SAVE', JSON.stringify(saveData));
            },

            newWave() {
                this.wave++;
                this.player.level++; // Player level advances every wave
                this.player.xp = 0; // Reset XP
                
                // Spawn logic: 1-3 start, +1 every 3 levels, max 6
                let numEnemies = Math.min(MAX_WAVE_ENEMIES, 3 + Math.floor(this.wave / 3));
                
                // Boss every 5 levels
                if (this.wave % 5 === 0) {
                    numEnemies = 1;
                    const boss = new Enemy(W / 4, H / 4, this.wave, 'ShadowMagician');
                    boss.isBoss = true;
                    this.enemies.push(boss);
                    console.log(`WAVE ${this.wave}: BOSS SPAWNED`);
                    this.triggerScreenShake(2.0);
                } else {
                    for (let i = 0; i < numEnemies; i++) {
                        const side = Math.floor(Math.random() * 4); // Spawn from random edge
                        let x, y;
                        if (side === 0) { x = Math.random() * W; y = 0; }
                        else if (side === 1) { x = W; y = Math.random() * H; }
                        else if (side === 2) { x = Math.random() * W; y = H; }
                        else { x = 0; y = Math.random() * H; }
                        
                        const enemyTypes = Object.keys(ENEMY_CONFIG);
                        const type = enemyTypes;
                        this.enemies.push(new Enemy(x, y, this.wave, type));
                    }
                    console.log(`WAVE ${this.wave}: ${numEnemies} enemies spawned.`);
                }
                
                // Enter evolution screen
                this.state = 'EVOLUTION_SCREEN';
                this.showUpgradeMenu();
            },
            
            showUpgradeMenu() {
                document.getElementById('upgrade-menu').style.display = 'block';
                const choicesDiv = document.getElementById('upgrade-choices');
                choicesDiv.innerHTML = '';
                
                // Use Shuffle and Pop method for non-repeating upgrades [7]
                const availableUpgrades = UPGRADES.filter(u =>!u.isUsed);
                if (availableUpgrades.length < 3) {
                    // Reset pool if depleted (e.g., in an endless roguelike)
                    UPGRADES.forEach(u => u.isUsed = false);
                    shuffleArray(UPGRADES);
                }
                
                shuffleArray(availableUpgrades);
                const choices = availableUpgrades.slice(0, 3);

                choices.forEach(upgrade => {
                    const card = document.createElement('div');
                    card.className = 'upgrade-card';
                    card.innerHTML = `<h3>${upgrade.name}</h3><p>${upgrade.type} | Tier: ${upgrade.tier}</p>`;
                    card.onclick = () => this.applyUpgrade(upgrade);
                    choicesDiv.appendChild(card);
                });
            },
            
            applyUpgrade(upgrade) {
                upgrade.effect();
                upgrade.isUsed = true;
                
                // Unlock new ability
                if (upgrade.type === 'Unlock' && upgrade.effect.name === 'effect') {
                     // The unlock effect function already handles adding to unlockedAbilities
                }
                
                document.getElementById('upgrade-menu').style.display = 'none';
                this.state = 'WAVE_FIGHT';
            },

            gameOver() {
                this.state = 'GAME_OVER';
                this.saveGame();
                document.getElementById('game-state-text').innerText = `GAME OVER - Reached PL ${this.player.pl.toFixed(1)} on Wave ${this.wave}`;
                console.log("Game Over. Final PL:", this.player.pl);
                // Prompt user to restart
                setTimeout(() => this.startGame(), 5000);
            },
            
            triggerScreenShake(duration) {
                this.isShaking = true;
                this.shakeTimer = duration;
            },

            // --- Game Loop and Core Functions ---

            gameLoop(timestamp) {
                if (!Game.lastTime) Game.lastTime = timestamp;
                const deltaTime = (timestamp - Game.lastTime) / 1000; // Time in seconds [8]
                Game.lastTime = timestamp;

                if (this.state === 'TITLE') {
                    if (this.input.isMouseDown) {
                        this.state = 'WAVE_FIGHT';
                        this.newWave();
                    }
                }

                if (this.state === 'WAVE_FIGHT' |

| this.state === 'TITLE') {
                    this.update(deltaTime);
                    this.draw();
                }

                requestAnimationFrame(this.gameLoop.bind(this));
            },

            update(deltaTime) {
                // Update Screen Shake
                if (this.isShaking) {
                    this.shakeTimer -= deltaTime;
                    if (this.shakeTimer <= 0) {
                        this.isShaking = false;
                    }
                }
                
                this.player.update(deltaTime, this.input);
                this.enemies.forEach(e => e.update(deltaTime));
                this.projectiles.forEach(p => p.update(deltaTime));
                this.particles.forEach(p => p.update(deltaTime));
                
                // Cleanup
                this.enemies = this.enemies.filter(e => e.currentHp > 0);
                this.projectiles = this.projectiles.filter(p => p.active && p.position.x > 0 && p.position.x < W && p.position.y > 0 && p.position.y < H);
                this.particles = this.particles.filter(p => p.life > 0);

                this.checkCollisions();

                // Win condition check
                if (this.state === 'WAVE_FIGHT' && this.enemies.length === 0) {
                    if (this.player.xp >= this.player.xpToNextLevel) {
                         this.newWave(); // Go to next wave/level up
                    } else {
                        // Bonus XP for clearing a wave
                        this.player.xp += 100 * this.wave;
                    }
                }
                
                this.updateUI();
            },
            
            checkCollisions() {
                // Projectile vs Enemy/Player Collision
                this.projectiles.forEach(p => {
                    const targets = p.isEnemy? [this.player] : this.enemies;

                    targets.forEach(target => {
                        const distanceVector = p.position.subtract(target.position);
                        const distance = distanceVector.magnitude();
                        const sumRadii = p.radius + target.size / 2;
                        
                        if (distance < sumRadii) {
                            if (target === this.player) {
                                // Player Shield Interaction (Reflection/Absorption)
                                
                                // Calculate impact normal (normalized vector from target center to projectile center)
                                const normal = distanceVector.normalize();
                                
                                // If the shield is active, attempt absorption/reflection
                                if (this.player.shieldActive && this.player.absorbProjectile(p, p.position, normal)) {
                                    // Absorbed/Reflected - projectile is handled inside absorbProjectile
                                    return; 
                                }
                            }
                            
                            // Check Projectile Overpower (Beam vs Mana Ball)
                            if (p.isBeam && p.specialType!== 'ShieldAttack' && target.isCharging) {
                                // Beam vs Charged Ball: Beam is very effective, destroys/hurts
                                p.active = false;
                                target.takeDamage(p.getDamage(target.def) * 0.5); // Half damage through absorb
                                createExplosion(p.position.x, p.position.y, p.color, 10, 1.5);
                                return;
                            }

                            // Standard Hit
                            const damage = p.getDamage(target.def);
                            target.takeDamage(damage);
                            p.active = false;
                            createExplosion(p.position.x, p.position.y, p.color, 5, 1);
                        }
                    });

                    // Projectile vs Projectile Overpower (PL comparison)
                    this.projectiles.filter(other => other!== p && other.active && other.isEnemy!== p.isEnemy).forEach(other => {
                        const distance = p.position.subtract(other.position).magnitude();
                        if (distance < p.radius + other.radius) {
                            
                            // Overpower check: Higher PL attack pierces/ignores lower (unless specific type)
                            if (p.casterPL > other.casterPL) {
                                other.active = false; // Lower PL projectile destroyed
                                createExplosion(p.position.x, p.position.y, p.color, 5, 0.5);
                            } else if (p.casterPL < other.casterPL) {
                                p.active = false; // Lower PL projectile destroyed
                                createExplosion(other.position.x, other.position.y, other.color, 5, 0.5);
                            } else {
                                // Equal PL = mutual destroy/spark
                                p.active = false;
                                other.active = false;
                                createExplosion(p.position.x, p.position.y, '#DDD', 8, 0.8);
                            }
                        }
                    });
                });
            },

            draw() {
                // Clear the canvas
                ctx.clearRect(0, 0, W, H);

                // Apply persistent aesthetic effects (minimal black field)
                ctx.fillStyle = 'black';
                ctx.fillRect(0, 0, W, H);
                
                // Screen Shake Offset
                let offsetX = 0;
                let offsetY = 0;
                if (this.isShaking) {
                    offsetX = (Math.random() - 0.5) * 10;
                    offsetY = (Math.random() - 0.5) * 10;
                }
                
                ctx.save();
                ctx.translate(offsetX, offsetY);

                // Draw entities
                this.enemies.forEach(e => e.draw(ctx));
                this.projectiles.forEach(p => p.draw(ctx));
                this.particles.forEach(p => p.draw(ctx));
                this.player.draw(ctx);
                
                ctx.restore();
            },
            
            updateUI() {
                // Update Stat Panel
                document.getElementById('stat-level').innerText = this.player.level;
                document.getElementById('stat-xp').innerText = `${Math.floor(this.player.xp)}/${this.player.xpToNextLevel}`;
                document.getElementById('stat-pl').innerText = this.player.pl.toFixed(1);
                document.getElementById('stat-atk').innerText = this.player.atk;
                document.getElementById('stat-def').innerText = this.player.def;
                
                // Update HP/Mana Bars
                const hpRatio = this.player.currentHp / this.player.maxHp;
                const manaRatio = this.player.currentMana / this.player.maxMana;
                document.getElementById('stat-hp-text').innerText = `${Math.floor(this.player.currentHp)}/${this.player.maxHp}`;
                document.getElementById('hp-bar-fill').style.width = `${hpRatio * 100}%`;
                document.getElementById('stat-mana-text').innerText = `${Math.floor(this.player.currentMana)}/${this.player.maxMana}`;
                document.getElementById('mana-bar-fill').style.width = `${manaRatio * 100}%`;
                
                // Update Spell List UI
                const spellListUI = document.getElementById('spell-list-ui');
                let html = '<div style="font-size: 16px; margin-bottom: 5px; color: white;">Abilities (Scroll)</div>';
                
                // Get all abilities sorted by key order for consistent display
                const sortedAbilities = Object.entries(ABILITIES).sort(([, a], [, b]) => (a.key |

| '').localeCompare(b.key |
| ''));

                sortedAbilities.forEach(([name, data]) => {
                    const isUnlocked = this.player.unlockedAbilities.includes(name);
                    const isSelected = this.player.currentAttack === name;
                    const onCooldown = this.player.abilityCooldowns[name] > 0;
                    
                    let className = 'spell-item';
                    if (!isUnlocked) className += ' spell-locked';
                    if (isSelected) className += ' spell-selected';
                    if (data.isSpecial) className += ' spell-special';
                    
                    const cdText = onCooldown? ` (${this.player.abilityCooldowns[name].toFixed(1)}s)` : '';
                    const manaCost = ` [${data.cost}M]`;

                    html += `<div class="${className}">[${data.key |

| '?'}] ${name}${manaCost}${cdText}</div>`;
                });
                spellListUI.innerHTML = html;
            }
        };

        // Initialize the game when the script loads
        window.onload = () => {
             // Pre-shuffle the main upgrade pool once
             shuffleArray(UPGRADES);
             Game.init();
        };

    </script>
</body>
</html>
